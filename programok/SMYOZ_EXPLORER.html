<!DOCTYPE html>

<html lang="hu">
<head>
<script>


// HOMOKOZÓ – mindig látszó váltógomb (ELVET/FOLYTAT) a meglévő gomb újrahasznosításával.
// NINCS FSM módosítás. A felirat alapján csak fn_action('FOLYTAT' | 'ELVET') hívás történik.
(function(){
  if (typeof FOLYTATAS === 'undefined') FOLYTATAS = false;
  

  function panel(){ return document.getElementById('homokozo_panel') || document.body; }

  function findButtons(){
    var root = panel();
    var btns = root.getElementsByTagName('button');
    var elhely = null, toggle = null;
    for (var i=0;i<btns.length;i++){
      var t = (btns[i].textContent||'').trim().toUpperCase();
      if (!elhely && t.indexOf('ELHELYEZ')===0) elhely = btns[i];
    }
    for (var j=0;j<btns.length;j++){
      var u = (btns[j].textContent||'').trim().toUpperCase();
      if (u==='ELVET' || u==='FOLYTAT'){ toggle = btns[j]; break; }
    }
    return {elhely:elhely, toggle:toggle};
  }

  function setLabel(){
    var pair = findButtons();
    if (!pair.toggle) return;
    var st = (typeof window.__elh_state__==='number') ? window.__elh_state__ : 0;
    pair.toggle.textContent = (st===0 ? 'FOLYTAT' : 'ELVET');
    pair.toggle.style.display=''; pair.toggle.hidden=false; pair.toggle.style.visibility='';
  }

  function bind(){
    var pair = findButtons();
    var elh = pair.elhely;
    var tog = pair.toggle;
    if (!tog) return;

    if (!tog.__bound_toggle){
      tog.addEventListener('click', function(){
        var lab = (tog.textContent||'').trim().toUpperCase();
        if (lab === 'FOLYTAT'){
          if (typeof window.fn_action === 'function') window.fn_action('FOLYTAT');
        } else {
          if (typeof window.fn_action === 'function') window.fn_action('ELVET');
        }
      }, false);
      tog.__bound_toggle = true;
    }

    if (elh && !elh.__bound_label){
      elh.addEventListener('click', function(){
        var p = findButtons();
        if (p.toggle) p.toggle.textContent = 'ELVET';
      }, true);
      elh.__bound_label = true;
    }
  }

  function init(){ bind(); setLabel(); }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>

<script>

window.SMY = window.SMY || {};
SMY.changed = false;
</script>
<!-- SMY STEP1 - built 2025-10-28 15:52:10 -->

<script id="SMY_STEP1_GLOBALS">

(function(){
  if(!window.SMY) window.SMY = {};
  const S = window.SMY;
  const N = 9;
  function alloc2D(n,m,v){ const A=new Array(n); for(let i=0;i<n;i++){ const r=new Array(m); for(let j=0;j<m;j++) r[j]=v; A[i]=r; } return A; }
  
  S.MATRIX_INPUT = S.MATRIX_INPUT || alloc2D(N,N,'---');
  S.MATRIX_REAL  = S.MATRIX_REAL  || alloc2D(N,N,'---');
  S.MATRIX_SNAP  = S.MATRIX_SNAP  || alloc2D(N,N,'---');
  
  S.POINTS_INPUT = S.POINTS_INPUT || alloc2D(N,N,'-');
  S.POINTS_REAL  = S.POINTS_REAL  || alloc2D(N,N,'-');
  S.POINTS_SNAP  = S.POINTS_SNAP  || alloc2D(N,N,'-');
  
  S.M_SHOT = S.M_SHOT || alloc2D(N,N,'---');
  S.P_SHOT = S.P_SHOT || alloc2D(N,N,'-');
  S.ISHOT_REAL = S.ISHOT_REAL || alloc2D(N,N,false);
  S.ISHOT_SNAP = S.ISHOT_SNAP || alloc2D(N,N,false);
  // HOMOK – logikai 9x9 mátrix (0 = hamis)
  S.HOMOK_REAL = S.HOMOK_REAL || alloc2D(N,N,false);
  S.HOMOK_SNAP = S.HOMOK_SNAP || alloc2D(N,N,false);
  
  S.M_REAL = S.MATRIX_REAL;
  S.P_REAL = S.POINTS_REAL;
  
  const fill1d = (n,v) => Array.from({length:n},()=>v);
  S.SOROK_REAL = fill1d(N,'-');
  S.OSZL_REAL  = fill1d(N,'-');
  
})();



// === UI writers for header boxes (minimal, explicit) ===
function writeLeltarPanel(){
  var box = document.getElementById('szigOrigBox');
  if(!box) return;
  var ls = (typeof LELTAR !== 'undefined' && LELTAR && LELTAR.lSZ);
  box.textContent = (Array.isArray(ls) && ls.length) ? ls.join(' - ') : '-';
}
function writeFoundIslandsPanel(sizes){
  var box = document.getElementById('szigBox');
  if(!box) return;
  sizes = Array.isArray(sizes) ? sizes : [];
  box.textContent = sizes.length ? sizes.join(' - ') : '-';
}

</script>
<!-- STEP5: Kirajzolási fallback - REAL szín hiányában (--) a SHOT 3-karakteres kódját írjuk ki -->
<script id="SMY_STEP5_FALLBACK">
(function(){
  if(!window.SMY) return;
  const S = window.SMY;
  const N = S.N || 9;

  function needFallback(realCode){
    return (typeof realCode === 'string' && realCode.length>=3 && realCode.slice(1)==='--');
  }

  function drawShotFallbackText(){ 
    {
      for(let r=0;r<N;r++){
        for(let c=0;c<N;c++){
          const real = (S.M_REAL && S.M_REAL[r]) ? S.M_REAL[r][c] : null;
          if(!needFallback(real)) continue;
          const shot = (S.M_SHOT && S.M_SHOT[r]) ? S.M_SHOT[r][c] : null;
          if(typeof shot !== 'string' || shot.length!==3) continue;
          const el = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
          if(!el) continue;
          const main = el.querySelector('.cellTextMain');
          const sub  = el.querySelector('.cellTextSub');
          if(main) main.textContent = shot;   
          if(sub)  sub.textContent  = '';     
        }
      }
    }
  }

  // Export + optional auto-call hook
  S.drawShotFallbackText = drawShotFallbackText;
  
})();
</script>
<!-- STEP4: Determinisztikus promóció SHOT->REAL (típus + pp/zz/xx színek) -->
<script id="SMY_STEP4_PROMO">
(function(){
  if(!window.SMY) window.SMY = {};
  const S = window.SMY;
  const N = S.N || 9;

  function isCellCode(x){
    return (typeof x === "string") && x.length === 3;
  }
  function detColor(cc){
    if(cc === "pp" || cc === "zz" || cc === "xx") return cc;
    return null; 
  }
  function promoteCellDeterministic(r,c){
    try{
      const shot = (S.M_SHOT && S.M_SHOT[r]) ? S.M_SHOT[r][c] : null;
      if(!isCellCode(shot)) return false;
      const T = shot[0];
      const CC = shot.slice(1);
      const dc = detColor(CC);
      const colorOut = dc ? dc : "--";
      if(S.M_REAL && S.M_REAL[r]){
        S.M_REAL[r][c] = T + colorOut;
      }
      return true;
    }catch(e){
      
      return false;
    }
  }
  function applyAllDeterministic(){
    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        promoteCellDeterministic(r,c);
      }
    }
    
  }

  
  if(!S.PROMO) S.PROMO = {};
  S.PROMO.promoteCellDeterministic = promoteCellDeterministic;
  S.PROMO.applyAllDeterministic = applyAllDeterministic;
  
})();
</script>


<!-- STEP3: Lokális SHOT->REAL promóció CSAK interaktív írásnál (wrap setCell*), semmi más -->
<script id="SMY_STEP3_LOCAL_PROMO">
(function(){
  {
    if(!window.SMY){  return; }
    const S = window.SMY;
    const N = 9;
    function promoteCell(r,c){
      try{
        if(S.M_SHOT && S.M_REAL){ S.M_REAL[r][c] = S.M_SHOT[r][c]; }
        if(S.P_SHOT && S.P_REAL){ S.P_REAL[r][c] = S.P_SHOT[r][c]; }
      }catch(e){  }
    }
    function wrapSetter(fnName){
      const orig = window[fnName];
      if(typeof orig !== "function") return false;
      window[fnName] = function(r,c, ...rest){
        const ret = orig.apply(this, [r,c, ...rest]);
        promoteCell(r,c);
        
        return ret;
      };
      return true;
    }
    const wrapped = [];
    ["setCellWater","setCellShip","setCell"].forEach(n=>{ if(wrapSetter(n)) wrapped.push(n); });
    
  }
})();
</script>


<!-- STEP2: I2S - INPUT -> SHOT strict copy (nincs auto SHOT->REAL) -->
<script id="SMY_STEP2_I2S">
(function(){
  
  {
    if(!window.SMY){  return; }
    const S = window.SMY;
    
    function copy2D(dst,src){
      try{
        if(!dst || !src) return;
        const R = Math.min(dst.length, src.length);
        const C = R ? Math.min(dst[0].length, src[0].length) : 0;
        for(let i=0;i<R;i++){ for(let j=0;j<C;j++){ dst[i][j] = src[i][j]; } }
      }catch(e){  }
    }
    if(!S.MATRIX_INPUT || !S.M_SHOT || !S.POINTS_INPUT || !S.P_SHOT){
       return;
    }
    copy2D(S.M_SHOT,   S.MATRIX_INPUT);
    copy2D(S.P_SHOT,   S.POINTS_INPUT);
    
    if(window.SMY && SMY.PROMO && typeof SMY.PROMO.applyAllDeterministic==='function'){
      SMY.PROMO.applyAllDeterministic();
    }
    
  try{
    
    if(!window.SMY){ window.SMY = {}; }
    if(!SMY.M_REAL) SMY.M_REAL = [];
    if(!SMY.P_REAL) SMY.P_REAL = [];
    function _to3(v){
      try{
        
        if (typeof v === 'string') {
          if (v.length >= 3) return v.substring(0,3);
          if (v.length === 2) return (v + '-').substring(0,3);
          if (v.length === 1) return (v + '--').substring(0,3);
          return '---';
        }

        
        if (v && typeof v.main === 'string') {
          var T = v.main.charAt(0) || '-';
          var col = '';
          if (typeof v.color === 'string' && v.color.length > 0) {
            col = v.color;
          }
          if (col.length === 1) {
            col = col + '-';
          } else if (col.length >= 2) {
            col = col.substring(0,2);
          } else {
            col = '--';
          }
          return (T + col).substring(0,3);
        }

        // 3) Ha van realCell mező ÉS nincs main, azt használjuk fallback-ként
        if (v && typeof v.realCell === 'string' && v.realCell.length >= 3) {
          return v.realCell.substring(0,3);
        }
      }catch(_){}
      
      return '---';
    }

    // Shore color normalization:
    // On the shore (edge) the red ('p') may only be parallel to the shore.
    // - Top/bottom edge: red must be in the horizontal component (3rd char).
    // - Left/right edge: red must be in the vertical component (2nd char).
    // Corners are left unchanged (either orientation is parallel to a shore).
    function _shoreNorm3(r,c,code3){
      try{
        if (typeof code3 !== 'string' || code3.length < 3) return code3;
        var T = code3.charAt(0);
        var v = code3.charAt(1);
        var h = code3.charAt(2);

        var N9 = (typeof N === 'number') ? N : ((typeof SMY !== 'undefined' && SMY && SMY.M_REAL && SMY.M_REAL.length) ? SMY.M_REAL.length : 9);

        var onTop = (r === 0);
        var onBottom = (r === (N9 - 1));
        var onLeft = (c === 0);
        var onRight = (c === (N9 - 1));
        if (!(onTop || onBottom || onLeft || onRight)) return code3;

        // Corner: either direction is parallel to some shore
        if ((onTop || onBottom) && (onLeft || onRight)) return code3;

        if (onTop || onBottom){
          // horizontal shore: 'p' must be horizontal (h)
          if (v === 'p' && h !== 'p'){
            var tmp = v; v = h; h = tmp;
          }
        } else if (onLeft || onRight){
          // vertical shore: 'p' must be vertical (v)
          if (h === 'p' && v !== 'p'){
            var tmp2 = v; v = h; h = tmp2;
          }
        }
        return (T + v + h);
      }catch(_){}
      return code3;
    }

    function _bridgeRowM(r){
      if (typeof workM === 'undefined' || !workM || !workM[r]) return;
      var row = workM[r];
      if (row && !row.__SMY_BRIDGED__){
        workM[r] = new Proxy(row, {
          set(target, prop, val){
            target[prop] = val;
            var c = Number(prop);
            if (!Number.isNaN(c)){
              if (!SMY.M_REAL[r]) SMY.M_REAL[r] = [];
              var __code = _to3(val);
              __code = _shoreNorm3(r,c,__code);
              SMY.M_REAL[r][c] = __code;
              
            }
            return true;
          }
        });
        workM[r].__SMY_BRIDGED__ = true;
      }
    }
    /*  function _bridgeRowP(r){
      if(typeof workP === 'undefined' || !workP || !workP[r]) return;
      var row = workP[r];
      if(row && !row.__SMY_BRIDGED__){
        workP[r] = new Proxy(row, {
          set(target, prop, val){
            target[prop] = val;
            var c = Number(prop);
            if(!Number.isNaN(c)){
              if(!SMY.P_REAL[r]) SMY.P_REAL[r] = [];
              SMY.P_REAL[r][c] = val;
            }
            return true;
          }
        });
        workP[r].__SMY_BRIDGED__ = true;
      }
    }*/ 
    window.debugCheckRealVsWork = function(label){
      try{
        if (typeof window.SMY === 'undefined' || !window.SMY) return;
        var S = window.SMY;
        var MR = S.M_REAL;
        if (!MR || typeof workM === 'undefined' || !workM) return;
        var maxRows = Math.min(MR.length || 0, workM.length || 0);
        if (!maxRows) return;
        var tag = label ? String(label) : '';
        for (var r = 0; r < maxRows; r++){
          var rowReal = MR[r];
          var rowWork = workM[r];
          if (!rowReal || !rowWork) continue;
          var maxCols = Math.min(rowReal.length || 0, rowWork.length || 0);
          for (var c = 0; c < maxCols; c++){
            var vWork = _to3(rowWork[c]);
            var vReal = rowReal[c] || '---';
            if (vReal !== vWork){
              
            }
          }
        }
      }catch(e){
        
      }
    };

    window.mergeRealAndWorkTypes = function()
	{
      try{
        if (typeof window.SMY === 'undefined' || !window.SMY) return;
        if (typeof workM === 'undefined' || !workM) return;
        var S = window.SMY;
        var MR = S.M_REAL;
        if (!MR) return;
        var maxRows = Math.min(MR.length || 0, workM.length || 0);
        if (!maxRows) return;

        function shipLike(t){
          return t === 'A' || t === 'B' || t === 'G' || t === 'D' || t === 'H';
        }
        function waterLike(t){
          return t === '0' || t === '1' || t === '2' || t === '3' || t === '4' || t === 'V';
        }

        for (var r = 0; r < maxRows; r++)
		{
          var rowReal = MR[r];
          var rowWork = workM[r];
          if (!rowReal || !rowWork) continue;
          var maxCols = Math.min(rowReal.length || 0, rowWork.length || 0);
          for (var c = 0; c < maxCols; c++)
		  {
		    if (workP[r][c] !== SMY.P_REAL[r][c])
			{ 
			   if (workP[r][c] !== '-') SMY.P_REAL[r][c] = workP[r][c];
			   else
			   if (SMY.P_REAL[r][c] !== '-') workP[r][c] = SMY.P_REAL[r][c];
			}
            var cellR = rowReal[c] || '---';
            var Tr = (cellR.charAt(0) || '-').toUpperCase();

            var w = rowWork[c];
            var Tw = '-';
            if (w)
			{
              if (typeof w.main === 'string' && w.main.length)
			  {
                Tw = w.main.charAt(0).toUpperCase();
              } 
            }

            var newTr = Tr;
            var newTw = Tw;

            // Ha az egyik ismeretlen, átveheti a másik T-t
            if (Tr === '-' && Tw !== '-'){ newTr = Tw;  } 
			else 
			if (Tw === '-' && Tr !== '-'){ newTw = Tr;  } 
			else 
			if (Tr !== '-' && Tw !== '-')
			{
              var shipR = shipLike(Tr);
              var shipW = shipLike(Tw);
              var waterR = waterLike(Tr);
              var waterW = waterLike(Tw);

              
              if ((shipR && waterW) || (waterR && shipW)){ } // semmit nem módosítunk  
			  else 
			  if (shipR && shipW)         
			  {
                  if (Tr === Tw){ }       
			  	  else 
				  if (Tr === 'H' && (Tw === 'A' || Tw === 'B' || Tw === 'G' || Tw === 'D'))
				  { newTr = Tw; }
				  else 
				  if (Tw === 'H' && (Tr === 'A' || Tr === 'B' || Tr === 'G' || Tr === 'D'))
				  { newTw = Tr; }
              } 
			  else 
			  if (waterR && waterW)        
			  {
           
                var isNumR = (Tr >= '0' && Tr <= '4');
                var isNumW = (Tw >= '0' && Tw <= '4');
                if (Tr === Tw){ }     
				else 
				if (Tr === 'V' && isNumW){ newTr = Tw; }
				else 
				if (Tw === 'V' && isNumR){ newTw = Tr; }
              }
            }

            // Visszaírás M_REAL-ba
            if (newTr !== Tr)
		    {
              var col = (cellR + '---').substring(1,3);
              rowReal[c] = (newTr + col).substring(0,3);
            }

            
            if (newTw !== Tw)
			{
              if (!w && newTw !== '-')
			  {
                
                w = {};
                rowWork[c] = w;
              }
              if (w)
			  {
                w.main = newTw;
                
                if (shipLike(newTw)) { w.kind = 'ship'; }
				else 
				if (waterLike(newTw)){ w.kind = 'water'; } 
				else { w.kind = '-'; }
                // realCell opcionális frissítése
                /* try {
                  if (typeof _to3 === 'function'){
                    w.realCell = _to3(w);
                  }
                }catch(_){}  */
              }
            }
          }
        }
      
        // AUTO 10/b: kikötött hajó két oldalán a parton vízmező 'V' (színek megtartása)
        try{
          const _auto10_on = (typeof window.CFG!=='undefined' && window.CFG && CFG.auto) ? (CFG.auto.auto10 !== false) : true;
          if (_auto10_on && typeof window.auto_10_shoreSideWater === 'function'){
            window.auto_10_shoreSideWater();
          }
        }catch(_e){}

        // Fejléc (vízvonalak/szigetek/kikötések) frissítése teljes táblás átfésülés után
        try{ if (typeof window.refreshTopBoxes === 'function') window.refreshTopBoxes(); }catch(_e2){}
}catch(e){
        
      }
    };

function bridgeWorkToSMY(){try{
        if(window.workM){
          for(var r=0; r<workM.length; r++){
            _bridgeRowM(r);
            
            if(!SMY.M_REAL[r]) SMY.M_REAL[r]=[];
            for(var c=0; c<workM[r].length; c++){
              var __code2 = _to3(workM[r][c]);
              SMY.M_REAL[r][c] = _shoreNorm3(r,c,__code2);
              
            }
          }
        }
        if(typeof workP !== 'undefined' && workP){
          for(var r=0; r<workP.length; r++){
            _bridgeRowP(r);
            if(!SMY.P_REAL[r]) SMY.P_REAL[r]=[];
            for(var c=0; c<workP[r].length; c++){
              SMY.P_REAL[r][c] = workP[r][c];
            }
          }
        }
        }catch(e){  }
    }
    bridgeWorkToSMY();
  }catch(e){}


    }
})();
</script>


<meta charset="utf-8"/>

<meta content="width=device-width,initial-scale=1" name="viewport"/>
<style>
  :root{
    --bg:#eef6ff; --fg:#0b2b40; --muted:#3b556b; --card:#fff; --accent:#1976d2;
    --free:#f4f4f6; --water:#a3d9ff; --ship:#123a66;
    --grid:#d3e9ff; --shadow:0 8px 24px rgba(20,40,60,.08);
  }
  *{box-sizing:border-box}
  body{margin:0; background:var(--bg); color:var(--fg); font-family:Arial,Helvetica,sans-serif; min-height:100vh; display:flex; flex-direction:column; gap:10px}
  header{background:#375e97; color:#fff; padding:12px 10px; text-align:center; font-weight:800; letter-spacing:.3px}
  .topwrap{display:flex; flex-direction:column; align-items:center; gap:6px; padding:8px 0}
  .infoRow{display:flex; gap:12px; width:860px; justify-content:space-between}
  
  .infoRow .ibox .cap{ font-size:13px; }
  .infoRow .ibox .val{ font-size:16px; }

  .ibox{width:270px; background:#ffffff; border:1px solid #cfe1ff; border-radius:8px; box-shadow:var(--shadow); padding:8px 10px; text-align:center}
  .ibox .cap{font-size:12px; color:var(--muted); margin-bottom:2px}
  .ibox .val{font-family:"Courier New",monospace; font-weight:800; font-size:16px; min-height:1.2em}
  .sumRow{width:860px; text-align:center; background:#ffffff; border:1px solid #cfe1ff; border-radius:8px; padding:6px 10px; box-shadow:var(--shadow); font-family:"Courier New",monospace; font-size:15px; font-weight:400}
  
  .sumRow{ font-size:16px; white-space:nowrap; }
  /* Ensure Lövések sor matches Vízvonalak sor typography */
  .sumRow{font-family:"Courier New",monospace; font-size:16px; font-weight:800;}

  .sumRow .sum-var{ font-weight:800; }

  .hud-dyn{font-weight:800;}

  .toolbar{background:#f9fbff; border-top:2px solid #cfe1ff; border-bottom:2px solid #cfe1ff; box-shadow:var(--shadow);
    padding:10px; display:grid; grid-template-columns: 1fr; gap:10px; align-items:center; justify-content:center}
  .group{display:flex; flex-direction:column; gap:8px; align-items:stretch}
  .mono{font-family:"Courier New",monospace; font-weight:400;}
  textarea.mono{width:100%; min-height:120px; resize:vertical; padding:8px; border:1px solid #cbd; border-radius:8px; background:#fff}
  button{border:0; background:var(--accent); color:#fff; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:800}
  button.ghost{background:#e7f0ff; color:#0b2b40}
  input[type="text"]{padding:6px 8px; border:1px solid #cbd; border-radius:8px; font-family:"Courier New",monospace; font-weight:400}

  .main{display:grid; grid-template-columns: 320px 240px 1fr 360px; gap:12px; padding:12px; justify-content:center; max-width:1180px; margin:-3px auto 0 auto; box-sizing:border-box}
  .card{background:#fff; border-radius:12px; box-shadow:var(--shadow); padding:12px}
  h2{margin:0 0 8px}

  .shipCol{font-family:"Courier New",monospace; font-weight:500; font-size:17px; line-height:1.35}
  .shipType{font-weight:800; color:#0b2b40; margin-top:6px}
  .shipVals{margin-left:10px}

  .boardWrap{display:flex; flex-direction:column; align-items:center; gap:14px}
  .frame{position:relative; width:510px; height:510px; background:var(--grid); border:2px solid #123; border-radius:8px; overflow:visible}
  #grid{ display:grid; grid-template-columns: repeat(9, 1fr); grid-auto-rows: 1fr; gap:0; width:100%; height:100%; }
  .cell{border:1px solid rgba(0,0,0,0.08); background:var(--free); position:relative}
  .cell.water{background:var(--water)}
  .cell.ship{ background:var(--ship) }
  .cellTextMain{position:absolute; left:50%; top:46%; transform:translate(-50%,-50%); font-family:"Courier New",monospace; font-weight:800; font-size:22px; color:#062e4f; pointer-events:none; z-index:4}
  .cellTextSub{position:absolute; left:50%; top:66%; transform:translate(-50%,-50%); font-family:"Courier New",monospace; font-weight:800; font-size:16px; color:#444444; pointer-events:none; z-index:4}
  .cell.ship .cellTextMain{ color:#fff }
  .cell.ship .cellTextSub{ color:#e9f3ff }

  
  svg#indexLayer{position:absolute; inset:-28px -28px -46px -28px; width:calc(100% + 56px); height:calc(100% + 74px); pointer-events:none}
  .indexText{ font-size:12px; fill: #333; font-family:"Courier New",monospace; font-weight:400 }
  
  .pt-water{fill:none; stroke:#147ad6; stroke-width:2}
  .pt-ship{fill:#222}
  .pt-free{fill:none; stroke:#000; stroke-width:3}
  .seg-water{stroke:#147ad6; stroke-width:2}

  .kv{display:grid; grid-template-columns: 1fr 1fr; gap:6px; margin-top:6px}
  .kv div{background:#f7fbff; border:1px solid #cfe1ff; border-radius:8px; padding:6px; font-family:"Courier New",monospace; font-weight:400; font-size:13px}
  .kv .t{font-weight:800; color:#123}

  
  .cellTextSub span.p,.cellTextSub span.z,.cellTextSub span.x{
  font-size:18px;
  font-weight:900;
  position:relative;
  top:2px;
}
.cellTextSub span.p{ color:#ff0000; }
.cellTextSub span.z{
  color:#00aa00;
  text-shadow:0 0 2px #003300;
}
.cellTextSub span.x{ color:yellow; }
  
  #autoRows{ display:flex; flex-wrap:wrap; gap:8px 14px; align-items:center; font-size:13px; color:#123; }
  #autoRows>label{ white-space:nowrap; display:inline-flex; align-items:center; gap:6px; }
  
  #alfaIndicator{ background:#ff00ff; }
  #alfaIndicatorLabel{ color:#ff00ff; }

#indexInput.hint{opacity:1} #indexInput::placeholder{opacity:1; color:#111}


#diagPaneFloat2{position:fixed;right:12px;top:12px;width:340px;max-height:80vh;overflow:auto;background:#fff;border:1px solid #e5e7eb;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.15);padding:12px;z-index:99999;display:none}
#diagPaneFloat2 h3{margin:0 8px 10px;font-size:16px}
#diagPaneFloat2 .row{display:flex;justify-content:space-between;gap:10px;padding:3px 0;border-bottom:1px dashed #eee}
#diagPaneFloat2 .row:last-child{border-bottom:none}
#diagPaneFloat2 .lbl{color:#374151}
#diagPaneFloat2 .val{font-weight:700;font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
#btnDiagFloat2{position:fixed; right:80mm; bottom:8mm; z-index:9999; background:#111827; color:#fff; border:1px solid #0f172a; border-radius:10px; padding:8px 10px;}


#shipCol.shipCol { display:flex; flex-direction:column; gap:4px; }
.shipGroup { margin-top:6px; font-weight:800; }
.shipItem { position:relative; padding-left:22px; display:flex; align-items:center; gap:8px; }

.shipItem::before{ display:none !important; }


#hudTopRight, .hud-top-right{ display:none !important; }


  
  .shipVal { min-width:26px; text-align:right; font-weight:600; }
  .shipCheck { width:18px; height:18px; }


.main > .card{
  margin-left:0 !important;
}
.main > .card:first-child{
  margin-right:8mm;
}
#homokozo_card{
  margin-left:0 !important;
}


/* DOKU toggle: only reorders the three top blocks; board and main layout stay unchanged */
header{position:relative}
.dokuToggle{position:absolute; right:12px; top:50%; transform:translateY(-50%); font-size:12px; font-weight:800;
  background:rgba(255,255,255,.16); padding:4px 8px; border-radius:10px; cursor:pointer; user-select:none; white-space:nowrap;}
.dokuToggle input{margin-right:6px; vertical-align:middle}

#topBlocks{display:flex; flex-direction:column}
.topwrap{display:flex; flex-direction:column}
.topwrap .infoRow{order:1}
.topwrap #sumRow{order:2}
.toolbar{order:3}

#topBlocks.doku-on .toolbar{order:1}
#topBlocks.doku-on .topwrap{order:2}
#topBlocks.doku-on .topwrap #sumRow{order:1}
#topBlocks.doku-on .topwrap .infoRow{order:2}

/* In DOKU módban: a Lövések sor és a Vízvonalak—Kikötések sor betűi legyenek teljesen azonosak (típus/méret/vastagság) */
#topBlocks.doku-on #sumRow,
#topBlocks.doku-on .infoRow .ibox .val{
  font-family: Arial, Helvetica, sans-serif;
  font-size: 16px;
  font-weight: 700;
  color: var(--fg);
}


</style>
<script>

let __isRestoring = false;
let __lastRestoreTime = 0; 

function appendMuhely(txt){
    {
      var padRow = document.querySelector('#homokozo_panel').firstElementChild.children[1];
      var pad = padRow.querySelector('div[style*="width:70px"][style*="height:70px"]');
      if(pad){
        pad.textContent = (pad.textContent||'') + "\n" + txt;
      }
    }
  }
  function fn_hajo(){
    appendMuhely('[fn:HAJÓ]');
  }


// === SMY helper: run autos to fixpoint, but keep AUT18 strictly last ===
window.SMY_runAllAutosFixpoint18Last = function(reason){
  if (typeof window.runAllAutosPass !== 'function') return 0;

  var total = 0;
  var fnAuto18 = (typeof window.auto_18_extend_partial_ship === 'function')
    ? window.auto_18_extend_partial_ship
    : undefined;

  for (var k = 0; k < 100; k++){
    if (typeof window.mergeRealAndWorkTypes === 'function') window.mergeRealAndWorkTypes();

    // 1) Fixpoint for ALL enabled autos except AUT18
    for (var pass = 0; pass < 100; pass++){
      if (typeof window.mergeRealAndWorkTypes === 'function') window.mergeRealAndWorkTypes();

      window.VALTOZAS = false;

      var hadCFG = (typeof CFG !== 'undefined' && CFG && CFG.auto);
      var hadOld18 = hadCFG && Object.prototype.hasOwnProperty.call(CFG.auto, 'auto18');
      var saved18 = hadOld18 ? CFG.auto['auto18'] : undefined;
      if (hadCFG) CFG.auto['auto18'] = false;

      var a = 0;
      try{ a = (window.runAllAutosPass()|0); }catch(_e){ a = 0; }
      total += (a|0);

      if (hadCFG){
        if (hadOld18) CFG.auto['auto18'] = saved18;
        else delete CFG.auto['auto18'];
      }

      if (window.VALTOZAS || a) continue;

      break; // stable without AUT18
    }

    // 2) One AUT18 step (if enabled) – only after 21 is fully applied
    var allow18 = !(typeof CFG !== 'undefined' && CFG && CFG.auto && CFG.auto['auto18'] === false);
    if (allow18 && fnAuto18){
      // Force-run 21 (extendFromPairs) to fixpoint BEFORE AUT18 (even if 21 is OFF).
      try{
        var fn21 = window.auto_21_extendFromPairs;
        if (typeof fn21 === 'function'){
          var hadCFG21 = (typeof CFG !== 'undefined' && CFG && CFG.auto);
          var hadOld21 = hadCFG21 && Object.prototype.hasOwnProperty.call(CFG.auto, 'extendFromPairs');
          var saved21 = hadOld21 ? CFG.auto['extendFromPairs'] : undefined;
          if (hadCFG21) CFG.auto['extendFromPairs'] = true;

          for (var t = 0; t < 100; t++){
            var r = 0;
            try{ r = (fn21()|0); }catch(_e){ r = 0; }
            total += (r|0);
            if (!r) break;
          }

          if (hadCFG21){
            if (hadOld21) CFG.auto['extendFromPairs'] = saved21;
            else delete CFG.auto['extendFromPairs'];
          }
        }
      }catch(_e){}

      window.VALTOZAS = false;
      var a18 = 0;
      try{ a18 = (fnAuto18()|0); }catch(_e){ a18 = 0; }
      total += (a18|0);

      if (window.VALTOZAS || a18){
        continue; // AUT18 changed -> rerun other autos to fixpoint again
      }
    }

    break; // fully stable
  }

  return total;
};

  document.addEventListener('DOMContentLoaded', function(){
    {
      var row3 = document.querySelector('#homokozo_panel').firstElementChild.children[2];
      if(row3){
        var hajobtn = Array.from(row3.querySelectorAll('button')).find(b=> (b.textContent||'').trim()==='HAJÓ');
        if(hajobtn && !hajobtn.__fn){
          hajobtn.addEventListener('click', fn_hajo);
          hajobtn.__fn = true;
        }
      }
    }
  });

window.removeAlfaIndicator = window.removeAlfaIndicator || function(){
  document.getElementById('alfaIndicator')?.remove();
  document.getElementById('alfaIndicatorLabel')?.remove();
};


/* ====== Automatizmus 6 (DINAMIKUS maxméret a LELTAR.lSZ alapján) ======
   Szabály:
   - LELTAR.lSZ: a cél szigethosszak multihalmaza (pl. [1,2,2,3,5]).
   - Zárt (nem bővíthető) V-szigetek (nincs szomszédos SZABAD pont) méretei levonódnak a készletből.
   - A "még szabad maximális méret" = a fennmaradó készlet maximuma.
   - Minden olyan V-sziget, amelyik elérte ezt a maximális méretet, körben a SZABAD pontok H lesznek.
*/
window.auto_6_fromMaxIsland = function auto_6_fromMaxIsland(){
  

  try{
    const _t0 = performance && performance.now ? performance.now() : Date.now();
const S = window.SMY || window.S || {};
    const P = (typeof workP !== 'undefined' && workP) ? workP : (S && S.workP ? S.workP : null);
    if(!P) return;
    const N9 = (typeof N==='number') ? N : 9;
    const NP = N9 - 1; 

    const target = (typeof LELTAR !== 'undefined' && LELTAR && Array.isArray(LELTAR.lSZ)) ? LELTAR.lSZ.slice() : null;
    if(!target || !target.length) return;

    
    const isFree = (v)=> (v===null || typeof v==='undefined' || v==='-' );

    // --- Freq map generátor
    const freq = (arr)=>{
      const m = Object.create(null);
      for(const x of arr){ m[x] = (m[x]||0)+1; }
      return m;
    };

    
    
    
    const seen = Array.from({length:NP}, ()=>Array(NP).fill(false));
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    const comps = []; 

    for(let r=0;r<NP;r++){
      for(let c=0;c<NP;c++){
        if(seen[r][c]) continue;
        if((P[r]||[])[c] !== 'V') continue;
        
        let stack=[[r,c]], cells=[], hasFree=false;
        seen[r][c]=true;
        while(stack.length){
          const [rr,cc] = stack.pop();
          cells.push([rr,cc]);
          for(const [dr,dc] of dirs){
            const nr=rr+dr, nc=cc+dc;
            if(nr<0||nc<0||nr>=NP||nc>=NP) continue;
            const val = (P[nr]||[])[nc];
            if(val==='V' && !seen[nr][nc]){ seen[nr][nc]=true; stack.push([nr,nc]); }
            else if(isFree(val)){ hasFree = true; } 
          }
        }
        comps.push({cells, size: cells.length, hasFreeNeighbor: hasFree});
      }
    }

    
    const closedSizes = comps.filter(k=>!k.hasFreeNeighbor).map(k=>k.size);
    const need = (function(arr){ const m=Object.create(null); for(const x of arr){ m[x]=(m[x]||0)+1; } return m; })(target);
    const used = (function(arr){ const m=Object.create(null); for(const x of arr){ m[x]=(m[x]||0)+1; } return m; })(closedSizes);

    
    const remaining = Object.create(null);
    for(const s in need){
      const a = need[s]||0, b = used[s]||0;
      remaining[s] = Math.max(0, a-b);
    }

    
    let curMax = null;
    for(const s in remaining){
      if(remaining[s]>0){
        const si = parseInt(s,10);
        if(!isNaN(si) && (curMax===null || si>curMax)) curMax = si;
      }
    }

    
    if (!window.SMY) window.SMY = {};
    window.SMY.MAX_ISLAND_REMAINING = (curMax===null ? null : curMax);

    
      void 0;
      void 0;
      void 0;

    
    {
      (function markIslandsList(){
        
        const closedFreq = (function(a){ const m=Object.create(null); a.forEach(x=>m[x]=(m[x]||0)+1); return m; })(closedSizes);
        const cont = document.querySelector('#SZIGETEK_LISTA, #LELTAR_SZIGETEK, .leltar-szigetek');
        if(!cont) return;

        /* removed auto6-style injection */
        
        let html='Szigetek: ';
        const usedCount = Object.create(null);
        for(const sz of target){
          const key = String(sz);
          const used = usedCount[key]||0;
          const quota = closedFreq[key]||0;
          const closed = used < quota;
          usedCount[key] = used + 1;
          const cls = ['szg-token'];
          if (closed) cls.push('szg-closed');
          if (curMax!==null && sz===curMax) cls.push('szg-max');
          html += `<span class="${cls.join(' ')}">${sz}</span><span class="szg-dash"> - </span>`;
        }
        cont.innerHTML = html.replace(/ - \s*$/,'');
      })();
    }

    if(curMax===null){
      const _t1 = performance && performance.now ? performance.now() : Date.now();
      return;
    }

    
    for(const k of comps){
      let converted = [];
      if(k.size === curMax){
        void 0;
        for(const [rr,cc] of k.cells){
          for(const [dr,dc] of dirs){
            const nr=rr+dr, nc=cc+dc;
            if(nr<0||nc<0||nr>=NP||nc>=NP) continue;
            const val = (P[nr]||[])[nc];
            if(isFree(val)){
              converted.push([nr,nc]);
              
              if(!P[nr]) P[nr] = [];
              P[nr][nc] = 'H';
            }
          }
        }
        if (converted.length){
          void 0;
        } else {
          void 0;
        }
      }
    }

    const _t1 = performance && performance.now ? performance.now() : Date.now();
  }catch(e){
  }
}/* ====== Automatizmus 6b (hajópont körül 3 víz + 1 szabad → hajó) ====== */
function auto_6b_fromShipPoints(){
  

  var MR;
  if (typeof SMY !== 'undefined' && SMY && SMY.M_REAL) {
    MR = SMY.M_REAL;
  } else if (typeof M_REAL !== 'undefined') {
    MR = M_REAL;
  }

  var PR;
  if (typeof SMY !== 'undefined' && SMY && SMY.P_REAL) {
    PR = SMY.P_REAL;
  } else if (typeof P_REAL !== 'undefined') {
    PR = P_REAL;
  }

  var WM;
  if (typeof window !== 'undefined' && typeof window.workM !== 'undefined') {
    WM = window.workM;
  } else if (typeof workM !== 'undefined') {
    WM = workM;
  }

  var WP;
  if (typeof workP !== 'undefined') {
    WP = workP;
  }

  if ((!WP && !PR) || (!WM && !MR)) {
    
    return 0;
  }
  let applied = 0;
  for (let pr = 0; pr < N - 1; pr++) {
    for (let pc = 0; pc < N - 1; pc++) {
      let isShipPoint = false;

      if (WP && WP[pr] && WP[pr][pc] === 'H') {
        isShipPoint = true;
      } else if (PR && PR[pr] && PR[pr][pc] === 'H') {
        isShipPoint = true;
      }

      if (!isShipPoint) continue;

      const cells = [ [pr, pc], [pr, pc + 1], [pr + 1, pc], [pr + 1, pc + 1] ];
      let water = 0, free = null, ships = 0;

      for (const [r, c] of cells) {
        var kind='-';

        if (MR && MR[r]) {
          var cellTok = MR[r][c];
          if (typeof cellTok === 'string' && cellTok) {
            var T = cellTok.charAt(0);
            if (T === 'A' || T === 'B' || T === 'G' || T === 'D' || T === 'H') {
              kind = 'ship';
            } else if (T === 'V' || (T >= '0' && T <= '4')) {
              kind = 'water';
            }
          }
        }

        if (!kind && WM && WM[r]) {
          const p = WM[r][c];
          if (p) {
            if (p.kind === 'water') {
              kind = 'water';
            } else if (p.kind === 'ship') {
              kind = 'ship';
            }
          }
        }

        if (kind === 'water') {
          water++;
        } else if (kind === 'ship') {
          ships++;
        } else {
          free = { r, c };
        }
      }

      if (water === 3 && ships === 0 && free) {
        const r = free.r;
        const c = free.c;
        const tok = (typeof parseTokenSafe === 'function') ? parseTokenSafe(r, c) : null;
        const main = tok && tok.main ? tok.main : 'H';
        const color = tok && tok.color ? tok.color : '-';
        var beforeMR = (MR && MR[r]) ? MR[r][c] : undefined;

        setCellShip(r, c, main, color);

        if (MR && MR[r]) {
          var old = MR[r][c];
            var vch = (typeof old === 'string' && old.length >= 2) ? old.charAt(1) : '-';
            var hch = (typeof old === 'string' && old.length >= 3) ? old.charAt(2) : '-';
            MR[r][c] = 'H' + vch + hch;
        }

        var afterMR = (MR && MR[r]) ? MR[r][c] : undefined;
        
        applied++;
        VALTOZAS = true;
      }
    }
  }
  
  return applied;
}
</script>
<style id="modeCSS">
  /* Haladóban az elrejtést most computeLabel intézi; a data-auto flag-et csak statisztikához használjuk.
  body.mode-halado .cell[data-auto="1"] .cellTextMain,
  body.mode-halado .cell[data-auto="1"] .cellTextSub { visibility: hidden; }
  */
  body.mode-kezdo .cell .cellTextMain,
  body.mode-kezdo .cell .cellTextSub { visibility: visible; }
#indexInput.hint{opacity:1} #indexInput::placeholder{opacity:1; color:#111}
</style>
<style>

</style>
<style>
/* === ELHELYEZÉS állapot-keret === */
#placeOverlay{
  position:fixed; border:3px solid yellow; border-radius:6px;
  box-shadow: 0 0 0 2px rgba(255,255,0,.35) inset;
  pointer-events:none; z-index:200001; display:none;
}
</style>
<style>
/* === ELHELYEZÉS állapot-keret (refresh) === */
#placeOverlay{
  position:fixed; border:3px solid yellow; border-radius:6px;
  box-shadow: 0 0 0 2px rgba(255,255,0,.35) inset;
  pointer-events:none; z-index:200001; display:none;
}
</style>

<script>
(function(){
  {
    var N = (window.N || 9);
    function mkM(n){ return Array.from({length:n}, ()=>Array(n).fill(null)); }
    if (!window.workM || !Array.isArray(window.workM) || !Array.isArray(window.workM[0]) || window.workM.length!==N){
      window.workM = mkM(N);
    }
    window.__ensureWorkM__ = function(){
      var n = (window.N || 9);
      if (!window.workM || !Array.isArray(window.workM) || !Array.isArray(window.workM[0]) || window.workM.length!==n){
        window.workM = mkM(n);
      }
    };
    document.addEventListener('click', function(e){
      var t = e.target && (e.target.closest && e.target.closest('button')) || e.target;
      if(!t) return;
      var txt = (t.textContent || '').toUpperCase();
      if (txt.includes('RESET') || txt.includes('TÁBLA TÖRLÉS') || txt.includes('TÁBLA TÖRLÉSE')){
        setTimeout(window.__ensureWorkM__, 0);
      }
    }, true);
  }
})();
</script>

<style>

.cell { position: relative; }
.f511-ring{
  position:absolute; inset:6%;
  border:3px solid #f5d10a; border-radius:8px; pointer-events:none;
  box-shadow: inset 0 0 0 2px rgba(245,209,10,.35);
  z-index: 3;
}
.f511-ring.ok{
  border-color:#34a853;
  box-shadow: inset 0 0 0 2px rgba(52,168,83,.30);
}
.f511-trace{
  font-family: "Courier New", monospace; font-weight: 700;
  background: #111; color: #0ff; padding: 2px 6px; border-radius: 6px;
}
</style>
<style>
/* auto: hide top-right HUD for now */
#hudTopRight, #HUD_topRight, .hud-top-right { display: none !important; }
</style>

<title>SMYOZ_EXPLORER_v12.16_REJTVENY-SEGMENTS-RESET_ALIASLESS_FIX1</title>

<style id="ui_teendok1018">

.topwrap{ margin-bottom:8px; }
.toolbar{ display:flex; flex-wrap:wrap; gap:16px; align-items:flex-start; }
.toolbar button.ghost{ background:var(--accent); color:#fff; }
#autoSwitches button{ text-transform:uppercase; font-weight:800; }
#autoSwitches #btnRunAllAutos{ background:#22c55e; color:#fff; }
#autoSwitches #autoTgl, #autoSwitches #autoRec{ background:var(--accent); color:#fff; }

.toolbar .group{ display:flex; flex-direction:column; gap:8px; }


#seedPastePanel textarea{ height:40px !important; min-height:40px !important; }

/* Automations: turn header into a link-like toggle; hide legacy buttons */
#autoTgl, #autoRec{ display:none !important; }
#autoSwitches .auto-link{ cursor:pointer; text-decoration:underline; }

/* Overlay for automation switches */
.auto-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.4); display:none; align-items:center; justify-content:center; z-index:9999; }
.auto-overlay .panel{ background:#fff; border-radius:10px; padding:12px 16px; max-width:90vw; max-height:80vh; overflow:auto; box-shadow:0 10px 30px rgba(0,0,0,.2); }
</style>

<style id="ui_teendok1018C_overrides">

#seedPastePanel{ display:block !important; }
#loadSeed{ display:inline-block !important; background:#22c55e !important; color:#fff !important; }

.toolbar{ display:flex; flex-wrap:wrap; gap:0px; align-items:flex-start; }
.toolbar button.ghost{ background:var(--accent); color:#fff; }
#autoSwitches button{ text-transform:uppercase; font-weight:800; }
#autoSwitches #btnRunAllAutos{ background:#22c55e; color:#fff; }
#autoSwitches #autoTgl, #autoSwitches #autoRec{ background:var(--accent); color:#fff; }

#slotLoadBtn{ display:flex; align-items:flex-start; }


.auto-overlay{ background:rgba(0,0,0,.18) !important; }
#autoRowsHost #autoRows{ display:block !important; }
#autoRowsHost label{ display:block !important; margin:6px 0 !important; font-size:1.5em; }
#autoRowsHost input[type="checkbox"]{ transform:translateY(1px); }


#homokozo_placeholder{ display:none !important; }
#homokozo_card{ display:none !important; }
</style>

<style id="teendok1018C2_css">

#slotLoadBtn{ display:inline-flex; align-items:flex-start; margin-right:2mm; }
#slotLoadBtn > #loadSeed{ font-family: inherit !important; font-weight:800 !important; font-size:14px !important; }

/* Opcionális finom tolás az Automatizmusok+Mód blokkra */
#autoSwitches{ margin-left:35mm; }
</style>

<style id="ui_teendok1018C3_css">

#elvet_placeholder_panel, #elvet_placeholder_card{
  display:inline-block;
  vertical-align:middle;
  width:88px; 
  height:28px; 
}

/* Tiny debug markers in each homokozó (pointer-events: none) */
/*.hk-marker{
  position:absolute; left:4px; top:4px; width:8px; height:8px;
  border:1px solid rgba(0,0,0,.35); border-radius:2px;
  pointer-events:none; z-index:10000; opacity:.9;
}
#homokozo_panel .hk-marker{ background:#28a745; } */ 
/* #homokozo_card  .hk-marker{ background:#007bff; } */ 
</style>



<style>
/* === AUTO switch panel (populates #autoRows) === */
#autoRows { padding: 6px 8px; font-family: inherit; font-size: 12px; }
#autoRows .auto-toolbar { margin-bottom: 6px; display:flex; gap:8px; flex-wrap:wrap; }
#autoRows .auto-toolbar button { padding:2px 6px; cursor:pointer; }
#autoRows .auto-grid { display:grid; grid-template-columns: repeat(2, minmax(160px,1fr)); gap:4px 12px; }
#autoRows .auto-item { display:flex; align-items:center; gap:6px; white-space:nowrap; }
#autoRows .auto-item input[type="checkbox"] { transform: translateY(1px); }
#autoRows .auto-item.disabled { opacity:.5; }
</style>


<style>
/* [SMY][HOMOKOZO NUMERIC LAYOUT] fix, numerikus elrendezés a panelen belül (nem mozgatunk DOM-ot) */
#homokozo_panel { position: relative; padding-top: 52px; } 
#hk_reset   { position: absolute; top: 8px;  left:  8px;  min-width: 110px; }
#hk_index   { position: absolute; top: 8px;  left: 132px; width: 160px; }
#hk_elhelyez{ position: absolute; top: 8px;  left: 308px; min-width: 130px; }
#hk_toggle  { position: absolute; top: 8px;  left: 456px; min-width: 130px; white-space: nowrap; }
</style>

<style id="hk_rows_fix_1109_css">
/* HOMOKOZÓ: rögzített 2–7. sorok - egyszerű, homokozó‑relatív pozicionálás
   Nincs új függvény, nincs spacer, nincs overlay/guard. */
#homokozo_panel{
  position: relative;
  --hk-top1: 70px;   
  --hk-step: 60px;   
  --hk-left: 8px;
  --hk-right: 8px;
  min-height: calc(var(--hk-top1) + (6 * var(--hk-step)) + 16px);
}

/* A sorok közvetlen szülője a panel első gyereke.
   A 2–7. gyermek-sorok függőlegesen rögzítve, homokozó‑relatív koordinátákkal. */
#homokozo_panel > * > *:nth-child(2),
#homokozo_panel > * > *:nth-child(3),
#homokozo_panel > * > *:nth-child(4),
#homokozo_panel > * > *:nth-child(5),
#homokozo_panel > * > *:nth-child(6),
#homokozo_panel > * > *:nth-child(7){
  position: absolute;
  left: var(--hk-left);
  right: var(--hk-right);
}


#homokozo_panel > * > *:nth-child(2){ top: calc(var(--hk-top1) + 0*var(--hk-step)); }
#homokozo_panel > * > *:nth-child(3){ top: calc(var(--hk-top1) + 1.3*var(--hk-step)); }
#homokozo_panel > * > *:nth-child(4){ top: calc(var(--hk-top1) + 2*var(--hk-step)); }
#homokozo_panel > * > *:nth-child(5){ top: calc(var(--hk-top1) + 3*var(--hk-step)); }
#homokozo_panel > * > *:nth-child(6){ top: calc(var(--hk-top1) + 4*var(--hk-step)); }
#homokozo_panel > * > *:nth-child(7){ top: calc(var(--hk-top1) + 5*var(--hk-step)); }


#homokozo_panel > * > *:nth-child(2),
#homokozo_panel > * > *:nth-child(3),
#homokozo_panel > * > *:nth-child(4),
#homokozo_panel > * > *:nth-child(5),
#homokozo_panel > * > *:nth-child(6),
#homokozo_panel > * > *:nth-child(7){
  pointer-events: auto; 
  z-index: 1;
}
</style>

<style id="ui_teendok1204_buttons">
/* 1204: felső sáv gomb-stílus egységesítés + zöld automatizmus legördülő */
.toolbar button{
  font-family: inherit;
  font-weight: 800;
  text-transform: uppercase;
}

/* MINDEN AUTOMATIZMUS FUT marad kék (accent) */
#autoSwitches #btnRunAllAutos{
  background: var(--accent);
  color: #fff;
}

/* 'Automatizmusok' fejléc mint zöld legördülő-gomb az overlay-hez */
#autoSwitches .auto-link{
  cursor: pointer;
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 6px 10px;
  border-radius: 8px;
  background: #22c55e; 
  color: #fff;
}
</style>
</head>
<body>
<div id="autoOverlay" class="auto-overlay" aria-hidden="true">
  <div class="panel">
    <div style="font-weight:800; margin-bottom:8px;">AUTOMATIZMUSOK</div>
    <div id="autoRowsHost"></div>
    <div id="autoProfileControls" style="display:flex; flex-wrap:wrap; align-items:center; justify-content:space-between; gap:8px; margin-top:10px;">
      <div style="display:flex; flex-wrap:wrap; align-items:center; gap:6px;">
        <span style="font-weight:600;">Profil:</span>
        <label style="display:inline-flex; align-items:center; gap:4px; cursor:pointer;">
          <input type="radio" name="autoProfileMode" id="autoProfile_K" value="K" checked="checked" />
          <span>K (Kezdő)</span>
        </label>
        <label style="display:inline-flex; align-items:center; gap:4px; cursor:pointer;">
          <input type="radio" name="autoProfileMode" id="autoProfile_H" value="H" />
          <span>H (Haladó)</span>
        </label>
        <label style="display:inline-flex; align-items:center; gap:4px; cursor:pointer;">
          <input type="radio" name="autoProfileMode" id="autoProfile_M" value="M" />
          <span>M (Mester)</span>
        </label>
      </div>
      <div style="display:flex; flex-wrap:wrap; align-items:center; gap:6px;">
        <button class="ghost" id="autoProfileExportBtn" type="button">Profil kiírása</button>
        <button class="ghost" id="autoProfileImportBtn" type="button">Profil beolvasása</button>
        <input type="file" id="autoProfileImportInput" accept=".txt,text/plain" style="display:none;" />
      </div>
    </div>
    <div style="text-align:right; margin-top:10px;">
      <button class="ghost" id="autoClose" type="button">Bezár</button>
    </div>
  </div>
</div>

<div id="placeOverlay" aria-hidden="true"></div>
<header id="appHeader"><span id="hdrTitle">SMYOZ Explorer v12.16</span>
  <label id="dokuToggleWrap" class="dokuToggle" title="DOKU fejléc elrendezés">
    <input id="dokuToggle" type="checkbox"/>
    DOKU
  </label>
</header>
<div id="topBlocks">
<div class="topwrap">
<div class="infoRow">
<div class="ibox"><div class="cap">Vízvonalak (össz / aktuális)</div><div class="val" id="vvBox">-</div></div>
<div class="ibox"><div class="cap">Szigetek (méretek növekvő sorrendben)</div><div class="val" id="szigBox">-</div></div>
<div class="ibox"><div class="cap">Szigetek (LELTÁR)</div><div class="val" id="szigOrigBox">-</div></div>
<div class="ibox"><div class="cap">Kikötések (össz / aktuális)</div><div class="val" id="khBox">-</div></div>
</div>
<div class="sumRow" id="sumRow">Lövések: <span class="hud-dyn">0</span> | ELHELYEZések: <span class="hud-dyn">0</span> | Megfejtett: <span class="hud-dyn">0</span>/77</div>
</div>
<div class="toolbar">
<div class="group">
<div style="font-weight:800">LELTÁR betöltése</div>
<div style="display:flex; gap:8px; align-items:center"><label style="font-weight:600">SEED.txt:</label><input accept=".txt,text/plain" id="seedFileInput" type="file"/></div>
<div style="font-size:12px; color:#666">Vagy: illeszd be kézzel alább</div>
<div id="seedPastePanel"><textarea class="mono" id="seedText" placeholder="Ide másold a SEED.txt tartalmát..." style="width:140px; min-width:140px; max-width:140px; height:70px;">SEED: 1
nVV: 1
lSZ: 2 - 2 - 4 - 8
nKH: 6

lOPZ:
AL: p01
BE: p00 p11
GA: m01 m01 m11
DE:  00  00  01  11

MATRIX:
0x 0x Dx 1p 1p Bx 0z 0x 0x
Dz 1p 2pp 3p 2p Bp 0pz Gx Gz
0x 1x 2p 3x 2x Bz 1z 2p 1x
0x Gz Gz 2x 3x 2p 2z 2p 1x
1x 2p 2x 2x 2x 2p 1z Az 0x
1x 2p 3x 2x Gz Gp 0pz Ax 0x
0x Bx 1p 1p 1p 2pp 1pz Ax 0x
0x Bx 0p Dpz 1p 2pp 1pz Ax 0x
0x Bx 0p 0p 0p Dx 0z 0x 0x

PONTOK:
H H H V H H H H X
H V V V H H H H X
H H H V H H V V X
H H H V V V H H X
V V V H H H H H X
H H V H H H H H X
H H H H V V H H X
H H H H H H H H X
X X X X X X X X X

VONALAK:
SOROK:   P P Z Z Z P P P P
OSZLOPOK: Z P P Z Z P V P Z

REJTVÉNY:
31 36 42 54


</textarea></div>

</div>
<div class="group">
<div style="display:flex; justify-content:center; margin-bottom:0px;">
  <button class="ghost" id="loadSeed">BETÖLTÉS</button>
</div>
<div style="margin-top:10mm; display:flex; gap:8px; flex-wrap:wrap; align-items:flex-end; justify-content:center">
<input class="mono" id="indexInput" placeholder="??" style="width:60px; font-size:18px; font-weight:700; text-align:center" type="text"/>
<button id="shootBtn">LÖVÉS</button>
<span class="mono" style="display:none">Lövések: <span id="shots">0</span></span>
</div>
<div style="font-size:12px; color:#3b556b">Enter is indítja a lövést.</div>
</div>
<div class="group" id="autoSwitches" style="border-top:1px dashed #cfe1ff; padding-top:8px;">
<div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
<div style="font-weight:800">AUTOMATIZMUSOK</div>


</div>
<div style="margin-top:6px;">
  <button class="ghost" id="btnRunAllAutos" style="padding:8px 8px; font-weight:800;">MINDEN AUTOMATIZMUS FUT</button>
</div>
<div id="viewModeRow" style="margin-top:6px; display:flex; align-items:center; gap:12px;"> <div style="font-weight:700">Mód:</div> <label><input id="mode_kezdo" name="viewMode" type="radio" value="kezdo"/> Edzés</label> <label><input id="mode_halado" name="viewMode" type="radio" value="halado"/> Játék</label> </div>


<div id="autoRows"></div>
</div>
</div>
</div><!-- /topBlocks -->
<div class="main">
<div class="card" style="width:160px;min-width:130px;max-width:170px;margin-left:80mm">
<h2>HAJÓK</h2>
<div class="shipCol" id="shipCol">-</div>
<div style="display:none"><h2 style="margin-top:10px">LELTÁR</h2>
<div class="mono">SEED: <span id="seedDisp">-</span></div>
<div class="mono">nVV (összes): <span id="vvDisp">-</span></div>
<div class="mono">lSZ: <span id="szDisp">-</span></div>
<div class="mono">nKH (összes): <span id="khDisp">-</span></div>
</div></div>
<div class="card" id="homokozo_card" style="flex:0 0 auto; width: calc(220px + 35mm);min-width: calc(200px + 35mm);max-width: calc(260px + 35mm); display:flex; align-items:center; justify-content:center; margin-left: -15mm;">
<div id="homokozo_placeholder" style="display:flex; align-items:center; justify-content:center; width:100%;">
<div style="width:40px;height:40px;background:#fff;position:relative;border:0;margin-bottom:5px;display:flex;align-items:center;justify-content:center">
<div style="position:absolute;width:60%;height:4px;background:white"></div>
<div style="position:absolute;height:60%;width:4px;background:white"></div>
</div>
<div style="background:#ffffff; border:0; color:#ffffff; border-radius:12px; padding:24px; width:100%; display:flex; align-items:center; justify-content:center;; flex-direction:column; gap:8px">
<div style="width:16mm;height:16mm;background:#ffffff;border:1px solid #aa0000;"></div>
<span style="font-size:32px; font-weight:800; color:#ffffff;"></span>
</div>
</div>
</div>
<div class="card"; style="margin-left:110mm">
<div class="boardWrap">
<div class="frame">
<div id="grid"></div>
<svg id="indexLayer">
<g id="gIndexes"></g>
<g id="gSegments"></g>
<g id="gPoints"></g>
</svg>
</div>

</div>
</div>
<div class="group" id="rightTools">
  <button class="btn-sm" id="btnRedrawReal" title="REAL → View frissítés" style="padding:8px 16px; font-size:14px; font-weight:800; min-width:140px;">ÚJ RAJZ</button>
</div>
</div>
</div>
<script id="ui_rightTools_homokozo_layout_fix">
(function(){
  function ready(fn){
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', fn);
    } else {
      fn();
    }
  }

  ready(function(){
    try{
      var grid  = document.getElementById('grid');
      var hk    = document.getElementById('homokozo_panel');
      var tools = document.getElementById('rightTools');
      if (!grid || !hk || !tools) return;

      
      var host = tools.parentElement;
      if (!host) {
        host = document.querySelector('.main') || document.body;
      }

      var cs = window.getComputedStyle(host);
      if (cs.position === 'static') {
        host.style.position = 'relative';
      }

      // Homokozó áthozása ugyanabba a hostba (a tábla mellé)
      if (hk.parentElement !== host) {
        host.appendChild(hk);
      }

      
      tools.style.display = 'flex';
      tools.style.flexDirection = 'row';
      tools.style.alignItems = 'flex-start';
      tools.style.gap = '6px';

      var btns = tools.getElementsByTagName('button');
      for (var i = 0; i < btns.length; i++) {
        var b = btns[i];
        b.style.minWidth = '0';
        b.style.width = '160px'; 
      }

      var gRect = grid.getBoundingClientRect();
      var hRect = host.getBoundingClientRect();
      var offsetX = 36;  
      var offsetY = 8;   // px - távolság a gombok és a homokozó között
      var upPx    = 150;  

      
      tools.style.position = 'absolute';
      var topTools = gRect.top - hRect.top - upPx;
      if (topTools < 0) topTools = 0;
      tools.style.top  = topTools + 'px';
      tools.style.left = (gRect.right - hRect.left + offsetX) + 'px';

      // Homokozó panel áthelyezése a gombok alá, a tábla jobb oldalára
      hk.style.position = 'absolute';
      var tRect = tools.getBoundingClientRect();
      var topHK = tRect.bottom - hRect.top + offsetY;
      hk.style.top  = topHK + 'px';
      hk.style.left = (gRect.right - hRect.left + offsetX) + 'px';

      // ÚJ RAJZ gomb közel vízszintes középre igazítása a HOMOKOZÓ fölé
      {
        var hkRect2 = hk.getBoundingClientRect();
        var toolsRect2 = tools.getBoundingClientRect();
        var hkCenterX = (hkRect2.left + hkRect2.right) / 2;
        var toolsCenterX = (toolsRect2.left + toolsRect2.right) / 2;
        var deltaX = hkCenterX - toolsCenterX;
        if (!isNaN(deltaX) && isFinite(deltaX)) {
          var baseLeft = parseFloat(tools.style.left) || 0;
          tools.style.left = (baseLeft + deltaX) + 'px';
        }
      }

    } catch (e) {
      // csendes hiba – UI finomhangolás, nem kritikus
    }
  });
})();
</script>


<script>

function colorCodeHTML(code){
  const s=String(code||'').toLowerCase(); if(!s) return '';
  if(s==='p'||s==='z'||s==='x') return `<span class="${s}">${s}</span>`;
  if(s==='pp') return `<span class="p">p</span><span class="p">p</span>`;
  if(s==='zz') return `<span class="z">z</span><span class="z">z</span>`;
  if(s==='pz') return `<span class="p">p</span><span class="z">z</span>`;
  if(s==='zp') return `<span class="z">z</span><span class="p">p</span>`;
  return s.split('').map(ch => (ch==='p'||ch==='z'||ch==='x') ? `<span class="${ch}">${ch}</span>` : ch).join('');
}
function normalizeColor(cc){
  const s = String(cc || '').toLowerCase();
  if (!s) return '';

  
  if (s === 'pp' || s === 'zz' || s === 'pz' || s === 'zp'){     return s;  }

  const hasP = s.indexOf('p') !== -1;
  const hasZ = s.indexOf('z') !== -1;
  const hasX = s.indexOf('x') !== -1;

  
  if (hasP && !hasZ){    return 'p';   }

  
  if (hasZ && !hasP){    return 'z';   }

  // Ha van benne 'x' (és nincs erősebb p/z szabály) → x   (xx, ?x, x?, x)
  if (hasX){    return 'x';   }

  
  if (/^[\-\?]+$/.test(s)){    return '-';  }

  
  return '-';
}


// Shore color-pair normalization (2 chars): on edges the red ('p') may only be parallel to the shore.
// - Top/bottom edge: red must be horizontal (2nd char of the color-pair).
// - Left/right edge: red must be vertical (1st char of the color-pair).
// Corners are left unchanged.
function shoreNorm2(r,c,color2){
  // color2 is expected to be a 2-char pair: [vertical][horizontal]
  var s = String(color2 || '');
  if (s.length !== 2) return s;

  var v = s.charAt(0);
  var h = s.charAt(1);

  var vv = v.toLowerCase();
  var hh = h.toLowerCase();
  var pCount = (vv === 'p') + (hh === 'p');
  if (pCount !== 1) return s;

  var N = 9;
  var onTop = (r === 0);
  var onBottom = (r === (N - 1));
  var onLeft = (c === 0);
  var onRight = (c === (N - 1));
  if (!(onTop || onBottom || onLeft || onRight)) return s;

  // Corner: leave unchanged
  if ((onTop || onBottom) && (onLeft || onRight)) return s;

  // Top/bottom shore => red must be horizontal (h)
  if (onTop || onBottom){
    if (vv === 'p') return (h + v);
    return s;
  }

  // Left/right shore => red must be vertical (v)
  if (hh === 'p') return (h + v);
  return s;
}




/* ====== Konstansok és állapot ====== */
const N=9;
let MATRIX=Array.from({length:N},()=>Array(N).fill('---'));
let POINTS=Array.from({length:N},()=>Array(N).fill('-'));
let LELTAR={}; // {seed,nVV,lSZ[],nKH,lOPZ{AL,BE,GA,DE}}
let shots=0;
let elhelyezesek=0;

let KIKOTOTTHAJOKSZAMA=0;
let VIZVONALAKSZAMA=0;
let FOLYTATAS = false; 
let vanMENTES = false;
let redrawLabelCycle = 0;
let EdJaMode = "kezdo";

// View-mode helper: used by applyMode() for Kezdő/Haladó redraw decisions.
function getViewModeForRedraw(){
  const elHal = document.getElementById("mode_halado");
  return (elHal && elHal.checked) ? "halado" : "kezdo";
}


let VALTOZAS = false; 

let workM = Array.from({length:N},()=>Array(N).fill(null));
window.workM = workM;     
let workP = Array.from({length:N},()=>Array(N).fill('-'));
     

/* ====== Automatizmusok ====== */
const CFG = { auto: {
  cornersWater:true,
  auto7:true, auto8:true,
  fromWater345:true, extendFromPairs:true, recomputeWaterPoints2a:true, bridgeOneGapPairs:false, auto6:true, auto6b:true,
  auto14:false, auto16:false, auto14a:false, auto2:false, auto23a:false
}};

window.SMY_TRY_BLOCKS = 379;
window.SMY_CATCH_BLOCKS = 377;
window.SMY_CATCH_COUNT = 0;


const CFG_ALFA = { showIndicator:true };


const gridEl = document.getElementById('grid');
const svgIndex = document.getElementById('indexLayer');
const gIndexes = document.getElementById('gIndexes');
const gSegments = document.getElementById('gSegments');
const gPoints = document.getElementById('gPoints');

const seedText = document.getElementById('seedText');
const loadBtn = document.getElementById('loadSeed');
const shipCol = document.getElementById('shipCol');

const seedDisp = document.getElementById('seedDisp');
const vvDisp   = document.getElementById('vvDisp');
const szDisp   = document.getElementById('szDisp');
const khDisp   = document.getElementById('khDisp');

/* ===== Incoming SEED support (honlap / rejtv) ===== */
const SMYOZ_SEED_LS_KEY = 'SMYOZ_EXPLORER_INCOMING_SEED_TEXT';

function applyIncomingSeedText(t, autoLoad){
  if (!seedText) return;
  if (typeof t !== 'string') return;
  const s = t.replace(/\r\n/g, '\n');
  if (s.trim() === '') return;

  seedText.value = s;

  const panel = document.getElementById('seedPastePanel');
  if (panel) panel.style.display = 'block';

  const btn = document.getElementById('loadSeed');
  if (btn) btn.style.display = 'inline-block';

  if (autoLoad && loadBtn) loadBtn.click();
}

(function initIncomingSeed(){
  // 1) One-shot localStorage handoff (works offline)
  try{
    const ls = localStorage.getItem(SMYOZ_SEED_LS_KEY);
    if (ls && ls.trim() !== ''){
      applyIncomingSeedText(ls, false);
      localStorage.removeItem(SMYOZ_SEED_LS_KEY);
    }
  }catch(e){}

  // 2) postMessage handoff (parent/iframe)
  window.addEventListener('message', (ev)=>{
    const d = ev ? ev.data : null;
    if (!d) return;

    if (typeof d === 'string'){
      if (d.indexOf('SMYOZ_SEED_TEXT:') === 0){
        applyIncomingSeedText(d.slice('SMYOZ_SEED_TEXT:'.length), false);
      }
      return;
    }

    if (typeof d === 'object'){
      if (d.type === 'SMYOZ_SEED_TEXT' && typeof d.text === 'string'){
        applyIncomingSeedText(d.text, !!d.autoLoad);
      }
    }
  });

  // 3) URL param ?seed=relative/or/http/url (best for hosted mode)
  try{
    const u = new URL(window.location.href);
    const seedUrl = u.searchParams.get('seed');
    if (seedUrl){
      fetch(seedUrl)
        .then(r => r.ok ? r.text() : Promise.reject(new Error('HTTP ' + r.status)))
        .then(t => applyIncomingSeedText(t, false))
        .catch(()=>{});
    }
  }catch(e){}
})();

const vvBox = document.getElementById('vvBox');
const szigBox = document.getElementById('szigBox');
const khBox = document.getElementById('khBox');
const sumRow = document.getElementById('sumRow');

const shotsEl = document.getElementById('shots');
const idxInput = document.getElementById('indexInput');
const shootBtn = document.getElementById('shootBtn');


function isCommentOrBlank(line){ const L=line.trim(); if(!L) return true; return L.startsWith('(')||L.startsWith('#')||L.startsWith(';')||L.startsWith('//'); }
function normalizeKey(s){ return s.normalize('NFD').replace(/[\u0300-\u036f]/g,''); }
/*  function redrawFromRealAll(){
        {
            if (typeof window.__redrawSimpleStrict === 'function'){
                window.__redrawSimpleStrict();
                return;
            }
        }
        {
            const S = window.SMY;
            if (!S || !S.M_REAL) return;

            // táblaépítés (ha kell)
            if (typeof buildEmptyBoard === 'function'){
                buildEmptyBoard();
            }

            // Új, egységes REDRAW: használjuk a computeLabel + normalizeColor + Kezdő/Haladó logikát
            if (typeof redrawSimpleStrict === 'function'){
                redrawSimpleStrict();
            } else if (typeof window.__redrawSimpleStrict === 'function'){
                window.__redrawSimpleStrict();
            } else {
                // Végszükség: közvetlen REAL → VIEW (régi logika, minimalizálva)
                const N = S.N || 9;
                for (let r = 0; r < N; r++){
                    for (let c = 0; c < N; c++){
                        const rc = ensure3(S.M_REAL[r][c]);
                        const T  = rc.charAt(0);     // típus
                        const CC = rc.slice(1, 3);   // színpár

                        if (T === '-'){
                            if (typeof setCellReset === 'function'){
                                setCellReset(r, c, '-', CC);
                            }
                        }
                        else if ((T >= '0' && T <= '4') || T === 'V'){
                            if (typeof setCellWater === 'function'){
                                setCellWater(r, c, T, CC);
                            }
                        }
                        else if (T === 'A' || T === 'B' || T === 'G' || T === 'D' || T === 'H'){
                            if (typeof setCellShip === 'function'){
                                setCellShip(r, c, T, CC);
                            }
                        }
                        else{
                            if (typeof setCellReset === 'function'){
                                setCellReset(r, c, '-', CC);
                            }
                        }

                        // vonalszegmensek
                        try {
                            if (typeof window.drawSegmentsFromRealCell === 'function'){
                                window.drawSegmentsFromRealCell(r, c);
                            }
                        } catch(_){}
                    }
                }

                // pont-overlay
                try {
                    if (typeof drawPointsOverlay === 'function'){
                        drawPointsOverlay();
                    }
                } catch(_){}
            }

            console.log('[AUTO_REDRAW] REAL → VIEW frissítve.');
        }
    }
   RA   PÓTLÁS  A  6018-6137  KIVETT RÉSZ HELYETT */

function buildEmptyBoard()
{
  gridEl.innerHTML='';
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const cell=document.createElement('div');
      cell.className='cell';
      cell.dataset.r=r; cell.dataset.c=c;
      const main=document.createElement('div'); main.className='cellTextMain'; main.textContent='';
      const sub=document.createElement('div');  sub.className='cellTextSub';  sub.textContent='';
      cell.appendChild(main); cell.appendChild(sub); gridEl.appendChild(cell);
    }
  }
  
    setCellWater(0,0); setCellWater(0,N-1); setCellWater(N-1,0); setCellWater(N-1,N-1);
  
  requestAnimationFrame(()=>{ drawIndexes(); drawPointsOverlay(); });

  window.workM = workM; 
  
     function ensureSegLayer1(r,c){
      var cellEl=document.querySelector('.cell[data-r="'+r+'"][data-c="'+c+'"]'); if(!cellEl) return null;
      var v=cellEl.querySelector('.rc-segV'); if(!v){ v=document.createElement('div'); v.className='rc-segV'; cellEl.appendChild(v); }
      var h=cellEl.querySelector('.rc-segH'); if(!h){ h=document.createElement('div'); h.className='rc-segH'; cellEl.appendChild(h); }
      var cs=getComputedStyle(cellEl);
      var bTop=parseFloat(cs.borderTopWidth)||0, bRight=parseFloat(cs.borderRightWidth)||0, bBottom=parseFloat(cs.borderBottomWidth)||0, bLeft=parseFloat(cs.borderLeftWidth)||0;
      var extra=0;  
      v.style.top=(-Math.max(bTop,bBottom)-extra)+'px'; v.style.bottom=(-Math.max(bTop,bBottom)-extra)+'px';
      h.style.left=(-Math.max(bLeft,bRight)-extra)+'px'; h.style.right=(-Math.max(bLeft,bRight)-extra)+'px';
      return {v:v,h:h};
    }
  
  
 
      function drawSegmentsFromRealCell_MUHELY(r,c)
	  {
        //rcEnsureRealCellOnly();
        var wm=SMY.M_REAL[r][c];   
        // var rc=(cellObj&&typeof cellObj.realCell==='string'&&cellObj.realCell.length===3)?cellObj.realCell:'---';
        var layers=ensureSegLayer1(r,c); if(!layers) return;
        var colV=wm[1]; var colH=wm[2];
        
		
        var tV=5; 
		var tH=5;
		if(colV){ layers.v.style.color=colV; layers.v.style.width=tV+'px'; layers.v.style.display='block'; } 
		else { layers.v.style.display='none'; }
        if(colH){ layers.h.style.color=colH; layers.h.style.height=tH+'px'; layers.h.style.display='block'; } 
		else { layers.h.style.display='none'; }
     };

  function MUHELYtabCHILD(r,c,)    
  {
	 var D = SMY.M_REAL[r][c];  
	 var main = (D[0]||'-').toUpperCase();
	 var color = D[1]+D[2];
    if (main==='V' || main==='0' || main==='1' || main==='2' || main==='3' || main==='4')
	{
       setCellWater(r,c, main, color);
    } 
	else 
	if (main==='H' || main==='A' || main==='B' || main==='G' || main==='D' || main==='D')
	{
       setCellShip(r,c, main, color);   
    }
	else if (main==='-') setCellReset(r,c,'-',color);
 
    
    var __AUT13_ret = 0;
    __AUT13_ret = enforceAuto13WaterVectors();
    
  }	
}

function setCellWater(r,c,numTxt,subTxt)
{
  const el = gridEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
  if(!el) return;
  el.classList.remove('ship'); el.classList.add('water');
  const main = el.querySelector('.cellTextMain');
  const sub  = el.querySelector('.cellTextSub');
  main.style.fontSize = '';
  // Alapszín (nem meglőtt): fekete a világoskék vízmezőn
  main.style.color='#000'; sub.style.color='#385a78';
  main.style.fontWeight = '800';
  main.style.textShadow = '';
  // Meglőtt (ISHOT_REAL): kékített (jól elkülönül a feketétől) a világoskék vízmezőn
  if (window.SMY && window.SMY.ISHOT_REAL && window.SMY.ISHOT_REAL[r] && window.SMY.ISHOT_REAL[r][c]) {
    var __fs = window.getComputedStyle(main).fontSize;
    var __n = parseFloat(__fs);
    if (__n > 0) main.style.fontSize = String(Math.round(__n * 1.2)) + 'px';
    main.style.color = '#0047ff';
    main.style.fontWeight = 'bold';
    main.style.textShadow = '0.7px 0 currentColor, -0.7px 0 currentColor, 0 0.7px currentColor, 0 -0.7px currentColor, 0.7px 0.7px currentColor, -0.7px -0.7px currentColor, 0.7px -0.7px currentColor, -0.7px 0.7px currentColor';
  }

  main.textContent = numTxt ?? '';
  let rawColor = String(subTxt||'').toLowerCase();
  if (rawColor === 'xx') rawColor = 'x';
  const normColor = normalizeColor(rawColor);
    const normColor2 = normColor;
sub.innerHTML = colorCodeHTML(normColor2);
  if (workM && !window._PAINT_ONLY){
    var prev = (workM[r] && workM[r][c]) ? workM[r][c] : null;
    var baseMain = (typeof numTxt === 'string') ? numTxt : '';
    if (!baseMain){
      // 1) Ha a REAL-mátrixban már van típus (pl. 'V' vagy '0'..'4'), azt tekintsük elsődlegesnek.
      var realTok = (SMY && SMY.M_REAL && SMY.M_REAL[r]) ? SMY.M_REAL[r][c] : null;
      var realT   = realTok ? String(realTok).charAt(0) : '';
      if (realT && (realT === 'V' || (realT >= '0' && realT <= '4'))){
        baseMain = realT;
      }
      // 2) Ha nincs REAL-információ, de a workM-ben már volt víz, akkor azt őrizzük meg.
      else if (prev && prev.kind === 'water' && typeof prev.main === 'string' && prev.main){
        baseMain = prev.main; 
      }
      
      else {
        baseMain = 'V';
      }
    }
    workM[r][c] = {kind:'water', main:baseMain, color:normColor2 || '-'};
  }

  try
  {
    var __idx = document.getElementById('indexInput');
    if(__idx)
	{
      // placeholder set via UI capture
      __idx.value = '';
      __idx.classList.add('hint');
    }
  }catch(e)
  {
    window.workM = workM; 
  }

  recomputeGlobals();

  SMY.changed = true;

  VALTOZAS = true;
}



function setCellShip(r,c,code,subTxt){
  const el = gridEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
  if(!el) return;

  el.classList.remove('water'); el.classList.add('ship');
  const main = el.querySelector('.cellTextMain');
  const sub  = el.querySelector('.cellTextSub');
  main.style.fontSize = '';
  // Alapszín (nem meglőtt): fehér a sötétkék hajómezőn
  main.style.color='#fff'; sub.style.color='#e9f3ff';
  main.style.fontWeight = '800';
  main.style.textShadow = '';
  // Meglőtt (ISHOT_REAL): még élénkebb sárga a sötétkék hajómezőn
  if (window.SMY && window.SMY.ISHOT_REAL && window.SMY.ISHOT_REAL[r] && window.SMY.ISHOT_REAL[r][c]) {
    var __fs = window.getComputedStyle(main).fontSize;
    var __n = parseFloat(__fs);
    if (__n > 0) main.style.fontSize = String(Math.round(__n * 1.2)) + 'px';
    main.style.color = '#ffff00';
    main.style.fontWeight = 'bold';
    main.style.textShadow = '0.7px 0 currentColor, -0.7px 0 currentColor, 0 0.7px currentColor, 0 -0.7px currentColor, 0.7px 0.7px currentColor, -0.7px -0.7px currentColor, 0.7px -0.7px currentColor, -0.7px 0.7px currentColor';
  }

  main.textContent = code;     
  let rawColor = String(subTxt||'').toLowerCase();
  if (rawColor === 'xx') rawColor = 'x';
  const normColor = normalizeColor(rawColor);
    const normColor2 = normColor;
sub.innerHTML = colorCodeHTML(normColor2); 
  if(workM && !window._PAINT_ONLY) workM[r][c] = {kind:'ship', main:code, color:normColor2 || '-'};

  recomputeGlobals();

  
  { 
     window.workM = workM;  
  
}

  SMY.changed = true;

  VALTOZAS = true;
}



function setCellReset(r,c,code,subTxt){
  const el = gridEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
  if(!el) return;

  el.classList.remove('water'); el.classList.remove('ship');
  const main = el.querySelector('.cellTextMain');
  const sub  = el.querySelector('.cellTextSub');
  main.style.fontSize = '';
  // Alapszín (nem meglőtt): fekete (semleges háttéren)
  main.style.color='#000'; sub.style.color='#385a78';
  main.style.fontWeight = '800';
  main.style.textShadow = '';
  // Meglőtt (ISHOT_REAL): kékített (jól elkülönül a feketétől)
  if (window.SMY && window.SMY.ISHOT_REAL && window.SMY.ISHOT_REAL[r] && window.SMY.ISHOT_REAL[r][c]) {
    var __fs = window.getComputedStyle(main).fontSize;
    var __n = parseFloat(__fs);
    if (__n > 0) main.style.fontSize = String(Math.round(__n * 1.2)) + 'px';
    main.style.color = '#0047ff';
    main.style.fontWeight = 'bold';
    main.style.textShadow = '0.7px 0 currentColor, -0.7px 0 currentColor, 0 0.7px currentColor, 0 -0.7px currentColor, 0.7px 0.7px currentColor, -0.7px -0.7px currentColor, 0.7px -0.7px currentColor, -0.7px 0.7px currentColor';
  }


  main.textContent = code;     
  let rawColor = String(subTxt||'').toLowerCase();
  if (rawColor === 'xx') rawColor = 'x';
  const normColor = normalizeColor(rawColor);
    const normColor2 = normColor;
sub.innerHTML = colorCodeHTML(normColor2); 
  if(workM && !window._PAINT_ONLY) workM[r][c] = {kind:'-', main:'-', color:normColor2 || '-'};

  recomputeGlobals();

  
  { 
     window.workM = workM;  
  }   
  
}

/* ====== Stat / auto-fill számláló ====== */
let autoFills = 0;
function incAutoFills(n){ autoFills += (n||1); }
function countSolvedCells(){
  // Megfejtett = pillanatnyi nem üres mezők száma M_REAL alapján (−4 sarok)
  let cnt = 0;
  const M = (typeof SMY !== 'undefined' && SMY && SMY.M_REAL) ? SMY.M_REAL : (typeof MATRIX !== 'undefined' ? MATRIX : null);
  if (!M) return 0;
  for (let r = 0; r < N; r++) for (let c = 0; c < N; c++){
    if ((r===0 || r===N-1) && (c===0 || c===N-1)) continue; // 4 sarok
    const v = M[r][c];
    if (v && v !== '---') cnt++;
  }
  return cnt;
}

// ====== AUTO-FLAG WRAPPEREK (WATER/SHIP) + DEBUG ======

window.__DBG_LABELS__ = window.__DBG_LABELS__ || false;

const __orig_setCellWater = setCellWater;
setCellWater = function(r,c,numTxt,subTxt){
  const el = gridEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
  const beforeMain = el?.querySelector('.cellTextMain')?.textContent || '';

  __orig_setCellWater(r,c,numTxt,subTxt);

  const afterMain = el?.querySelector('.cellTextMain')?.textContent || '';

  if (window.__DBG_LABELS__) {
    {
      
    }
  }

  // REDRAW / tiszta újrarajzolás esetén semmit nem jelölünk auto-ként,
  
  if (window._PAINT_ONLY) {
    return;
  }

  if(!window.__MANUAL_WRITE__ && !beforeMain && afterMain){
    if(el) el.setAttribute('data-auto','1');
    incAutoFills(1);
  } else if(window.__MANUAL_WRITE__ && el){
    el.removeAttribute('data-auto');
  }
  recomputeWaterPoints_2a_TL();
};

const __orig_setCellShip = setCellShip;
setCellShip = function(r,c,code,subTxt)
{
  var __oldCommit = __SHIP_COMMIT__; __SHIP_COMMIT__ = true;

  const el = gridEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
  const beforeMain = el?.querySelector('.cellTextMain')?.textContent || '';

  __orig_setCellShip(r,c,code,subTxt);

  const afterMain = el?.querySelector('.cellTextMain')?.textContent || '';

  if (window.__DBG_LABELS__) {
    {
      
    }
  }

  // REDRAW / tiszta újrarajzolás: ne jelöljünk auto-ként,
  
  if (window._PAINT_ONLY) {
    __SHIP_COMMIT__ = __oldCommit;
    return;
  }

  if(!window.__MANUAL_WRITE__ && !beforeMain && afterMain){
    if(el) el.setAttribute('data-auto','1');
    incAutoFills(1);
  } else if(window.__MANUAL_WRITE__ && el){
    el.removeAttribute('data-auto');
  }
  recomputeWaterPoints_2a_TL();

  markShipPoints(r,c);

  __SHIP_COMMIT__ = __oldCommit;

  {
    var __idx = document.getElementById('indexInput');
    if(__idx){
      // placeholder set via UI capture
      __idx.value = '';
      __idx.classList.add('hint');
    }
  }

  recomputeGlobals();
};


function drawIndexes(){
  const rect = gridEl.getBoundingClientRect(); const w = rect.width, h = rect.height; const cw = w/N, ch = h/N;
  gIndexes.innerHTML='';
  svgIndex.setAttribute('viewBox', `-28 -28 ${w+56} ${h+74}`);
  function t(x,y,txt,anchor='middle'){
    const e=document.createElementNS('http://www.w3.org/2000/svg','text');
    e.setAttribute('x', x); e.setAttribute('y', y); e.setAttribute('class', 'indexText'); e.setAttribute('text-anchor', anchor); e.textContent = txt; gIndexes.appendChild(e);
  }
  for(let c=0;c<N;c++){ const x = c*cw + cw/2; t(x, -10, String((c+1)*10)); t(x, h+34, String((c+1)*10)); }
  for(let r=0;r<N;r++){ const y = r*ch + ch/2 + 4; t(-14, y, String(r+1), 'end'); t(w+14, y, String(r+1), 'start'); }
}



function parseToken(tok){
  const s=(tok||'').trim();
  if(!s) return {kind:'free', main:'', color:''};
  const mainMatch=s.match(/[ABGDHV0-4]/i);
  const main=mainMatch?mainMatch[0].toUpperCase():'';
  if(!main) return {kind:'free', main:'', color:''};
  const pz=(s.match(/[pz]/gi)||[]).map(x=>x.toLowerCase());
  const pCount=pz.filter(x=>x==='p').length;
  const zCount=pz.filter(x=>x==='z').length;
  let color='';
  if(pCount===2) color='pp';
  else if(zCount===2) color='zz';
  else if(pCount===1 && zCount===1) color='pz';
  else if(pCount===1) color='p';
  else if(zCount===1) color='z';
  if(!color && /x/i.test(s)) color='-'; 
  if(!color && ('ABGDH'.includes(main) || '01234V'.includes(main))) color='-'; // implicit x (legacy seed)
  if('ABGD'.includes(main)) return {kind:'ship', main, color};
  if('01234V'.includes(main)) return {kind:'water', main, color};
  return {kind:'free', main:'', color:''};
}

/* ====== SEED.txt parser ====== */
function parseSeedText(raw)
{
  const out = { leltar:{ seed:'-', nVV:0, lSZ:[], nKH:0, lOPZ:{AL:[],BE:[],GA:[],DE:[]} }, matrix:null, points:null, rejtveny:null };  
  const lines = raw.split(/\r?\n/); let sec = null; const mtx = []; const pts = [];  const rej = [];  
  for(let i=0;i<lines.length;i++)
  {
    let orig = lines[i]; if(isCommentOrBlank(orig)) continue; let L = orig.trim();
    if(/seed/i.test(L)){ const m = L.match(/seed[^0-9]*([0-9]{1,6})/i); if(m){ out.leltar.seed = m[1]; continue; } }
    if(/^nvv\s*:/i.test(L)){ out.leltar.nVV = parseInt((L.split(':')[1]||'0').trim(),10)||0; continue; }
    if(/^lsz\s*:/i.test(L)){ const rest = (L.split(':')[1]||'').trim(); 
	      out.leltar.lSZ = rest ? rest.split(/[^0-9]+/).filter(Boolean).map(s=>parseInt(s,10)).sort((a,b)=>a-b) : []; continue; }
    if(/^nkh\s*:/i.test(L)){ out.leltar.nKH = parseInt((L.split(':')[1]||'0').trim(),10)||0; continue; }

    const NK = normalizeKey(L).toUpperCase();
    if(/^LOPZ\s*:\s*$/i.test(L) || /^HAJ[OÓ]K\s*:\s*$/i.test(L) || /^HAJOK\s*:\s*$/i.test(NK)){ sec='LOPZ'; continue; }
    if(/^MATRIX\s*:\s*$/i.test(L)){ sec='MATRIX'; continue; }
    if(/^PONTOK\s*:\s*$/i.test(L)){ sec='PONTOK'; continue; }
    if(/^REJTVENY\s*:?\s*$/i.test(L) || /^REJTVENY\s*:?\s*$/i.test(NK)){ sec='REJTVENY'; continue; }   
 

    if(sec==='LOPZ')
	{
      const m = L.match(/^(AL|BE|GA|DE)\s*:\s*(.*)$/i);
      if(m){ const key = m[1].toUpperCase(); const vals = (m[2]||'').trim().split(/\s+/).filter(Boolean); out.leltar.lOPZ[key] = vals; }
      continue;
    }
    if(sec==='MATRIX')  { const parts = L.split(/\s+/).filter(Boolean); if(parts.length===N) mtx.push(parts.map(tok=>tok.trim())); continue; }
    if(sec==='PONTOK')  { const parts = L.split(/\s+/).filter(Boolean); if(parts.length===N) pts.push(parts.map(tok=>tok.trim().toUpperCase())); continue; }
    if(sec==='REJTVENY'){ const parts = L.split(/\s+/).filter(Boolean); if(parts.length>=1) rej.push(parts.map(tok=>tok.trim())); continue; }  
 }
    if(mtx.length===N) out.matrix = mtx; if(pts.length===N) out.points = pts;
	if(rej.length>=1) out.rejtveny = rej;     

    return out;
}


function showLeltar(leltar){
  const seedDispEl = document.getElementById('seedDisp');
  const vvDispEl   = document.getElementById('vvDisp');
  const khDispEl   = document.getElementById('khDisp');
  const vvBoxEl    = document.getElementById('vvBox');
  const khBoxEl    = document.getElementById('khBox');
  const szigBoxEl  = document.getElementById('szigBox');

  if(seedDispEl) seedDispEl.textContent = leltar.seed || '-'; 
  if(vvDispEl)   vvDispEl.textContent   = String(leltar.nVV); 
  if(khDispEl)   khDispEl.textContent   = String(leltar.nKH);
  

  if(vvBoxEl)   vvBoxEl.textContent    = `${leltar.nVV} / 0`; 
  if(khBoxEl)   khBoxEl.textContent    = `${leltar.nKH} / 0`; 
  if(szigBoxEl) szigBoxEl.textContent  = leltar.lSZ.length ? leltar.lSZ.join(' - ') : '-';
  updateStatsHud();
  const ord={'p':0,'m':1,' ':2};
  function sortLOPZ(arr){ return (arr||[]).slice().sort((a,b)=>{ const oa=(ord[a?.[0]]??9), ob=(ord[b?.[0]]??9); if(oa!==ob) return oa-ob; const na=parseInt(a?.slice(1)||'0',10)|0, nb=parseInt(b?.slice(1)||'0',10)|0; return na-nb; });}

function block(type, arr){
  const div = document.createElement('div');
  const NAMES = { AL:'ALFA', BE:'BETA', GA:'GAMMA', DE:'DELTA' };

  
  const title = document.createElement('div');
  title.className = 'shipGroup';
  title.textContent = NAMES[type] || type;
  div.appendChild(title);

  
  const items = sortLOPZ(arr || []);

  if(!items.length){
    const item = document.createElement('div');
    item.className = 'shipItem';
    const span = document.createElement('span');
    span.className = 'shipVal';
    span.textContent = '-';
    item.appendChild(span);
    div.appendChild(item);
  } else {
    for(const val of items){
      const item = document.createElement('div');
      item.className = 'shipItem';
      item.setAttribute('data-type', type);

      const span = document.createElement('span');
      span.className = 'shipVal';
      span.textContent = String(val);

      item.appendChild(span);
	  
	        
      var chk = document.createElement('input');
      chk.type = 'checkbox';
      chk.className = 'shipCheck';
      chk.id = 'ship_' + type + '_' + String(val);
      window.STATE = window.STATE || {};
      window.STATE.SHIP_FOUND = window.STATE.SHIP_FOUND || {};
      var key = type + '-' + String(val);
      chk.checked = !!window.STATE.SHIP_FOUND[key];
      chk.addEventListener('change', function(){ window.STATE.SHIP_FOUND[key] = !!chk.checked; if(typeof recomputeAlfaFromBoard==='function') recomputeAlfaFromBoard(); });
      item.appendChild(chk);
	  
      div.appendChild(item);
    }
  }
  return div;
}
    shipCol.innerHTML=''; 
    shipCol.appendChild(block('AL', leltar.lOPZ.AL)); shipCol.appendChild(block('BE', leltar.lOPZ.BE)); 
    shipCol.appendChild(block('GA', leltar.lOPZ.GA)); shipCol.appendChild(block('DE', leltar.lOPZ.DE));
    
    (function(){
      {
        if(Array.isArray(window.REJTVENY) && window.REJTVENY.length){
          const box = document.createElement('div');
          box.id = 'rejtvenyBoxHajok';
          box.style.marginTop = '10mm';
          box.style.background = '#fbfbff';
          box.style.border = '1px dashed #cdd6f5';
          box.style.borderRadius = '6px';                               box.style.borderRadius = '0px';  
          box.style.padding = '2mm 3mm';                                box.style.padding = '0mm 0mm';   
          box.style.whiteSpace = 'pre-wrap';
          box.style.wordWrap = 'break-word';
          box.style.overflowWrap = 'anywhere';
          box.style.color = '#0b2b40';
          const t = document.createElement('div');
          t.style.fontWeight = '800'; t.style.fontSize = '16px'; t.style.color = '#2b3a8a'; t.style.marginBottom = '2mm';    
          t.textContent = 'REJTVÉNY';
          const x = document.createElement('div');
          x.style.lineHeight = '1.3'; x.style.fontSize = '14px';
          x.textContent = window.REJTVENY.map(line => (line||[]).join(' ')).join('\n');
          box.appendChild(t); box.appendChild(x);
          shipCol.appendChild(box);
          
          const card = document.getElementById('shipCol').closest('.card');
          if(card){
            const measure = () => {
              const rectCard = card.getBoundingClientRect();
              const rectBox  = box.getBoundingClientRect();
              const gap = 2;                            
              const avail = Math.max(24, rectCard.bottom - rectBox.top - gap);
              box.style.maxHeight = avail + 'px';
              let size = 16; const min=11;                             
              x.style.fontSize = size + 'px';
              
              for(let k=0;k<20 && box.scrollHeight>box.clientHeight && size>min;k++){ size--; x.style.fontSize = size + 'px'; }
              box.style.overflow = (box.scrollHeight>box.clientHeight) ? 'auto' : 'hidden';
            };
            requestAnimationFrame(measure);
            window.addEventListener('resize', () => requestAnimationFrame(measure), { passive:true });
          }
        }
      }
    })();


}


loadBtn.addEventListener('click', ()=>{
  // BETÖLTÉS = teljes újrakezdés: a HAJÓK panel pipái is nullázódjanak
  if (window.STATE && window.STATE.SHIP_FOUND) window.STATE.SHIP_FOUND = {};


  
  // Teljes állapot törlése új SMYOZ betöltése előtt
  if (typeof TORLES_WORK === 'function') TORLES_WORK();
    if (typeof SMY !== 'undefined' && typeof TORLES_REAL === 'function') TORLES_REAL();

{  }
{
    window.SMY = window.SMY || {};
    var Nloc = (typeof N==='number' && N>0) ? N : 9;
    if (!Array.isArray(SMY.SOROK_REAL) || SMY.SOROK_REAL.length !== Nloc) SMY.SOROK_REAL = new Array(Nloc).fill('-');
    else SMY.SOROK_REAL.fill('-');
    if (!Array.isArray(SMY.OSZL_REAL) || SMY.OSZL_REAL.length !== Nloc) SMY.OSZL_REAL = new Array(Nloc).fill('-');
    else SMY.OSZL_REAL.fill('-');

diagRefreshVectors(); 
  }
  diagRefreshVectors();
  loadFromSeedText(seedText.value);

});
function loadFromSeedText(raw){
  if(!raw || !raw.trim()){ alert('Illeszd be a SEED.txt tartalmát!'); return; }
  const parsed = parseSeedText(raw); LELTAR = parsed.leltar; writeLeltarPanel(); 
  MATRIX = parsed.matrix || Array.from({length:N},()=>Array(N).fill('---')); 
  POINTS = parsed.points || Array.from({length:N},()=>Array(N).fill('-'));  
  KIKOTOTTHAJOKSZAMA=LELTAR.nKH;  VIZVONALAKSZAMA=LELTAR.nVV;
 
  REJTVENY = parsed.rejtveny || '';    

  window.NVP_CONST = 4 + 2 * (Number(LELTAR && LELTAR.nKH) || 0);
  shots = 0; shotsEl.textContent = '0'; elhelyezesek = 0; autoFills = 0;
  workM = Array.from({length:N},()=>Array(N).fill(null));
  workP = Array.from({length:N},()=>Array(N).fill('-'));
  recomputeGlobals();
  guardWorkP();
  
  if(POINTS){ for(let r=0;r<N;r++) for(let c=0;c<N;c++){ if(POINTS[r][c]==='X') workP[r][c]='X'; }}
  showLeltar(LELTAR); buildEmptyBoard(); if(window.removeAlfaIndicator){ window.removeAlfaIndicator(); } recomputeWaterPoints_2a_TL(); drawPointsOverlay(); resetAlfa(); removeAlfaIndicator(); recomputeAlfaFromBoard(); drawAlfaIndicator();;

  writeFoundIslandsPanel([]);
}


function parseIndex(str){ const s=(str||'').trim(); if(!/^\d{2}$/.test(s)) return null; const c=parseInt(s[0],10)-1; const r=parseInt(s[1],10)-1; if(r<0||r>=N||c<0||c>=N) return null; return {r,c}; }


function __countMVP__(){
  try{
    const N9 = (typeof N==='number')?N:9;
    let cnt = 0;
    for(let r=0;r<=N9-2;r++){
      for(let c=0;c<=N9-2;c++){
        const v = (workP && workP[r]) ? workP[r][c] : undefined;
        if(v==='V') cnt++;
      }
    }
    return cnt;
  }catch(e){ return 0; }
}


function shoot(){
  window.__MANUAL_WRITE__ = true;
  if(!LELTAR){ alert('Előbb tölts be LELTÁRT (SEED.txt)!'); return; }
  if(!MATRIX){ alert('A SEED-ben nem volt MATRIX szekció - most nincs mit felfedni.'); return; }
  const pc = parseIndex(idxInput.value); if(!pc){ alert('Adj meg érvényes INDEX-et (pl. 55)!'); idxInput.focus(); return; }
  const {r,c} = pc; const tok = MATRIX[r][c]||''; const {kind, main, color} = parseToken(tok);
  if(kind==='ship'){ setCellShip(r,c,main,(color||'-')); }
  else if(kind==='water'){ setCellWater(r,c,main,(color||'-')); }

  const S = window.SMY || window.S || null;
  if (S && S.ISHOT_REAL && S.ISHOT_REAL[r]){ MIS = S.ISHOT_REAL; }
  MIS[r][c]=true;
  SMY.HOMOK_REAL[r][c]=false;
  // SMY.ISHOT_REAL[r][c]=true;  helyett MIS
  void 0;
  
  window.__MANUAL_WRITE__ = false;
  afterAction(r,c, kind, main, color); 
  {
    const sealOn = (!CFG || !CFG.auto) ? true : (CFG.auto.sealFullShips !== false);
    if(sealOn) findAndSealFullShips();              
  }
  if(CFG.auto.fromWater345) auto_3_4_5_fromWater(r,c, kind, main, color); 
  if(CFG.auto.extendFromPairs) tryExtendFromPairs();                
  if(CFG.auto.recomputeWaterPoints2a) updateWaterPointsAroundCell(r,c);    
  
 
  
  {
    if(typeof window.NVP_CONST==='number' && window.NVP_CONST>0){
      const mvps = __countMVP__();
      if(mvps >= window.NVP_CONST){
        auto_7_fillAllShipPoints(true);
        drawPointsOverlay();
      }
    }
  }
  
   
  drawPointsOverlay();                 

  if(CFG.auto.auto6) auto_6_fromMaxIsland();
  if(CFG.auto.auto6b) auto_6b_fromShipPoints();
  if(CFG.auto.auto7) auto_7_fillAllShipPoints();
  if(CFG.auto.auto16) auto_16_numbered_water_complete_points();  // [AUTO16_CALL_FROM_SHOOT]
  if(CFG.auto.auto2) auto_2_pointV_implies_fourVCells();
  if(CFG.auto.auto14a){

/* ====== Automatizmus 23a: hajópont kilökés szomszéd víz párok alapján ====== */
  auto_14a_rowcol_vectors_from_ship_gaps();
  }
  if(CFG.auto.auto14 && window.auto_14_fill_vectors_between_red_segments){
    window.auto_14_fill_vectors_between_red_segments();
  }
  if(CFG.auto.auto13b !== false && window.auto_13b_fix_colors_from_vectors){
    window.auto_13b_fix_colors_from_vectors(); // [AUTO13B_CALL_FROM_SHOOT]
  }
  refreshTopBoxes();

  drawPointsOverlay();

  shots++; shotsEl.textContent=String(shots);
  updateStatsHud();
  idxInput.value=''; idxInput.focus();
  { const el = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`); if(el) el.setAttribute('data-shot','1'); }

  /* AUTO RE-RUN LOOP */
  while (true) {
    // detect changes made by autos even if they write directly
    let __before = (typeof workM!=='undefined' && typeof workP!=='undefined') ? JSON.stringify([workM, workP]) : null;
    SMY.changed = false;
    if(CFG.auto.auto6) auto_6_fromMaxIsland();
    if(CFG.auto.auto6b) auto_6b_fromShipPoints();
    if(CFG.auto.auto7) auto_7_fillAllShipPoints();
    if(CFG.auto.auto14 && typeof auto_14_fill_vectors_between_red_segments==='function') auto_14_fill_vectors_between_red_segments();
    if(CFG.auto.auto16 && typeof auto_16_numbered_water_complete_points==='function') auto_16_numbered_water_complete_points(); // [AUTO16_CALL_FROM_RUNALL]
    if(CFG.auto.auto2 && typeof auto_2_pointV_implies_fourVCells==='function') auto_2_pointV_implies_fourVCells();
    let __after = (typeof workM!=='undefined' && typeof workP!=='undefined') ? JSON.stringify([workM, workP]) : null;
    if(typeof drawPointsOverlay==='function') drawPointsOverlay();
    if (!SMY.changed && __before === __after) break;
  }

  if (window.debugCheckRealVsWork){ window.debugCheckRealVsWork('shoot/loop'); }

var __AUT13_ret = 0;
__AUT13_ret = enforceAuto13WaterVectors();
if(__AUT13_ret) void 0;
  if (window.debugCheckRealVsWork){ window.debugCheckRealVsWork('shoot/AUT13'); }
  {
    // LÖVÉS utáni egységes redraw – különösen Haladó módban, hogy az AUT-mezők azonnal elrejthetők
    if (typeof redrawSimpleStrict === 'function'){
      redrawSimpleStrict();
    } else if (typeof window.__redrawSimpleStrict === 'function'){
      window.__redrawSimpleStrict();
    }
  }
}

idxInput.addEventListener('keydown',(e)=>{ if(e.key==='Enter'){ e.preventDefault(); shoot(); } });
shootBtn.addEventListener('click', shoot);


buildEmptyBoard(); if(window.removeAlfaIndicator){ window.removeAlfaIndicator(); }
let rezTimer=null; window.addEventListener('resize', ()=>{ clearTimeout(rezTimer); rezTimer=setTimeout(()=>{ drawIndexes(); drawPointsOverlay(); }, 120); });


function updateStatsHud(){
  const s = (typeof shots !== 'undefined') ? shots : 0;
  const e = (typeof elhelyezesek !== 'undefined') ? elhelyezesek : 0;
  const solved = countSolvedCells();

  const text =
    `Lövések: <span class="hud-dyn">${s}</span>` +
    ` | ELHELYEZések: <span class="hud-dyn">${e}</span>` +
    ` | Megfejtett: <span class="hud-dyn">${solved}</span>/77`;

  const el = document.getElementById('sumRow');
  if (el) el.innerHTML = text;
}

/* ====== SEED fájl kiválasztás ====== */
const seedFileInput = document.getElementById('seedFileInput');
if (seedFileInput){
  seedFileInput.addEventListener('change', async (ev)=>{
    const f = ev.target.files && ev.target.files[0];
    if(!f) return;
    const txt = await f.text();
    window.__lastFileText = txt; // csak kényelmi tárolás
    if (seedText) seedText.value = txt;

    // A Tallózás csak beilleszt: a tényleges betöltést MINDIG a BETÖLTÉS gomb végzi.
    const paste = document.getElementById('seedPastePanel'); if (paste) paste.style.display = 'block';
    const btn   = document.getElementById('loadSeed');      if (btn)   btn.style.display   = 'inline-block';
  });
}

var __SHIP_COMMIT__ = false; 
function markShipPoints(i, j){
  if(!__SHIP_COMMIT__) return; 
  if(!workP) return;
  const pts = [[i,j],[i-1,j],[i,j-1],[i-1,j-1]];
  for(const [pi,pj] of pts){
    if(pi<0||pj<0||pi>(N-2)||pj>(N-2)) continue; 
    if(workP[pi][pj]!=='X') workP[pi][pj]='H';
  }
}


function guardWorkP()
{
	return true;   
}


/* Forrás: AUTOMATIZMUSOK.txt - itt most a legbiztonságosabb részhalmaz: nMM, nMS, nMO, nPP, nMVP, nVP */
window.STATE = window.STATE || {
  nMM: 0,          
  nMS: Array(9).fill(0), 
  nMO: Array(9).fill(0), 
  nPP: 0,          
  nMVP: 0,         
  nVP: 0           
};

function recomputeGlobals(){
  {
    const N9 = (typeof N==='number') ? N : 9;
    if(!window.STATE){ window.STATE = { nMM:0, nMS:Array(N9).fill(0), nMO:Array(N9).fill(0), nPP:0, nMVP:0, nVP:0, maxIsland:0 }; }

        if(!window.STATE){ window.STATE = { nMM:0, nMS:Array(N9).fill(0), nMO:Array(N9).fill(0), nPP:0, nMVP:0, nVP:0, maxIsland:0 }; }
        // Szabad mezők (MATRIX): ahol a workM[r][c] nincs, vagy kind nincs ('ship'/'water')
    let nMM = 0;
    const nMS = Array(N9).fill(0);
    const nMO = Array(N9).fill(0);
    for(let r=0;r<N9;r++){
      for(let c=0;c<N9;c++){
        const cell = (window.workM && workM[r]) ? workM[r][c] : undefined;
        const kind = cell && cell.kind;
        const corner = (r===0&&c===0)||(r===0&&c===N9-1)||(r===N9-1&&c===0)||(r===N9-1&&c===N9-1);
        const isFree = (!corner) && (!kind || (kind!=='ship' && kind!=='water'));
        if(isFree){ nMM++; nMS[r]++; nMO[c]++; }
      }
    }
    window.STATE.nMM = nMM; window.STATE.nMS = nMS; window.STATE.nMO = nMO;

    
    let nPP = 0, nMVP = 0;
    for(let r=0;r<=N9-2;r++){
      for(let c=0;c<=N9-2;c++){
        const v = (workP && workP[r]) ? workP[r][c] : undefined;
        if(v===null || typeof v==='undefined'){ nPP++; }
        else if(v==='V'){ nMVP++; }
      }
    }
    window.STATE.nPP = nPP; window.STATE.nMVP = nMVP;

    
    let nKH = (window.LELTAR && typeof LELTAR.nKH === 'number') ? LELTAR.nKH : 0;
	nKH=KIKOTOTTHAJOKSZAMA;
	nVV=VIZVONALAKSZAMA;
    window.STATE.nVP = 4 + 2*nKH;

    
    try{
      const el = document.getElementById('diagGlobalsBody');
      if(el){
        el.innerHTML = ''  
          + '<div>nMM: <b>' + window.STATE.nMM + '</b></div>'
          + '<div>nMS: <span class="mono">' + window.STATE.nMS.join(' ') + '</span></div>'
          + '<div>nMO: <span class="mono">' + window.STATE.nMO.join(' ') + '</span></div>'
          + '<div>nPP: <b>' + window.STATE.nPP + '</b></div>'
          + '<div>nMVP: <b>' + window.STATE.nMVP + '</b></div>'
          + '<div>nVP: <b>' + window.STATE.nVP + '</b></div>';
      }
    }catch(e){}
  }
}


function parseTokenSafe(r,c){
  // Kezdő módban az INPUT (MATRIX) alapján, Játék/Haladó módban a feltárt M_REAL alapján dolgozunk.
  var mode = EdJaMode;
  /*try{
    if (typeof getViewModeForRedraw === 'function'){
      mode = getViewModeForRedraw();  // kizárólag Edzés/Játék kapcsoló
    } else {
      var h = document.getElementById('mode_halado');
      if (h && h.checked) mode = 'halado';
    }
  }catch(e){
    mode = 'kezdo';
  }*/

  var t = '';
  if (mode === 'halado'){
    // Játék (Haladó) módban nem leskelődünk az INPUT-ba, csak a valós M_REAL állapotot nézzük.
    var S = (typeof SMY !== 'undefined' && SMY) ? SMY : (typeof window !== 'undefined' ? (window.SMY || window.S || null) : null);
    var MR = S && S.M_REAL ? S.M_REAL : (typeof M_REAL !== 'undefined' ? M_REAL : null);
    if (MR && MR[r]) t = MR[r][c] || '---';
  } else {
    // Edzés (Kezdő) módban marad az INPUT-alapú működés.
    if (typeof MATRIX !== 'undefined' && MATRIX && MATRIX[r]) t = MATRIX[r][c] || '---';
  }
  return parseToken(t);
}
function lengthOfShipCode(code)
{ 
    const m=String(code||'').toUpperCase(); if(m==='A'||m==='AL') return 4; if(m==='B'||m==='BE') return 3; 
   if(m==='G'||m==='GA') return 2; if(m==='D'||m==='DE') return 1; return 1; 
}
function isShipDrawn(r,c){
  // DOM-független hajódetektálás: csak az adatmodellre támaszkodunk,
  // hogy a Haladó / Kezdő nézet különbsége ne zavarja meg az AUT20/21-et.
  {
    if (typeof workM !== 'undefined' && workM && workM[r] && workM[r][c] && workM[r][c].kind === 'ship'){
      return true;
    }
    const S = window.SMY || window.S || null;
    if (S && S.M_REAL && S.M_REAL[r]){
      const tok = String(S.M_REAL[r][c] || '---');
      const T = tok.charAt(0);
      if (T==='A' || T==='B' || T==='G' || T==='D' || T==='H'){
        return true;
      }
    }
  }
  return false;
}



function cellRect()
{ 
   const rect = gridEl.getBoundingClientRect(); return {w:rect.width,h:rect.height,cw:rect.width/N,ch:rect.height/N}; 
}
function pointPixel(r,c)
{ 
  
  const {cw,ch} = cellRect(); const x = (c+1)*cw; const y = (r+1)*ch; return {x,y};
}


function drawPointsOverlay(){
  if(!workP){ gPoints.innerHTML=''; gSegments.innerHTML=''; return; }
  gPoints.innerHTML=''; gSegments.innerHTML='';
  const {cw,ch} = cellRect(); const rad = Math.max(2, Math.min(cw,ch)*0.06);
  
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const P = workP[r][c]; if(P!=='V') continue;
      
      if(c+1<N && workP[r][c+1]==='V'){
        const p1 = pointPixel(r,c), p2 = pointPixel(r,c+1);
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', p1.x); line.setAttribute('y1', p1.y); line.setAttribute('x2', p2.x); line.setAttribute('y2', p2.y);
        line.setAttribute('class','seg-water'); gSegments.appendChild(line);
      }
      
      if(r+1<N && workP[r+1][c]==='V'){
        const p1 = pointPixel(r,c), p2 = pointPixel(r+1,c);
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', p1.x); line.setAttribute('y1', p1.y); line.setAttribute('x2', p2.x); line.setAttribute('y2', p2.y);
        line.setAttribute('class','seg-water'); gSegments.appendChild(line);
      }
    }
  }
  
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const P = workP[r][c]; if(!P || P==='X') continue; 
      const {x,y} = pointPixel(r,c);
      const el = document.createElementNS('http://www.w3.org/2000/svg', P==='V'?'circle':'circle');
      if(P==='V'){ el.setAttribute('r',rad); el.setAttribute('class','pt-water'); }
      else if(P==='H'){ el.setAttribute('r',rad*0.8); el.setAttribute('class','pt-ship'); }
      el.setAttribute('cx',x); el.setAttribute('cy',y); gPoints.appendChild(el);
    }
  }

  
  

}

/* ====== Automatizmus 11 (Parton ismert típusú hajómező → teljes hajó befelé) ====== */
function tryEdgeCompletion(r,c,code){
  // AUT11: már csak az új (auto11) kapcsolót használja
  if(CFG && CFG.auto && CFG.auto.auto11 === false) return;

  if(!workM || !MATRIX) return;
  const L = lengthOfShipCode(code);
  if(L<=1) return;
  let dir = null;
  if(r===0) dir='D';
  else if(r===N-1) dir='U';
  else if(c===0) dir='R';
  else if(c===N-1) dir='L';
  if(!dir) return;
  const step=(pos,dir)=>{
    let [rr,cc]=pos;
    if(dir==='D') rr++;
    else if(dir==='U') rr--;
    else if(dir==='R') cc++;
    else if(dir==='L') cc--;
    return [rr,cc];
  };
  let cur=[r,c];
  const cells=[[r,c]];
  for(let k=1;k<L;k++){
    cur=step(cur,dir);
    const [rr,cc]=cur;
    if(rr<0||cc<0||rr>=N||cc>=N) return;
    cells.push([rr,cc]);
	setCellShip(rr,cc,code,'-');
    const p=parseTokenSafe(rr,cc);
    if(p.kind==='ship' && p.main.toUpperCase()===code.toUpperCase())
	{
      setCellShip(rr,cc,code,p.color||'-');
    } 
  }
  if(cells.length===L){
    surroundRunWithWater(cells);
  }
}

/* ====== Automatizmus 20: TELJES hajó körül víz ====== */
function surroundRunWithWater(run){
  // AUT20: csak az új (sealFullShips) kapcsolót használja
  if (CFG && CFG.auto && CFG.auto.sealFullShips === false) return;

  const seen=new Set();
  for(const [r,c] of run){
    for(let dr=-1; dr<=1; dr++){
      for(let dc=-1; dc<=1; dc++){
        const rr=r+dr, cc=c+dc; if(rr<0||cc<0||rr>=N||cc>=N) continue; const key=rr+','+cc; if(seen.has(key)) continue;
        if(isShipDrawn(rr,cc)) continue; const p = parseTokenSafe(rr,cc);
        if(p.kind==='water'){ setCellWater(rr,cc,p.main,p.color||'-'); } else { setCellWater(rr,cc,'V',p.color); }
        seen.add(key);
      }
    }
  }
}
function scanLinesAndSeal(getRC){
  // AUT20: teljes hajó lezárása - 'H' jelű hajómezők kizárva (azok nem garantáltan teljes hajók)
  if (CFG && CFG.auto && CFG.auto.sealFullShips === false) return;
  if (!gridEl || typeof getRC !== 'function') return;

  let i = 0;
  while (i < N){
    let run = [];
    let code = null;

    
    while (i < N){
      const [r, c] = getRC(i);
      const el = gridEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
      if (!el) break;

      const mainTxt = (el.querySelector('.cellTextMain')?.textContent || '').trim();
      if (el.classList.contains('ship') && mainTxt){
        const ch = mainTxt[0].toUpperCase();

        // 'H' csak általános hajómező - AUT20 nem vizsgálja, mert nem tudjuk, hogy teljes-e a hajó
        if (ch === 'H'){
          break;
        }

        if (!code){
          code = ch;
        } else if (ch !== code){
          break;
        }

        run.push([r, c]);
        i++;
      } else {
        break;
      }
    }

    
    if (run.length){
      const normCode = (code || '').toUpperCase();
      if (normCode !== 'H'){ 
        const need = lengthOfShipCode(code);
        const beforeIdx = i - run.length - 1;
        const afterIdx  = i;
        let beforeOK = true;
        let afterOK  = true;

        
        if (beforeIdx >= 0){
          const [br, bc] = getRC(beforeIdx);
          const elb = gridEl.querySelector(`.cell[data-r="${br}"][data-c="${bc}"]`);
          const bMain = (elb?.querySelector('.cellTextMain')?.textContent || '').trim();
          beforeOK = !(elb && elb.classList.contains('ship') && bMain);
        }

        
        if (afterIdx < N){
          const [ar, ac] = getRC(afterIdx);
          const ela = gridEl.querySelector(`.cell[data-r="${ar}"][data-c="${ac}"]`);
          const aMain = (ela?.querySelector('.cellTextMain')?.textContent || '').trim();
          afterOK = !(ela && ela.classList.contains('ship') && aMain);
        }

        
        if (run.length === need && beforeOK && afterOK){
          surroundRunWithWater(run);
        }
      }
    }

    i++;
  }
}

function findAndSealFullShips(){
  // AUT20: globális végigszaladásnál már csak az új kapcsolót használjuk
  if (CFG && CFG.auto && CFG.auto.sealFullShips === false) return;
 window.__MANUAL_WRITE__ = true; for(let r=0;r<N;r++){ scanLinesAndSeal(i=>[r,i]); } for(let c=0;c<N;c++){ scanLinesAndSeal(i=>[i,c]); } window.__MANUAL_WRITE__ = false; updateStatsHud && updateStatsHud(); }

/* ====== Automatizmus 1 (hajó sarkaira víz) + kiterjesztés ====== */
function afterAction(r,c, kind, main, color)
{
  if(kind==='ship')
  {
    const deltas = (CFG.auto.cornersWater ? [[-1,-1],[-1,1],[1,-1],[1,1]] : []);
    for(const [dr,dc] of deltas)
	{ const rr=r+dr, cc=c+dc; if(rr>=0 && cc>=0 && rr<N && cc<N)
	  {   
	    const p = parseTokenSafe(rr,cc); 
	    if(p.kind==='water'){ setCellWater(rr,cc,p.main,p.color||'-'); } 
   	    else { setCellWater(rr,cc,'V','-'); } 
	  } 
    }
    if(main){ tryEdgeCompletion(r,c,main); }
  }
  {
    const sealOn = (!CFG || !CFG.auto) ? true : (CFG.auto.sealFullShips !== false);
    if(sealOn) findAndSealFullShips();
  }
  if(typeof recomputeAlfaFromBoard==='function') recomputeAlfaFromBoard();
  updateStatsHud();
  if (window.debugCheckRealVsWork){ window.debugCheckRealVsWork('afterAction'); }
}



function auto_1_shipCornersFromReal(){
  if(!window.CFG || !CFG.auto || !CFG.auto.cornersWater) return 0;
  var MR = (typeof SMY!=='undefined' && SMY && SMY.M_REAL) || (typeof M_REAL!=='undefined' ? M_REAL : null);
  if(!MR || !MR.length) return 0;
  var N = MR.length, applied = 0, r, c, cell, t, c1, c2, rr, cc;
  var deltas = [[-1,-1],[-1,1],[1,-1],[1,1]];
  for(r=0;r<N;r++){
    for(c=0;c<N;c++){
      cell = MR[r][c];
      if(!cell) continue;
      t = cell[0];
      if(t!=='A' && t!=='B' && t!=='G' && t!=='D' &&  t!=='H') continue;
      for(var i=0;i<4;i++){
        rr = r + deltas[i][0]; cc = c + deltas[i][1];
        if(rr<0||cc<0||rr>=N||cc>=N) continue;
        cell = MR[rr][cc] || '---';
        t = cell[0] || '-'; c1 = cell[1] || '-'; c2 = cell[2] || '-';
        if(t!=='-') continue;
        MR[rr][cc] = 'V' + c1 + c2;
        applied++;
        VALTOZAS = true;
      }
    }
  }
  return applied;
}

/* ====== Automatizmus 3,4,5 (vízmezők szabályai) ====== */
function auto_3_4_5_fromWater(r,c, kind, main, color){
  

  if(!CFG.auto.fromWater345) return;
  if(kind!=='water') return; const num=parseInt(main,10);
  if(num===3){ [[-1,0],[1,0],[0,-1],[0,1]].forEach(([dr,dc])=>{ const rr=r+dr, cc=c+dc; 
  if(rr<0||cc<0||rr>=N||cc>=N) return; 
  const p=parseTokenSafe(rr,cc); setCellWater(rr,cc,p.kind==='water'?p.main:'V',(p.color||'-')); updateWaterPointsAroundCell(rr,cc); }); }
  if(num===4){ for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0) continue; const rr=r+dr, cc=c+dc; if(rr<0||cc<0||rr>=N||cc>=N) continue; const p=parseTokenSafe(rr,cc); setCellWater(rr,cc,p.kind==='water'?p.main:'V',(p.color||'-')); updateWaterPointsAroundCell(rr,cc); } }
  if(color==='zz'){ 
    for(let cc=0;cc<N;cc++)
	{ const p=parseTokenSafe(r,cc); 
	  setCellWater(r,cc,p.kind==='water'?p.main:'V',(p.color||'-')); 
	  updateWaterPointsAroundCell(r,cc); 
	}
    for(let rr=0;rr<N;rr++)
	{ const p=parseTokenSafe(rr,c); 
	  setCellWater(rr,c,p.kind==='water'?p.main:'V',(p.color||'-')); 
	  updateWaterPointsAroundCell(rr,c); }
  }
}

/* ====== Automatizmus 2 és 2a (vízpont ↔ vízmezők) ====== */
function markPoint(r,c, val){ if(!workP) return; if(r<0||c<0||r>=N||c>=N) return; if(workP[r][c]==='X') return; 
  if(workP[r][c] && workP[r][c]!==val) { workP[r][c]=val; } else if(!workP[r][c]) { workP[r][c]=val; } }


function recomputeWaterPoints_2a_TL(){
  if(!CFG.auto.recomputeWaterPoints2a) return;

  if(!workM || !workP) return;
  
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      if(workP[r][c]==='X') continue;
	  if(workP[r][c]!=='H' && workP[r][c]!=='V') workP[r][c] = '-';

    }
  }
  
  for(let r=0;r<N-1;r++){
    for(let c=0;c<N-1;c++){
      const a = workM?.[r]?.[c];
      const b = workM?.[r]?.[c+1];
      const d = workM?.[r+1]?.[c];
      const e = workM?.[r+1]?.[c+1];
      if(a && b && d && e && a.kind==='water' && b.kind==='water' && d.kind==='water' && e.kind==='water'){
        
        if(workP[r][c]!=='X') workP[r][c]='V';
      }
    }
  }
}
function updateWaterPointsAroundCell(r,c){ 
  recomputeWaterPoints_2a_TL();
}

/* ====== Automatizmus 21 (szomszédos hajók → teljes hajó) ====== */
function tryExtendFromPairs(){
  if(!CFG.auto.extendFromPairs) return;

/////////////////////////////////////////////////////////////  
  
  var MR = null;
  if (typeof SMY !== 'undefined' && SMY && SMY.M_REAL) {
    MR = SMY.M_REAL;
  } else if (typeof M_REAL !== 'undefined') {
    MR = M_REAL;
  }


  // --- Hossz-korlát ellenőrzés: automatizmus ne hozzon létre túl hosszú hajót ---
  function __lenOfShip__(code){
    if (typeof lengthOfShipCode === 'function') return lengthOfShipCode(code);
    var m = String(code||'').toUpperCase();
    if (m === 'A') return 4;
    if (m === 'B') return 3;
    if (m === 'G') return 2;
    if (m === 'D') return 1;
    return 0;
  }
  function __mainAt__(r,c){
    var w = (typeof workM !== 'undefined' && workM && workM[r]) ? workM[r][c] : null;
    if (w && w.kind === 'ship' && w.main) return String(w.main).toUpperCase();
    var s = (MR && MR[r]) ? MR[r][c] : null;
    if (typeof s === 'string' && s.length){
      var ch = s.charAt(0).toUpperCase();
      if (ch === 'H' || ch === 'A' || ch === 'B' || ch === 'G' || ch === 'D') return ch;
    }
    return '';
  }
  function __runLenAfterSet__(r,c,main){
    main = String(main||'').toUpperCase();
    var h = 1, v = 1;
    for (var cc = c-1; cc >= 0; cc--){ if (__mainAt__(r,cc) === main) h++; else break; }
    for (var cc2 = c+1; cc2 < N; cc2++){ if (__mainAt__(r,cc2) === main) h++; else break; }
    for (var rr = r-1; rr >= 0; rr--){ if (__mainAt__(rr,c) === main) v++; else break; }
    for (var rr2 = r+1; rr2 < N; rr2++){ if (__mainAt__(rr2,c) === main) v++; else break; }
    return (h > v) ? h : v;
  }
  function __canSetShipHere__(r,c,main){
    var L = __lenOfShip__(main);
    if (!L) return true;
    return (__runLenAfterSet__(r,c,main) <= L);
  }

  // Elő-passz: minden M_REAL-beli 'H..' mező (határozatlan hajó)
  


  // (A korábbi 'GYANÚS' blokk törölve: nem szükséges, és M_REAL/workM keverést okozott.)

  
  
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      let A=workM?.[r]?.[c];
      if(!A || A.kind!=='ship') continue;

      
      if(c+1<N){
        let B=workM?.[r]?.[c+1];
        if(B && B.kind==='ship'){
          let mainA = String(A.main||'').toUpperCase();
          let mainB = String(B.main||'').toUpperCase();

          if(mainA==='H' && mainB!=='H'){
            if(mainB!=='D'){
              if(__canSetShipHere__(r,c,mainB)) setCellShip(r,c, mainB, A.color || B.color || '-');
              A = workM?.[r]?.[c];
              mainA = String(A.main||'').toUpperCase();
            }else{
              
            }
          }else if(mainB==='H' && mainA!=='H'){
            if(mainA!=='D'){
              if(__canSetShipHere__(r,c+1,mainA)) setCellShip(r,c+1, mainA, B.color || A.color || '-');
              B = workM?.[r]?.[c+1];
              mainB = String(B.main||'').toUpperCase();
            }else{
              
            }
          }
        }

        
        A = workM?.[r]?.[c];
        const B2 = workM?.[r]?.[c+1];
        if(A && B2 && A.kind==='ship' && B2.kind==='ship' && B2.main===A.main){
          extendShipFrom(r,c,'H',A.main);
        }
      }

      
      if(r+1<N){
        let B=workM?.[r+1]?.[c];
        if(B && B.kind==='ship'){
          let mainA = String(A.main||'').toUpperCase();
          let mainB = String(B.main||'').toUpperCase();

          if(mainA==='H' && mainB!=='H'){
            if(mainB!=='D'){
              if(__canSetShipHere__(r,c,mainB)) setCellShip(r,c, mainB, A.color || B.color || '-');
              A = workM?.[r]?.[c];
              mainA = String(A.main||'').toUpperCase();
            }else{
              
            }
          }else if(mainB==='H' && mainA!=='H'){
            if(mainA!=='D'){
              if(__canSetShipHere__(r+1,c,mainA)) setCellShip(r+1,c, mainA, B.color || A.color || '-');
              B = workM?.[r+1]?.[c];
              mainB = String(B.main||'').toUpperCase();
            }else{
              
            }
          }
        }

        
        A = workM?.[r]?.[c];
        const B2v = workM?.[r+1]?.[c];
        if(A && B2v && A.kind==='ship' && B2v.kind==='ship' && B2v.main===A.main){
          extendShipFrom(r,c,'V',A.main);
        }
      }
    }
  }

}
function extendShipFrom(r,c,orient,code){ const need=lengthOfShipCode(code); const cells=[];
  if(orient==='H'){ 
    let cc=c; while(cc>=0 && workM?.[r]?.[cc]?.kind==='ship' && workM[r][cc].main===code){ cells.unshift([r,cc]); cc--; }
    
    cc=c+1; while(cc<N && workM?.[r]?.[cc]?.kind==='ship' && workM[r][cc].main===code){ cells.push([r,cc]); cc++; }
    // próbáljuk kiterjeszteni a MATRIX alapján
    let left=cells[0][1]-1; while(cells.length<need && left>=0 && parseTokenSafe(r,left).kind==='ship' && parseTokenSafe(r,left).main===code){ setCellShip(r,left,code,parseTokenSafe(r,left).color||'-'); cells.unshift([r,left]); left--; }
    let right=cells[cells.length-1][1]+1; while(cells.length<need && right<N && parseTokenSafe(r,right).kind==='ship' && parseTokenSafe(r,right).main===code){ setCellShip(r,right,code,parseTokenSafe(r,right).color||'-'); cells.push([r,right]); right++; }
    if(cells.length===need){ surroundRunWithWater(cells); }
  }else{
    
    let rr=r; while(rr>=0 && workM?.[rr]?.[c]?.kind==='ship' && workM[rr][c].main===code){ cells.unshift([rr,c]); rr--; }
    
    rr=r+1; while(rr<N && workM?.[rr]?.[c]?.kind==='ship' && workM[rr][c].main===code){ cells.push([rr,c]); rr++; }
    // kiterjesztés MATRIX alapján
    let up=cells[0][0]-1; while(cells.length<need && up>=0 && parseTokenSafe(up,c).kind==='ship' && parseTokenSafe(up,c).main===code){ setCellShip(up,c,code,parseTokenSafe(up,c).color||'-'); cells.unshift([up,c]); up--; }
    let down=cells[cells.length-1][0]+1; while(cells.length<need && down<N && parseTokenSafe(down,c).kind==='ship' && parseTokenSafe(down,c).main===code){ setCellShip(down,c,code,parseTokenSafe(down,c).color||'-'); cells.push([down,c]); down++; }
    if(cells.length===need){ surroundRunWithWater(cells); }
  }
}

/* ====== Automatizmus 22 (vízmező oldalán vízpont-párok → szigetszegmensek) ====== */
// Már megoldja a drawPointsOverlay: ha két szomszédos pont 'V', automatikusan behúzzuk a vonalat.

(function(){
  const LSKEY='smyoz_auto_flags_v1';
  const def=JSON.parse(JSON.stringify(CFG.auto));
  function load(){ try{ const s=localStorage.getItem(LSKEY); if(!s) return {...def}; const o=JSON.parse(s); return {...def,...o}; }catch(e){ return {...def}; } }
  function save(o){ localStorage.setItem(LSKEY, JSON.stringify(o)); }
  function apply(o){
    Object.assign(CFG.auto, o);
    [['sw_cornersWater','cornersWater'],
     ['sw_fromWater345','fromWater345'],['sw_extendFromPairs','extendFromPairs'],['sw_recomputeWaterPoints2a','recomputeWaterPoints2a'],
     ['sw_bridgeOneGapPairs','bridgeOneGapPairs'],['sw_auto6','auto6'],['sw_auto6b','auto6b'],['sw_auto7','auto7']].forEach(([id,key])=>{ const el=document.getElementById(id); if(el) el.checked=!!o[key]; });
  }
  const flags=load(); apply(flags);
  const rows=document.getElementById('autoRows'); const btn=document.getElementById('autoTgl');
  if(btn&&rows){ btn.addEventListener('click', ()=>{ rows.style.display=(rows.style.display==='none'?'block':'none'); }); }
  
  const rec=document.getElementById('autoRec');
  if(rec){ rec.addEventListener('click', ()=>{ const f=load(); f.recomputeWaterPoints2a=true; save(f); apply(f); }); }
  
  [['sw_cornersWater','cornersWater'],
   ['sw_fromWater345','fromWater345'],['sw_extendFromPairs','extendFromPairs'],['sw_recomputeWaterPoints2a','recomputeWaterPoints2a'],
   ['sw_bridgeOneGapPairs','bridgeOneGapPairs'],['sw_auto6','auto6'],['sw_auto6b','auto6b'],['sw_auto7','auto7']].forEach(([id,key])=>{
    const el=document.getElementById(id);
    if(el){ el.addEventListener('change', ()=>{ const f=load(); f[key]=!!el.checked; save(f); apply(f); }); }
  });
})();

const STATE = (window.STATE||{}); if(!('alfaOri' in STATE)) STATE.alfaOri=null; if(!('alfaConflict' in STATE)) STATE.alfaConflict=false;

function _alfaPerp(ori){ if(ori==='H') return 'V'; if(ori==='V') return 'H'; return null; }
function _lopzKeyFromMain(main){
  if(main==='A') return 'AL';
  if(main==='B') return 'BE';
  if(main==='G') return 'GA';
  if(main==='D') return 'DE';
  return null;
}
function _getEffectiveMainAt(r,c){
  try{
    const wm = (typeof workM !== 'undefined') ? workM : null;
    const p = wm && wm[r] && wm[r][c];
    if(p && p.kind==='ship' && p.main) return p.main;
  }catch(e){}
  try{
    const S = (typeof SMY !== 'undefined' && SMY) ? SMY : (typeof window !== 'undefined' ? (window.SMY || window.S || null) : null);
    const MR = S && S.M_REAL ? S.M_REAL : (typeof M_REAL !== 'undefined' ? M_REAL : null);
    if(MR && MR[r]){
      const t = MR[r][c] || '---';
      const main = t.charAt(0);
      if(main==='A'||main==='B'||main==='G'||main==='D'||main==='H') return main;
    }
  }catch(e){}
  return '';
}
function _findShipOriAt(r,c){
  const main = _getEffectiveMainAt(r,c);
  if(!main) return null;

  let h=1,cc=c-1;
  while(cc>=0 && _getEffectiveMainAt(r,cc)===main){ h++; cc--; }
  cc=c+1;
  while(cc<N && _getEffectiveMainAt(r,cc)===main){ h++; cc++; }
  if(h>=2) return 'H';

  let v=1,rr=r-1;
  while(rr>=0 && _getEffectiveMainAt(rr,c)===main){ v++; rr--; }
  rr=r+1;
  while(rr<N && _getEffectiveMainAt(rr,c)===main){ v++; rr++; }
  if(v>=2) return 'V';

  return null;
}
function _relSetForTypeKey(typeKey){
  const out = [];
  const seen = {};

  const lelt = (typeof LELTAR !== 'undefined' && LELTAR && LELTAR.lOPZ) ? LELTAR : null;
  const arr = lelt && lelt.lOPZ && lelt.lOPZ[typeKey] ? lelt.lOPZ[typeKey] : null;

  let uniform = '';
  if(Array.isArray(arr) && arr.length){
    for(let i=0;i<arr.length;i++){
      const v = String(arr[i]||'').trim();
      if(!v) continue;
      const ch = v.charAt(0).toLowerCase();
      if(ch!=='p' && ch!=='m') continue;
      if(!uniform) uniform = ch;
      else if(uniform !== ch){ uniform = '?'; break; }
    }
    if(uniform && uniform !== '?'){
      seen[uniform]=true;
      out.push(uniform);
      return out; // egyértelmű típus-szintű viszony
    }
  }

  const sf = window.STATE && window.STATE.SHIP_FOUND ? window.STATE.SHIP_FOUND : null;
  if(sf){
    for(const k in sf){
      if(!sf[k]) continue;
      const dash = k.indexOf('-');
      if(dash<0) continue;
      const tk = k.slice(0,dash);
      if(tk !== typeKey) continue;
      const val = k.slice(dash+1);
      const ch = String(val||'').charAt(0).toLowerCase();
      if(ch==='p' || ch==='m'){
        if(!seen[ch]){ seen[ch]=true; out.push(ch); }
      }
    }
  }
  return out;
}
function _inferAlfaCandidatesFrom(main, shipOri){
  const typeKey = _lopzKeyFromMain(main);
  if(!typeKey) return [];
  const rels = _relSetForTypeKey(typeKey);
  if(!rels.length) return [];
  const out = [];
  for(let i=0;i<rels.length;i++){
    const rel = rels[i];
    const ori = (rel==='p') ? shipOri : _alfaPerp(shipOri);
    if(ori && out.indexOf(ori)<0) out.push(ori);
  }
  return out;
}
function setAlfaOri(ori){
  if(STATE.alfaOri===ori) { drawAlfaIndicator(); return; }
  STATE.alfaOri = ori;
  drawAlfaIndicator();
}
function recomputeAlfaFromBoard(){
  const cand = [];
  const seen = {};
  for(let r=0;r<N;r++){
    for(let c=0;c<N;c++){
      const main = _getEffectiveMainAt(r,c);
      if(main!=='A' && main!=='B' && main!=='G') continue; // DELTA (D) nem ad irányt
      const so = _findShipOriAt(r,c);
      if(!so) continue;
      const arr = _inferAlfaCandidatesFrom(main, so);
      for(let i=0;i<arr.length;i++){
        const o = arr[i];
        if(o && !seen[o]){ seen[o]=true; cand.push(o); }
      }
    }
  }

  if(cand.length===1){
    STATE.alfaConflict=false;
    if(STATE.alfaOri!==cand[0]) STATE.alfaOri=cand[0];
    drawAlfaIndicator();
    return;
  }
  if(cand.length===0){
    STATE.alfaConflict=false;
    if(STATE.alfaOri!==null) STATE.alfaOri=null;
    drawAlfaIndicator();
    return;
  }

  // ellentmondás: több irány adódik
  STATE.alfaConflict=true;
  if(STATE.alfaOri!==null) STATE.alfaOri=null;
  drawAlfaIndicator();
}
function maybeInferAlfaOriAt(r,c){ recomputeAlfaFromBoard(); }
function resetAlfa(){ STATE.alfaOri=null; STATE.alfaConflict=false; drawAlfaIndicator(); }

function drawAlfaIndicator(){
  const host = gridEl && gridEl.parentElement || document.body;
  const old=document.getElementById('alfaIndicator'); const old2=document.getElementById('alfaIndicatorLabel');
  if(!CFG_ALFA.showIndicator){ if(old) old.remove(); if(old2) old2.remove(); return; }
  if(getComputedStyle(host).position==='static'){ host.style.position='relative'; }
  let bar=document.getElementById('alfaIndicator'); let lab=document.getElementById('alfaIndicatorLabel');
  if(!bar){ bar=document.createElement('div'); bar.id='alfaIndicator'; host.appendChild(bar); }
  if(!lab){ lab=document.createElement('div'); lab.id='alfaIndicatorLabel'; lab.textContent='ALFA'; host.appendChild(lab); }
  const visible = !!STATE.alfaOri;
  if(!visible){ document.getElementById('alfaIndicator')?.remove(); document.getElementById('alfaIndicatorLabel')?.remove();; return; }
  Object.assign(bar.style,{ position:'absolute', background:'#ff00ff', borderRadius:'3px', boxShadow:'0 0 8px rgba(255,0,255,.6)', pointerEvents:'none', opacity: visible?'1':'0', zIndex: 3 });
  Object.assign(lab.style,{ position:'absolute', color:'#ff00ff', fontWeight:'800', fontSize:'12px', pointerEvents:'none', opacity: visible?'1':'0', zIndex: 3 });
  const cell=gridEl.querySelector('.cell');
  const gRect=gridEl.getBoundingClientRect(); const hRect=host.getBoundingClientRect();
  const cRect=cell ? cell.getBoundingClientRect() : { width: 28, height: 28 };
  const cw=cRect.width, ch=cRect.height; const seg=2.5;
  if(!visible){ return; }
  if(STATE.alfaOri==='H'){
    const w=Math.max(2, seg*cw); const h=Math.max(4, Math.min(8, ch*0.18));
    bar.style.width=w+'px'; bar.style.height=h+'px';
    const top  = gRect.top  - hRect.top  - (h + 56); 
    const left = gRect.right - hRect.left - (w + 12);
    bar.style.left=left+'px'; bar.style.top=top+'px';
    lab.style.left=(left - 40)+'px'; lab.style.top=(top - 2)+'px';
  } else if(STATE.alfaOri==='V'){
    const w=Math.max(4, Math.min(8, cw*0.18)); const h=Math.max(2, seg*ch);
    bar.style.width=w+'px'; bar.style.height=h+'px';
    const left = gRect.left - hRect.left - (w + 56); 
    const top  = gRect.top  - hRect.top + 6;
    bar.style.left=left+'px'; bar.style.top=top+'px';
    lab.style.left=(left - 40)+'px'; lab.style.top=(top + Math.round(h/2) - 8)+'px';
  }
}

(function(){
  const orig_after = afterAction;
  window.afterAction = function(r,c,kind,main,color){
    if(kind==='ship') maybeInferAlfaOriAt(r,c);
    return orig_after.apply(this, arguments);
  };
})();
/* Induláskor és ÚJ SEED környékén frissítünk */
setTimeout(()=>{ recomputeAlfaFromBoard(); }, 0);
document.addEventListener('click', (ev)=>{
  const b = ev.target.closest('button'); if(!b) return;
  const t = (b.id||'') + ' ' + (b.textContent||''); if(/seed/i.test(t)){
    { resetAlfa(); setTimeout(()=>{ recomputeAlfaFromBoard(); }, 0); }
  }
});

</script>
<script>
(function(){
  window.removeAlfaIndicator = function(){
    document.getElementById('alfaIndicator')?.remove();
    document.getElementById('alfaIndicatorLabel')?.remove();
  };
})();
</script>
<script>
(function(){
  const LSKEY_MODE='smyoz_view_mode_v1';
/*  function getMode(){ try{ return JSON.parse(localStorage.getItem(LSKEY_MODE)) || 'kezdo'; }catch(e){ return 'kezdo'; } }*/
  function setMode(m){ localStorage.setItem(LSKEY_MODE, JSON.stringify(m)); }
  function applyMode(m){
    document.body.classList.toggle('mode-halado', m==='halado');
    document.body.classList.toggle('mode-kezdo',  m!=='halado');
    const k=document.getElementById('mode_kezdo'), h=document.getElementById('mode_halado');
	if(k) k.checked=(m==='kezdo'); if(h) h.checked=(m==='halado');  
	m = EdJaMode;
    {
      if(m==='kezdo'){
        CFG.auto.auto6 = true;
        CFG.auto.auto6b = true;
        const sw6 = document.getElementById('sw_auto6');
        const sw6b = document.getElementById('sw_auto6b');
        if(sw6) sw6.checked = true;
        if(sw6b) sw6b.checked = true;
      }
    }
    {
      // Kezdő/Haladó váltáskor azonnali REAL → VIEW frissítés
      var b = document.getElementById('btnRedrawReal');
	  EdJaMode = getViewModeForRedraw();
	  redrawLabelCycle = 0;
      if (b && typeof b.click === 'function'){
        b.click();
      } else if (typeof redrawSimpleStrict === 'function'){
        redrawSimpleStrict();
      } else if (typeof window.__redrawSimpleStrict === 'function'){
        window.__redrawSimpleStrict();
      }
    }
  }
  function init(){
    const m = EdJaMode;  applyMode(m);
    const k=document.getElementById('mode_kezdo'), h=document.getElementById('mode_halado');
    if(k) k.addEventListener('change', ()=>{ if(k.checked){ setMode('kezdo'); applyMode('kezdo'); }});
    if(h) h.addEventListener('change', ()=>{ if(h.checked){ setMode('halado'); applyMode('halado'); }});
  }
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>
<script>

</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  {
    // Ha létezik az adott auto függvény, burkoljuk egy debug loggal
    ['auto6','auto21','auto21a','auto21b','bridge21','islandMax6'].forEach(function(name){
      var f = window[name];
      if(typeof f === 'function' && !f.__wrapped){
        window[name] = function(){  return f.apply(this, arguments); };
        window[name].__wrapped = true;
      }
    });
    
    Array.from(document.querySelectorAll('label,button,span')).forEach(function(el){
      var t = (el.textContent||'').toLowerCase();
      if(t.includes('sziget maxméret') || t.includes('egy lyuk híd')){
        ['click','change'].forEach(function(ev){ el.addEventListener(ev, function(){  }); });
      }
    });
  }
});
</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  {
    var idx = document.getElementById('indexInput');
    var btn = document.getElementById('shootBtn');
    function echoTyped(){
      try{
        var v = (idx && idx.value || '').trim();
        if(v){ idx.placeholder = v; idx.classList.add('hint'); }
      }catch(e){}
    }
    if(idx && !idx.__capEcho){
      idx.addEventListener('keydown', function(ev){ if(ev.key==='Enter'){ echoTyped(); } }, true);
      idx.__capEcho = true;
    }
    if(btn && !btn.__capEcho){
      btn.addEventListener('click', function(){ echoTyped(); }, true);
      btn.__capEcho = true;
    }
  }
});
</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  {
    var btn = document.getElementById('btnDiag');
    var card = document.getElementById('diagGlobals');
    if(btn && card){
      btn.addEventListener('click', function(){
        card.style.display = (card.style.display==='none' || !card.style.display) ? 'block' : 'none';
        if(card.style.display==='block'){ recomputeGlobals(); }
      });
    }
  }
});
</script>

<div aria-label="Diagnosztika" id="diagPaneFloat2" role="dialog">
<h3>Diagnosztika</h3>
<div class="row"><div class="lbl">nMM (szabad mezők)</div><div class="val" id="dg2_nMM">–</div></div>
<div class="row"><div class="lbl">nMS (sor vektor)</div><div class="val" id="dg2_nMS">–</div></div>
<div class="row"><div class="lbl">nMO (oszlop vektor)</div><div class="val" id="dg2_nMO">–</div></div>
<div class="row"><div class="lbl">nPP (szabad pontok)</div><div class="val" id="dg2_nPP">–</div></div>
<div class="row"><div class="lbl">nMVP (megtalált vízpontok)</div><div class="val" id="dg2_nMVP">–</div></div>
<div class="row"><div class="lbl">nVP (összes vízpont)</div><div class="val" id="dg2_nVP">–</div></div>
<div class="row"><div class="lbl">maxIsland(V)</div><div class="val" id="dg2_maxI">–</div></div>
<div class="row"><div class="lbl">SOROK_REAL</div><div class="val" id="dg2_sorok_real">–</div></div>
<div class="row"><div class="lbl">OSZL_REAL</div><div class="val" id="dg2_oszl_real">–</div></div>
<div class="row"><div class="lbl">nKH (kikötött hajók)</div><div class="val" id="dg2_nKH">–</div></div>
<div class="row"><div class="lbl">nVV (vízvonalak)</div><div class="val" id="dg2_nVV">–</div></div>
</div>
<button class="btn-sm" id="btnDiagFloat2" type="button">DIAG</button>
<script>
(function(){
  var __timer2 = null;
  function diagRecompute2()
  {
     {
      var N9 = (typeof N==='number')?N:9;
      
      var nMM=0, nMS=Array(N9).fill(0), nMO=Array(N9).fill(0);
      for(var r=0;r<N9;r++)
	  {
        for(var c=0;c<N9;c++)
		{
          var corner=(r===0&&c===0)||(r===0&&c===N9-1)||(r===N9-1&&c===0)||(r===N9-1&&c===N9-1);
          var cell=(window.workM&&workM[r])?workM[r][c]:undefined;
          var k=cell&&cell.kind;
          var free = (!corner) && (!k || (k!=='ship' && k!=='water'));
          if(free){ nMM++; nMS[r]++; nMO[c]++; }
        }
      }
      
      var nPP=0, nMVP=0;
      for(var rr=0; rr<=N9-2; rr++)
	  {
        for(var cc=0; cc<=N9-2; cc++)
		{
          var v=(workP&&workP[rr])?workP[rr][cc]:undefined;
          if(v===null || typeof v==='undefined') nPP++;
          else if(v==='V') nMVP++;
        }
      }
      
      var nKH = 0;
      try  { nKH = Number(LELTAR.nKH)||0; } catch(e){ nKH = 0; }     
	  
	  var nVV = 0;
      try  { nVV = Number(LELTAR.nVV)||0; } catch(e){ nVV = 0; }

	  KIKOTOTTHAJOKSZAMA=nKH;
	  VIZVONALAKSZAMA=nVV;
	  
      var nVP = 4 + 2*nKH;
	  	void 0;

      
      var seen=Array.from({length:N9-1},()=>Array(N9-1).fill(false));
      var dr=[1,-1,0,0], dc=[0,0,1,-1];
      var best=0;
      for(var r2=0;r2<=N9-2;r2++){
        for(var c2=0;c2<=N9-2;c2++){
          var vv=(workP&&workP[r2])?workP[r2][c2]:undefined;
          if(vv!=='V' || seen[r2][c2]) continue;
          var q=[[r2,c2]], qi=0; seen[r2][c2]=true; var cnt=0;
          while(qi<q.length){
            var cur=q[qi++]; cnt++;
            for(var k2=0;k2<4;k2++)
			{
              var nr=cur[0]+dr[k2], nc=cur[1]+dc[k2];
              if(nr<0||nc<0||nr>N9-2||nc>N9-2) continue;
              if(seen[nr][nc]) continue;
              var v2=(workP[nr]||[])[nc];
              if(v2==='V'){ seen[nr][nc]=true; q.push([nr,nc]); }
            }
          }
          if(cnt>best) best=cnt;
        }
      }

      
      function S(id,val){ var e=document.getElementById(id); if(e) e.textContent=String(val); }
      S('dg2_nMM', nMM);
      S('dg2_nMS', nMS.join(' '));
      S('dg2_nMO', nMO.join(' '));
      S('dg2_nPP', nPP);
      S('dg2_nMVP', nMVP);
      S('dg2_nVP', nVP);
      S('dg2_maxI', best);
      try{ S('dg2_sorok_real', (window.SMY&&SMY.SOROK_REAL)?SMY.SOROK_REAL.join(' '):'–'); }catch(_){ S('dg2_sorok_real','–'); }
      try{ S('dg2_oszl_real',  (window.SMY&&SMY.OSZL_REAL) ?SMY.OSZL_REAL.join(' '):'–'); }catch(_){ S('dg2_oszl_real','–'); }
      S('dg2_nKH', nKH);
      S('dg2_nVV', nVV);
    }
  }
  window.diagRecompute2 = diagRecompute2;

  function toggleDiag2(){
    var pane=document.getElementById('diagPaneFloat2');
    if(!pane) return;
    var show = pane.style.display!=='block';
    pane.style.display = show ? 'block' : 'none';
    if(show){
      diagRecompute2();
      if(__timer2) clearInterval(__timer2);
      __timer2 = setInterval(diagRecompute2, 400);
    }else{
      if(__timer2) clearInterval(__timer2), __timer2=null;
    }
  }
  window.toggleDiag2 = toggleDiag2;

  document.addEventListener('DOMContentLoaded', function(){
    var btn=document.getElementById('btnDiagFloat2');
    if(btn && !btn.__b){ btn.addEventListener('click', function(){ toggleDiag2(); }); btn.__b=true; }
    var shootBtn=document.getElementById('shootBtn');
    if(shootBtn && !shootBtn.__diag2){ shootBtn.addEventListener('click', function(){ diagRecompute2(); }); shootBtn.__diag2=true; }
    var idx=document.getElementById('indexInput');
    if(idx && !idx.__diag2){ idx.addEventListener('keydown', function(ev){ if(ev.key==='Enter'){ diagRecompute2(); } }); idx.__diag2=true; }
  });
})();

/* ====== Automatizmus 7 (összes szabad pont → hajópont) ====== */
function auto_7_fillAllShipPoints(force=false){
  

  if(!workP) return;
  const nMVP = (window.STATE && typeof window.STATE.nMVP === 'number') ? window.STATE.nMVP : 0;
  const nVP  = (window.STATE && typeof window.STATE.nVP  === 'number') ? window.STATE.nVP  : 0;
  if(!force && nMVP < nVP) return;

  
  var __oldCommit = (typeof window.__SHIP_COMMIT__ !== 'undefined') ? window.__SHIP_COMMIT__ : false;
  window.__SHIP_COMMIT__ = true;
  let changed = false;
  try{
    for(let r=0;r<N-1;r++){
      for(let c=0;c<N-1;c++){
        const v = workP[r]?.[c];
        
        if(v==='-'){
          workP[r][c] = 'H';
          changed = true;
        }
      }
    }
  } finally {
    window.__SHIP_COMMIT__ = __oldCommit;
  }

  if (changed){
    VALTOZAS = true;
  }

  recomputeGlobals();
  if(typeof diagRecompute2 === 'function') diagRecompute2();
}
/* ====== Automatizmus 8 (minden hajó kikötve → szabad partmezők vízzé) ====== */
function auto_8_shoreFreeToWater(){
  
  let applied = 0;
  const MR = SMY.M_REAL;
  const N  = MR.length;
  const SHIPS = 'ABGDH';
  const totalKH = KIKOTOTTHAJOKSZAMA;
  let t=0,b=0,l=0,r=0;
  for(let i=0;i<N;i++){
    const top = MR[0][i][0];
    const bot = MR[N-1][i][0];
    const left = MR[i][0][0];
    const right = MR[i][N-1][0];
    if(SHIPS.includes(top)) t++;
    if(SHIPS.includes(bot)) b++;
    if(SHIPS.includes(left)) l++;
    if(SHIPS.includes(right)) r++;
  }
  const curKH = t + b + l + r;
  if(curKH < totalKH){
    
    return 0;
  }
  // 1) partok feltöltése vízzel (csak a partvonalakon, sarok nélkül, M_REAL alapján)
  for(let c=1;c<=N-2;c++){
    if(MR[0][c][0] === '-'){ const cc = MR[0][c][1]+MR[0][c][2]; MR[0][c] = 'V'+cc; setCellWater(0,c,'V',cc); applied++; }
    if(MR[N-1][c][0] === '-'){ const cc = MR[N-1][c][1]+MR[N-1][c][2]; MR[N-1][c] = 'V'+cc; setCellWater(N-1,c,'V',cc); applied++; }
  }
  for(let r2=1;r2<=N-2;r2++){
    if(MR[r2][0][0] === '-'){ const cc = MR[r2][0][1]+MR[r2][0][2]; MR[r2][0] = 'V'+cc; setCellWater(r2,0,'V',cc); applied++; }
    if(MR[r2][N-1][0] === '-'){ const cc = MR[r2][N-1][1]+MR[r2][N-1][2]; MR[r2][N-1] = 'V'+cc; setCellWater(r2,N-1,'V',cc); applied++; }
  }
  // 2) parti hajómezők számlálása → SOROK/OSZL_REAL
  const SR = SMY.SOROK_REAL;
  const OR = SMY.OSZL_REAL;
  SR[0]     = (t===0 ? 'V' : (t===1 ? 'Z' : 'P'));
  SR[N-1]   = (b===0 ? 'V' : (b===1 ? 'Z' : 'P'));
  OR[0]     = (l===0 ? 'V' : (l===1 ? 'Z' : 'P'));
  OR[N-1]   = (r===0 ? 'V' : (r===1 ? 'Z' : 'P'));
  if (typeof recomputeGlobals === 'function') recomputeGlobals();
  if (typeof diagRecompute2 === 'function') diagRecompute2();
  
  
  return applied;
}

document.addEventListener('DOMContentLoaded', function(){
  const b7 = document.getElementById('btnAuto7Test');
  if (b7) b7.addEventListener('click', function(){
    auto_7_fillAllShipPoints(true);
    drawPointsOverlay();
    if (typeof diagRecompute2 === 'function') diagRecompute2();
  });

  const ball = document.getElementById('btnRunAllAutos');
  if (ball) ball.addEventListener('click', function(){
    if (typeof window.SMY_runAllAutosFixpoint18Last === 'function') {
      window.SMY_runAllAutosFixpoint18Last('BTN');
    } else if (typeof window.runAllAutosPass === 'function') {
      window.runAllAutosPass();
    }

    try {
      if (typeof window.__redrawSimpleStrict === 'function') {
        window.__redrawSimpleStrict();
      } else if (typeof window.redrawFromRealAll === 'function') {
        window.redrawFromRealAll();
      }
    } catch(_){
    }
  });
});


</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  var a7 = document.querySelector('#sw_auto7');
  if(a7) a7.checked = false;
});
</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  var a7 = document.getElementById('sw_auto7');
  if(a7){
    a7.checked = false;
    { a7.dispatchEvent(new Event('change', {bubbles:true})); }
  }
});
</script>
<script id="__fix10_35mm_header_update">
(function()
{
  
})();
</script>
<script id="__fix10_35mm_red16_header_update">
(function()
{
  
})();
</script>
<div id="homokozo_panel" style="position:absolute; background:white; border:1px solid #999; padding:4px; position:absolute; width:90mm; background:white; border:1px solid #999; padding:4px; position:absolute; left:57mm; top:110mm; width:90mm; background:white; border:1px solid #999; padding:4px; height:120mm;">
<div style="display:flex; flex-direction:column; align-items:center;gap:9px; padding:4px;">

<div style="display:flex;gap:12px; justify-content:center; align-items:center;;margin-left:10px;">
<div style="width:52px;height:52px;background:#ccc;position:relative;border:3px solid #333;">
<div style="position:absolute;left:50%;top:50%;width:60%;height:5px;background:#fff;transform:translate(-50%,-50%);"></div>
<div style="position:absolute;left:50%;top:50%;width:5px;height:60%;background:#fff;transform:translate(-50%,-50%);"></div>
</div>
<input placeholder="INDEX" style="width:60px;text-align:center;border:3px solid black;border-radius:8px;" type="text"/>
<button style="padding:5px 10px;">ELHELYEZ</button>
</div>

<div style="display:flex; justify-content:center;">
<div id="muhely_box" style="width:70px;height:70px;border:4px solid #000;background:#ccc;"></div>
</div>

<div style="display:flex;gap:9px; justify-content:center; flex-wrap:wrap;">
<button style="background:#003366;color:#fff;padding:8px 13px;">HAJÓ</button>
<button style="background:#003366;color:#fff;padding:8px 13px;">A</button>
<button style="background:#003366;color:#fff;padding:8px 13px;">B</button>
<button style="background:#003366;color:#fff;padding:8px 13px;">G</button>
<button style="background:#003366;color:#fff;padding:8px 13px;">D</button>
<button style="background:#a3d9ff;color:#000;padding:8px 13px;">VÍZ</button>
</div>

<div style="display:flex;gap:9px; justify-content:center;">
<div style="width:44px;height:44px;border:3px solid #333;position:relative;">
<div style="position:absolute;left:10%;top:50%;width:80%;height:6px;background:red;transform:translateY(-50%);"></div>
</div>
<div style="width:44px;height:44px;border:3px solid #333;position:relative;">
<div style="position:absolute;left:50%;top:10%;width:6px;height:80%;background:red;transform:translateX(-50%);"></div>
</div>
<div style="width:44px;height:44px;border:3px solid #333;position:relative;">
<div style="position:absolute;left:10%;top:50%;width:80%;height:6px;background:red;transform:translateY(-50%);"></div>
<div style="position:absolute;left:50%;top:10%;width:6px;height:80%;background:red;transform:translateX(-50%);"></div>
</div>
</div>

<div style="display:flex;gap:9px; justify-content:center;">
<div style="width:44px;height:44px;border:3px solid #333;position:relative;">
<div style="position:absolute;left:10%;top:50%;width:80%;height:6px;background:green;transform:translateY(-50%);"></div>
</div>
<div style="width:44px;height:44px;border:3px solid #333;position:relative;">
<div style="position:absolute;left:50%;top:10%;width:6px;height:80%;background:green;transform:translateX(-50%);"></div>
</div>
<div style="width:44px;height:44px;border:3px solid #333;position:relative;">
<div style="position:absolute;left:10%;top:50%;width:80%;height:6px;background:green;transform:translateY(-50%);"></div>
<div style="position:absolute;left:50%;top:10%;width:6px;height:80%;background:green;transform:translateX(-50%);"></div>
</div>
</div>

<div style="display:flex;gap:9px; justify-content:center;">
<div style="width:44px;height:44px;border:3px solid #333;position:relative;text-align:center;line-height:44px;font-weight:bold;">H
      <div style="position:absolute;top:2px;left:2px;width:10px;height:10px;background:black;border-radius:50%;"></div>
</div>
<div style="width:44px;height:44px;border:3px solid #333;position:relative;text-align:center;line-height:44px;font-weight:bold;">H
      <div style="position:absolute;top:2px;right:2px;width:10px;height:10px;background:black;border-radius:50%;"></div>
</div>
<div style="width:44px;height:44px;border:3px solid #333;position:relative;text-align:center;line-height:44px;font-weight:bold;">H
      <div style="position:absolute;bottom:2px;left:2px;width:10px;height:10px;background:black;border-radius:50%;"></div>
</div>
<div style="width:44px;height:44px;border:3px solid #333;position:relative;text-align:center;line-height:44px;font-weight:bold;">H
      <div style="position:absolute;bottom:2px;right:2px;width:10px;height:10px;background:black;border-radius:50%;"></div>
</div>
</div>

<div style="display:flex; justify-content:center;">
<div style="width:44px;height:44px;border:3px solid #333;position:relative;text-align:center;line-height:44px;font-weight:bold;background:#a3d9ff;">V<div style="position:absolute;bottom:2px;right:2px;width:10px;height:10px;background:#3399ff;border:2px solid blue;border-radius:50%;"></div></div>
</div>

<div style="margin-top:100mm; align-self:flex-end; display:flex; justify-content:flex-end; width:100%;">
  <label style="display:flex; align-items:center; gap:4px; margin:0; font-size:11px;">
    <input type="checkbox" id="muhely_ovatos_toggle" checked>
    ÓVATOS MŰHELY
  </label>
</div>
</div>
</div>
<script>
(function(){
  document.title = "SMYOZ Explorer v12.16" ;
  { var _h = document.getElementById('hdrTitle'); if(_h){ _h.textContent = "SMYOZ Explorer v12.16" ; } }

  function setupHomokozoMuhely(){
    var HK = document.getElementById('homokozo_panel');
    if(!HK) return;
    var container = HK.firstElementChild || HK;
    var rows = container && container.children ? container.children : [];
    var padRow = rows[1];
    if(!padRow) return;
    var pad = padRow.querySelector('div[style*="width:70px"][style*="height:70px"]');
    if(!pad) return;

    pad.style.display='flex'; pad.style.alignItems='center'; pad.style.justifyContent='center';
      pad.style.fontFamily='"Courier New",monospace'; pad.style.fontWeight='800'; pad.style.fontSize='16px';
      pad.style.overflow='hidden'; pad.style.whiteSpace='nowrap'; pad.style.userSelect='none';

    function writeMuhely(txt){ pad.textContent = String(txt||''); }

    
    var row1 = rows[0];
    if(row1){
      var resetSq = row1.querySelector('div[style*="width:52px"][style*="height:52px"]');
      if(resetSq){ resetSq.style.cursor='pointer'; resetSq.addEventListener('click', function(){ writeMuhely('RESET'); }); }
      var elhelyezBtn = row1.querySelector('button');
      if(elhelyezBtn){ elhelyezBtn.addEventListener('click', function(){ writeMuhely((elhelyezBtn.textContent||'').trim() || 'ELHELYEZ'); }); }
    }

    
    var row3 = rows[2];
    if(row3){
      row3.querySelectorAll('button').forEach(function(btn){
        btn.addEventListener('click', function(){ writeMuhely((btn.textContent||'').trim()); });
      });
    }

    
    var row4 = rows[3];
    if(row4){
      var labs = ['-','|','+'], i=0;
      row4.querySelectorAll('div[style*="width:44px"][style*="height:44px"]').forEach(function(sq){
        var lab = labs[i++] || '?'; sq.style.cursor='pointer'; sq.addEventListener('click', function(){ writeMuhely(lab); });
      });
    }

    
    var row5 = rows[4];
    if(row5){
      var labs2 = ['-','|','+'], j=0;
      row5.querySelectorAll('div[style*="width:44px"][style*="height:44px"]').forEach(function(sq){
        var lab = labs2[j++] || '?'; sq.style.cursor='pointer'; sq.addEventListener('click', function(){ writeMuhely(lab); });
      });
    }

    
    var row6 = rows[5];
    if(row6){
      var k=0;
      row6.querySelectorAll('div[style*="width:44px"][style*="height:44px"]').forEach(function(sq){
        var lab = 'H' + (++k); sq.style.cursor='pointer'; sq.addEventListener('click', function(){ writeMuhely(lab); });
      });
    }

    
    var row7 = rows[6];
    if(row7){
      var v = row7.querySelector('div[style*="width:44px"][style*="height:44px"]');
      if(v){ v.style.cursor='pointer'; v.addEventListener('click', function(){ writeMuhely('V'); }); }
    }
  }

  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', setupHomokozoMuhely); }
  else{ setupHomokozoMuhely(); }
})();
</script>

<script>
(function(){
  function pad(){ return document.getElementById('muhely_box'); }
  function ensurePadStyle(p){ if(!p) return; p.style.whiteSpace='pre-line'; p.style.textAlign='left'; p.style.padding='4px'; }
  function writeFirst(txt){
    var p = pad(); if(!p) return;
    ensurePadStyle(p);
    p.textContent = String(txt||'');
  }
  function writeTwo(first, second){
    var p = pad(); if(!p) return;
    ensurePadStyle(p);
    p.textContent = String(first||'') + '\n' + String(second||'');
  }
  function attach(){
    var HK = document.getElementById('homokozo_panel');
    if(!HK) return;
    var container = HK.firstElementChild || HK;
    var rows = container && container.children ? Array.prototype.slice.call(container.children) : [];
    
    var row1 = rows[0];
    if(row1){
      var kids = Array.prototype.slice.call(row1.children);
      var resetDiv = kids[0];
      var placeBtn = kids[2];
      if(resetDiv){
        resetDiv.addEventListener('click', function(){
          writeTwo('RESET', '[fn:RESET]');
          if(typeof fn_action==='function'){ fn_action('RESET'); }
        });
      }
      if(placeBtn){
        placeBtn.addEventListener('click', function(){
            {     var st = (typeof window!=='undefined'? window.__elh_state__ : 0);     var root = document.getElementById('homokozo_panel') || document;     var btns = root.getElementsByTagName('button');     var toggle=null; for(var i=0;i<btns.length;i++){ var t=(btns[i].textContent||'').trim().toUpperCase(); if(t==='FOLYTAT'||t==='ELVET'){ toggle=btns[i]; break; } }     var lab = toggle ? (toggle.textContent||'').trim().toUpperCase() : '';     if (st===0 && lab==='FOLYTAT'){ FOLYTATAS=false;  }   } writeTwo('ELHELYEZÉS', '[fn:ELHELYEZÉS]');
          if(typeof fn_action==='function'){ fn_action('ELHELYEZÉS'); }
        });
      }
    }
    
    var row3 = rows[2];
    if(row3){
      Array.prototype.slice.call(row3.querySelectorAll('button')).forEach(function(btn){
        btn.addEventListener('click', function(){
          var lab = (btn.textContent||'').trim();
          writeTwo(lab, '[fn:'+lab+']');
          if(typeof fn_action==='function'){ fn_action(lab); }
        });
      });
    }
    function attachSquares(row, labels){
      if(!row) return;
      var squares = Array.prototype.slice.call(row.children);
      squares.forEach(function(sq, idx){
        var lab = labels && labels[idx] ? labels[idx] : (row===rows[5] ? ('H'+(idx+1)) : (row===rows[6] ? 'V' : ''));
        if(!lab) return;
        sq.addEventListener('click', function(){
          writeTwo(lab, '[fn:'+lab+']');
          if(typeof fn_action==='function'){ fn_action(lab); }
        });
      });
    }
    
    attachSquares(rows[3], ['-','|','+']);
    
    attachSquares(rows[4], ['-','|','+']);
    
    attachSquares(rows[5], null);
    
    attachSquares(rows[6], null);
  }
  if(document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', attach); } else { attach(); }
})();
</script>
<script data-disabled="v6.44" type="text/disabled">

(function(){
  window.__HK_ROW = -1;
  window.__HK_CHILD_IDX = -1;
  function setupCapture(){
    var hk = document.getElementById('homokozo_panel');
    if(!hk) return;
    var container = hk.firstElementChild || hk;
    var rows = (container && container.children) ? Array.prototype.slice.call(container.children) : [];
    hk.addEventListener('click', function(ev){
      window.__HK_ROW = -1;
      window.__HK_CHILD_IDX = -1;
      var node = ev.target;
      var row = node;
      while(row && row.parentElement !== container){ row = row.parentElement; }
      if(!row) return;
      window.__HK_ROW = rows.indexOf(row);
      var child = node;
      while(child && child.parentElement !== row){ child = child.parentElement; }
      if(child){
        var arr = Array.prototype.slice.call(row.children);
        window.__HK_CHILD_IDX = arr.indexOf(child);
      }
    }, true);
  }
  var DARAB = '---';
  var SARKOK = '????';
  function applyMask(base, mask){
  
  {
    base = String(base||'');
    var __m_in = String(mask||'');
    if (base.length >= 3 && __m_in.length === 3){
      var __a = __m_in.split('');
      
      if ((__a[1]==='p' || __a[1]==='z') && base.charAt(1) === __a[1]) __a[1] = '-';
      if ((__a[2]==='p' || __a[2]==='z') && base.charAt(2) === __a[2]) __a[2] = '-';
      mask = __a.join('');
    }
    
    (function(){
      var panel = document.getElementById('probe_panel');
      if(!panel){
        panel = document.createElement('div');
        panel.id = 'probe_panel';
        panel.style.cssText = 'position:fixed;left:8px;top:8px;background:rgba(0,0,0,.85);color:#fff;font:12px/1.3 monospace;padding:8px;border-radius:8px;z-index:999999;max-width:60vw;';
        panel.innerHTML = '<div style="font-weight:bold;margin-bottom:4px">PROBE</div>'
                        + '<div id="probe_apply_eff"></div>';
         
      }
      var E=document.getElementById('probe_apply_eff');
      if(E){ E.textContent = 'applyMask: eff mask=\"' + String(mask) + '\"  base=\"' + String(base) + '\"'; }
    })();
  }

    var a = String(base||'').split('');
    var b = String(mask||'').split('');
    var n = Math.min(a.length, b.length);
    for(var i=0;i<n;i++){ if(b[i] !== '?') a[i] = b[i]; }
    return a.join('');
  }
  function codeHTML(s){
    return String(s||'').replace(/./g,function(ch){
      if(ch==='p') return '<span style="color:#c62828;font-weight:800">p</span>';
      if(ch==='z') return '<span style="color:#2e7d32;font-weight:800">z</span>';
      if(ch==='x') return '<span style="color:#f9a825;font-weight:800">x</span>';
      if(/[abgdvh]/i.test(ch)) return '<span style="color:#111;font-weight:800">'+ch.toUpperCase()+'</span>';
      if(ch==='-') return '<span style="color:#bbb">-</span>';
      if(ch==='?') return '<span style="color:#999">?</span>';
      return ch;
    });
  }

function writeMuhely3(line1, line2)
{
  return;               
  
}
var __orig_fn_action = window.fn_action;
  window.fn_action = function(param, p1, p2){
    try{
      var C = String(param||'').trim();
      var s1 = (p1==null?'':String(p1));
      var s2 = (p2==null?'':String(p2));
      var line2 = s1 + (s2 ? (' | ' + s2) : '');
      if (C.toUpperCase() === 'RESET') {
        DARAB = '---'; SARKOK = '????';
        writeMuhely3('RESET', '');
        return;
      }
      var mask = null;
      if (C === 'HAJÓ') mask = 'H??';
      else if (C === 'A') mask = 'A??';
      else if (C === 'B') mask = 'B??';
      else if (C === 'G') mask = 'G??';
      else if (C === 'D') mask = 'D??';
      else if (C === 'VÍZ') mask = 'V??';
      if (!mask && /^H[1-4]$/.test(C)) {
        var n = parseInt(C.slice(1), 10);
        mask = (n===1) ? 'H???' : (n===2) ? '?H??' : (n===3) ? '??H?' : '???H';
      }
      if (!mask && (C==='-' || C==='|' || C==='+')) {
        var idx = (C==='-') ? 0 : (C==='|') ? 1 : 2;
        if (window.__HK_ROW === 3) {
          mask = idx===0 ? '??p' : idx===1 ? '?p?' : '?pp';
        } else if (window.__HK_ROW === 4) {
          mask = idx===0 ? '??z' : idx===1 ? '?z?' : '?zz';
        }
      }
      if (!mask && (C === 'V' || C === 'vízpont' || C === 'VÍZPONT')) {
        if (window.__HK_ROW === 6) mask = '???V';
      }
      if (!mask && /^[A-ZV\-\?][pz\-\?]{2}$/.test(C)) mask = C;
      if (!mask && /^[H\?]{4}$/.test(C)) mask = C;
      if (!mask) { writeMuhely3(C, line2); return; }
      if (mask.length === 3) {
        var t = mask[0].toUpperCase();
        if (['H','A','B','G','D'].indexOf(t) >= 0) SARKOK = 'HHHH';
        if (t === 'V') SARKOK = '????';
        DARAB = applyMask(DARAB, mask);
        writeMuhely3(mask, line2);
        return;
      } else if (mask.length === 4) {
        SARKOK = applyMask(SARKOK, mask);
        writeMuhely3(mask, line2);
        return;
      }
      writeMuhely3(mask, line2);
    } catch (e) {
      writeMuhely3('ERR', String(e));
    }
  };
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', setupCapture);
  else setupCapture();
})();
</script>
<script>



(function(){
  
  if (typeof window.fn_action === 'function' && !window._legacy_fn_action) window._legacy_fn_action = window.fn_action;
  if (typeof window.writeMuhely === 'function' && !window._legacy_writeMuhely) window._legacy_writeMuhely = window.writeMuhely;
  if (typeof window.appendMuhely === 'function' && !window._legacy_appendMuhely) window._legacy_appendMuhely = window.appendMuhely;

  // Capture homokozó structure only for row/child indexing (no style changes)
  window.__HK_ROW = -1;
  window.__HK_CHILD_IDX = -1;
  function setupCapture(){
    var hk = document.getElementById('homokozo_panel');
    if(!hk) return;
    var container = hk.firstElementChild || hk;
    var rows = (container && container.children) ? Array.prototype.slice.call(container.children) : [];
    hk.addEventListener('click', function(ev){
      window.__HK_ROW = -1; window.__HK_CHILD_IDX = -1;
      var node = ev.target, row = node;
      while(row && row.parentElement !== container){ row = row.parentElement; }
      if(!row) return;
      window.__HK_ROW = rows.indexOf(row);
      var child = node;
      while(child && child.parentElement !== row){ child = child.parentElement; }
      if(child){
        var arr = Array.prototype.slice.call(row.children);
        window.__HK_CHILD_IDX = arr.indexOf(child);
      }
    }, true);
  }

  
  window.DARAB = (typeof window.DARAB === 'string') ? window.DARAB : '---';
  window.SARKOK = (typeof window.SARKOK === 'string') ? window.SARKOK : '????';

  function applyMask(base, mask){
  
  {
    base = String(base||'');
    var __m_in = String(mask||'');
    if (base.length >= 3 && __m_in.length === 3){
      var __a = __m_in.split('');
      
      if ((__a[1]==='p' || __a[1]==='z') && base.charAt(1) === __a[1]) __a[1] = '-';
      if ((__a[2]==='p' || __a[2]==='z') && base.charAt(2) === __a[2]) __a[2] = '-';
      mask = __a.join('');
    }
    
    (function(){
      var panel = document.getElementById('probe_panel');
      if(!panel){
        panel = document.createElement('div');
        panel.id = 'probe_panel';
        panel.style.cssText = 'position:fixed;left:8px;top:8px;background:rgba(0,0,0,.85);color:#fff;font:12px/1.3 monospace;padding:8px;border-radius:8px;z-index:999999;max-width:60vw;';
        panel.innerHTML = '<div style="font-weight:bold;margin-bottom:4px">PROBE</div>'
                        + '<div id="probe_apply_eff"></div>';
         
      }
      var E=document.getElementById('probe_apply_eff');
      if(E){ E.textContent = 'applyMask: eff mask=\"' + String(mask) + '\"  base=\"' + String(base) + '\"'; }
    })();
  }

    var a = String(base||'').split('');
    var b = String(mask||'').split('');
    var n = Math.min(a.length, b.length);
    for(var i=0;i<n;i++){ if(b[i] !== '?') a[i] = b[i]; }
    return a.join('');
  }
  function codeHTML(s){
    return String(s||'').replace(/./g,function(ch){
      if(ch==='p') return '<span style="font-weight:800;color:#c62828">p</span>';
      if(ch==='z') return '<span style="font-weight:800;color:#2e7d32">z</span>';
      if(ch==='x') return '<span style="font-weight:800;color:#f9a825">x</span>';
      if(/[abgdvh]/i.test(ch)) return '<span style="font-weight:800;color:#111">'+ch.toUpperCase()+'</span>';
      if(ch==='-') return '<span style="color:#bbb">-</span>';
      if(ch==='?') return '<span style="color:#999">?</span>';
      return ch;
    });
  }

  function writeMuhely3(line1, line2){
    
    var box = document.getElementById('muhely_box');
    if(!box) return;
    box.style.textAlign = 'left';
    box.style.display = 'block';
    box.style.whiteSpace = 'normal';
    box.innerHTML = '';
    var l1 = (line1 && String(line1).length) ? String(line1) : '&nbsp;';
    var l2 = (line2 && String(line2).trim().length) ? String(line2) : null;
    var l3 = codeHTML(window.DARAB) + ' &nbsp; ' + codeHTML(window.SARKOK);
    var html = '<div>'+ l1 +'</div>';
    if(l2){ html += '<div>'+ l2 +'</div>'; }
    html += '<div>'+ l3 +'</div>';
    box.innerHTML = html;
  }

  
  window.writeMuhely = function(s){ writeMuhely3(s || '', ''); };
  window.appendMuhely = function(s){ writeMuhely3(s || '', ''); };

  
  window.fn_action = function(param, p1, p2){
    try{
      var C = String(param||'').trim();
      var s1 = (p1==null?'':String(p1));
      var s2 = (p2==null?'':String(p2));
      var line2 = s1 + (s2 ? (' | ' + s2) : '');

      
      if (C.toUpperCase() === 'RESET') {
        window.DARAB = '---';
        window.SARKOK = '????';
        writeMuhely3('RESET', '');
        return;
      }

      var mask = null;

      
      if (C === 'HAJÓ') mask = 'H??';
      else if (C === 'A') mask = 'A??';
      else if (C === 'B') mask = 'B??';
      else if (C === 'G') mask = 'G??';
      else if (C === 'D') mask = 'D??';
      else if (C === 'VÍZ') mask = 'V??';

      
      if (!mask && /^H[1-4]$/.test(C)) {
        var n = parseInt(C.slice(1),10);
        mask = (n===1) ? 'H???' : (n===2) ? '?H??' : (n===3) ? '??H?' : '???H';
      }

      
      if (!mask && (C==='-' || C==='|' || C==='+')) {
        var idx = (C==='-') ? 0 : (C==='|') ? 1 : 2;
        if (window.__HK_ROW === 3) {
          mask = idx===0 ? '??p' : idx===1 ? '?p?' : '?pp';
        } else if (window.__HK_ROW === 4) {
          mask = idx===0 ? '??z' : idx===1 ? '?z?' : '?zz';
        }
      }

      
      if (!mask && (C === 'V' || C === 'vízpont' || C === 'VÍZPONT') && window.__HK_ROW === 6) {
        mask = '???V';
      }

      
      if (!mask && /^[A-ZV\-\?][pz\-\?]{2}$/.test(C)) mask = C;
      if (!mask && /^[H\?]{4}$/.test(C)) mask = C;

      if (!mask) { writeMuhely3(C, line2); return; }

      if (mask.length === 3) {
        var t = mask[0].toUpperCase();
        if (['H','A','B','G','D'].indexOf(t) >= 0) window.SARKOK = 'HHHH';
        if (t === 'V') window.SARKOK = '????';
        window.DARAB = applyMask(window.DARAB, mask);
        writeMuhely3(mask, line2);
        return;
      } else if (mask.length === 4) {
        window.SARKOK = applyMask(window.SARKOK, mask);
        writeMuhely3(mask, line2);
        return;
      }
      writeMuhely3(mask, line2);
    }catch(e){
      writeMuhely3('ERR', String(e));
    }
  };

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', setupCapture);
  else setupCapture();

  
  
})();
</script>
<script>

(function(){
  if (typeof window._muhelyCrossActive === 'undefined') window._muhelyCrossActive = false;

  function ensureHUD(){
    var hud = document.getElementById('muhely_debug_hud');
    if(!hud){
      hud = document.createElement('div');
      hud.id = 'muhely_debug_hud';
      hud.style.position = 'fixed';
      hud.style.top = '8px';
      hud.style.right = '8px';
      hud.style.maxWidth = '520px';
      hud.style.width = 'min(38vw, 520px)';
      hud.style.background = 'rgba(0,0,0,0.82)';
      hud.style.color = '#ffeb3b';
      hud.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      hud.style.fontSize = '12px';
      hud.style.lineHeight = '1.35';
      hud.style.padding = '10px 12px';
      hud.style.border = '1px solid rgba(255,255,255,0.2)';
      hud.style.borderRadius = '10px';
      hud.style.zIndex = '5000';
      hud.style.pointerEvents = 'auto';
      hud.style.boxShadow = '0 6px 24px rgba(0,0,0,0.4)';
      var title = document.createElement('div');
      title.textContent = 'MŰHELY – Debug HUD';
      title.style.fontWeight = '700';
      title.style.marginBottom = '6px';
      var pre = document.createElement('pre');
      pre.id = 'muhely_debug_pre';
      pre.style.margin = '0';
      pre.style.whiteSpace = 'pre-wrap';
      pre.style.color = '#ffeb3b';
      pre.style.tabSize = '4';
      var tip = document.createElement('div');
      tip.style.marginTop = '6px';
      tip.style.color = '#ccc';
      tip.style.fontSize = '11px';
      
      title.ondblclick = function(){ hud.style.display = 'none'; };
      hud.appendChild(title);
      hud.appendChild(pre);
      hud.appendChild(tip);
      (document.body || document.documentElement).appendChild(hud);
       
    }
    return hud;
  }
  function setHUD(text){
    var pre = document.getElementById('muhely_debug_pre');
    if(!pre){ ensureHUD(); pre = document.getElementById('muhely_debug_pre'); }
    if(!pre) return;
    pre.textContent = text;
  }
  function diffChars(oldStr, newStr){
    var out = [];
    var maxLen = Math.max(oldStr.length, newStr.length);
    for (var i=0;i<maxLen;i++){
      var a = oldStr[i] || '·', b = newStr[i] || '·';
      var mark = (a===b) ? ' ' : '*';
      out.push(mark + ' ' + (a||'·') + ' → ' + (b||'·'));
    }
    return out.join('\n');
  }
  function formatStateLine(label, value){
    return (label + ': ').padEnd(9,' ') + value;
  }

  function ensureHosts(){
    var box = document.getElementById('muhely_box');
    if(!box) return null;
    var cs = getComputedStyle(box);
    if (cs.position === 'static') box.style.position = 'relative';

    var bgHost = box.querySelector('#muhely_bg_host');
    if(!bgHost){
      bgHost = document.createElement('div');
      bgHost.id = 'muhely_bg_host';
      bgHost.style.position = 'absolute';
      bgHost.style.inset = '0';
      bgHost.style.pointerEvents = 'none';
      bgHost.style.zIndex = '10';
      box.appendChild(bgHost);
    }
    var bgSvg = bgHost.querySelector('#muhely_bg_svg');
    if(!bgSvg){
      bgSvg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      bgSvg.setAttribute('id','muhely_bg_svg');
      bgSvg.setAttribute('width','100%');
      bgSvg.setAttribute('height','100%');
      bgSvg.setAttribute('viewBox','0 0 100 100');
      bgSvg.style.display = 'block';
      bgSvg.style.position = 'absolute';
      bgSvg.style.top = '0'; bgSvg.style.left = '0';
      bgHost.appendChild(bgSvg);
    }

    var fgHost = box.querySelector('#muhely_fg_host');
    if(!fgHost){
      fgHost = document.createElement('div');
      fgHost.id = 'muhely_fg_host';
      fgHost.style.position = 'absolute';
      fgHost.style.inset = '0';
      fgHost.style.pointerEvents = 'none';
      fgHost.style.zIndex = '25';
      box.appendChild(fgHost);
    }
    var fgSvg = fgHost.querySelector('#muhely_fg_svg');
    if(!fgSvg){
      fgSvg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      fgSvg.setAttribute('id','muhely_fg_svg');
      fgSvg.setAttribute('width','100%');
      fgSvg.setAttribute('height','100%');
      fgSvg.setAttribute('viewBox','0 0 100 100');
      fgSvg.style.display = 'block';
      fgSvg.style.position = 'absolute';
      fgSvg.style.top = '0'; fgSvg.style.left = '0';
      fgHost.appendChild(fgSvg);
    }

    return {bgSvg:bgSvg, fgSvg:fgSvg};
  }

  var COL = { darkBlue:'#0b3d91', lightBlue:'#90caf9', grayBg:'#e0e0e0', red:'#c62828', green:'#2e7d32', amber:'#f9a825', ringBlue:'#1e88e5', black:'#000', white:'#fff', yellow:'#ffeb3b' };
  function line(svg,x1,y1,x2,y2,col,w){
    var el = document.createElementNS('http://www.w3.org/2000/svg','line');
    el.setAttribute('x1',x1); el.setAttribute('y1',y1);
    el.setAttribute('x2',x2); el.setAttribute('y2',y2);
    el.setAttribute('stroke',col); el.setAttribute('stroke-width',w);
    el.setAttribute('stroke-linecap','round');
    svg.appendChild(el);
  }
  function circle(svg,cx,cy,r,col,w,fill){
    var el = document.createElementNS('http://www.w3.org/2000/svg','circle');
    el.setAttribute('cx',cx); el.setAttribute('cy',cy); el.setAttribute('r',r);
    el.setAttribute('fill', fill || 'none');
    el.setAttribute('stroke',col); el.setAttribute('stroke-width',w);
    svg.appendChild(el);
  }
  function rect(svg,x,y,w,h,fill){
    var el = document.createElementNS('http://www.w3.org/2000/svg','rect');
    el.setAttribute('x',x); el.setAttribute('y',y);
    el.setAttribute('width',w); el.setAttribute('height',h);
    el.setAttribute('fill', fill);
    svg.appendChild(el);
  }
  function text(svg, txt, x, y, fill, size){
    var el = document.createElementNS('http://www.w3.org/2000/svg','text');
    el.setAttribute('x', x); el.setAttribute('y', y);
    el.setAttribute('fill', fill || '#000');
    el.setAttribute('font-size', size || '36');
    el.setAttribute('font-weight', '800');
    el.setAttribute('text-anchor', 'middle');
    el.setAttribute('dominant-baseline', 'middle');
    el.textContent = txt;
    svg.appendChild(el);
  }

  function drawBackgroundAndCross(bgSvg, tChar, S){
    var t=(tChar||'-').toUpperCase();
    var fill=COL.grayBg;
    if('HABGD'.indexOf(t)>=0) fill=COL.darkBlue;
    else if(t==='V') fill=COL.lightBlue;
    if(S && S[3]==='V') fill=COL.lightBlue;
    var m=12; rect(bgSvg, m, m, 100-2*m, 100-2*m, fill);
    if (window._muhelyCrossActive){
      line(bgSvg, 12, 50, 88, 50, COL.white, 7);
      line(bgSvg, 50, 12, 50, 88, COL.white, 7);
    }
  }
  function drawForeground(fgSvg, D, S){
    var c2=D[1]||'-', c3=D[2]||'-', mid=50, pad=14, w=8;
    if(c2==='p'||c2==='z'||c2==='x'){ line(fgSvg,mid,pad,mid,100-pad,c2==='p'?COL.red:c2==='z'?COL.green:COL.amber,w); }
    if(c3==='p'||c3==='z'||c3==='x'){ line(fgSvg,pad,mid,100-pad,mid,c3==='p'?COL.red:c3==='z'?COL.green:COL.amber,w); }
    var m=10, r=9;
    if(S[0]==='H') circle(fgSvg,m,m,r,COL.black,2,COL.black);
    if(S[1]==='H') circle(fgSvg,100-m,m,r,COL.black,2,COL.black);
    if(S[2]==='H') circle(fgSvg,m,100-m,r,COL.black,2,COL.black);
    if(S[3]==='H') circle(fgSvg,100-m,100-m,r,COL.black,2,COL.black);
    if(S[3]==='V') circle(fgSvg,84,84,8,COL.ringBlue,4,'none');
    var t=(D[0]||'-').toUpperCase();
    if('HABGD'.indexOf(t)>=0){ text(fgSvg, t, 50, 52, COL.yellow, 34); }
  }

  function renderOverlay(){
    var hosts = ensureHosts(); if(!hosts) return;
    var bgSvg = hosts.bgSvg, fgSvg = hosts.fgSvg;
    while(bgSvg.firstChild) bgSvg.removeChild(bgSvg.firstChild);
    while(fgSvg.firstChild) fgSvg.removeChild(fgSvg.firstChild);
    var D = String(window.DARAB || '---');
    var S = String(window.SARKOK || '????');
    drawBackgroundAndCross(bgSvg, D[0]||'-', S);
    drawForeground(fgSvg, D, S);
  }

  function hideMuhelyText(){
    var box = document.getElementById('muhely_box'); if(!box) return;
    var wrap = box.firstElementChild;
    if (wrap){
      wrap.style.display = 'none';
      wrap.style.visibility = 'hidden';
      wrap.style.pointerEvents = 'none';
    }
  }

  function enforceWaterConsistency(){
    {
      var S = String(window.SARKOK || '????');
      var D = String(window.DARAB || '---');
      if (S[3] === 'V' && (D[0]||'-') !== 'V'){
        window.DARAB = 'V' + (D[1]||'-') + (D[2]||'-');
      }
    }
  }

  var prev = window.fn_action;
  window.fn_action = function(a,b,c){
    // ensureHUD();
    var beforeD = String(window.DARAB || '---');
    var beforeS = String(window.SARKOK || '????');
    var action = (a!==undefined) ? JSON.stringify(a) : '(n/a)';
    if (String(a||'').toUpperCase() === 'RESET') window._muhelyCrossActive = true;

    var r;
    if (typeof prev === 'function') r = prev.apply(this, arguments);
    var t = (String(window.DARAB||'---')[0] || '-').toUpperCase();
      if ('HABGD'.indexOf(t) >= 0) window._muhelyCrossActive = false; 

      enforceWaterConsistency();
      hideMuhelyText();
      renderOverlay();

      var afterD = String(window.DARAB || '---');
      var afterS = String(window.SARKOK || '????');
      var txt = '';
      txt += formatStateLine('ACTION', action) + '\n';
      txt += formatStateLine('DARAB',  afterD) + '    (előtte: ' + beforeD + ')\n';
      txt += diffChars(beforeD, afterD) + '\n\n';
      txt += formatStateLine('SARKOK', afterS) + '    (előtte: ' + beforeS + ')\n';
      txt += diffChars(beforeS, afterS) + '\n';
      // setHUD(txt);
    return r;
  };

  function init(){
    // ensureHUD();
      hideMuhelyText();
      enforceWaterConsistency();
      renderOverlay();
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init); else init();
  window.addEventListener('resize', function(){ renderOverlay(); });
})();
</script>
<script>

(function(){
  function $(sel){ return document.querySelector(sel); }
  function ensureHosts(){
    var box = $('#muhely_box'); if(!box) return null;
    var cs = getComputedStyle(box);
    if (cs.position === 'static') box.style.position = 'relative';
    var bgHost = box.querySelector('#muhely_bg_host');
    if(!bgHost){
      bgHost = document.createElement('div');
      bgHost.id = 'muhely_bg_host';
      Object.assign(bgHost.style,{position:'absolute',inset:'0',pointerEvents:'none',zIndex:'10'});
      box.appendChild(bgHost);
    }
    var bg = bgHost.querySelector('svg#muhely_bg_svg');
    if(!bg){
      bg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      bg.setAttribute('id','muhely_bg_svg');
      bg.setAttribute('width','100%'); bg.setAttribute('height','100%'); bg.setAttribute('viewBox','0 0 100 100');
      Object.assign(bg.style,{position:'absolute',top:'0',left:'0',display:'block'});
      bgHost.appendChild(bg);
    }
    var fgHost = box.querySelector('#muhely_fg_host');
    if(!fgHost){
      fgHost = document.createElement('div');
      fgHost.id = 'muhely_fg_host';
      Object.assign(fgHost.style,{position:'absolute',inset:'0',pointerEvents:'none',zIndex:'25'});
      box.appendChild(fgHost);
    }
    var fg = fgHost.querySelector('svg#muhely_fg_svg');
    if(!fg){
      fg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      fg.setAttribute('id','muhely_fg_svg');
      fg.setAttribute('width','100%'); fg.setAttribute('height','100%'); fg.setAttribute('viewBox','0 0 100 100');
      Object.assign(fg.style,{position:'absolute',top:'0',left:'0',display:'block'});
      fgHost.appendChild(fg);
    }
    return {box:bgHost.parentNode, bg, fg};
  }
  var COL = { darkBlue:'#0b3d91', lightBlue:'#90caf9', gray:'#e0e0e0', red:'#c62828', green:'#2e7d32', amber:'#f9a825', ring:'#1e88e5', black:'#000', white:'#fff', yellow:'#ffeb3b' };
  function line(svg,x1,y1,x2,y2,col,w){ var el=document.createElementNS('http://www.w3.org/2000/svg','line'); el.setAttribute('x1',x1); el.setAttribute('y1',y1); el.setAttribute('x2',x2); el.setAttribute('y2',y2); el.setAttribute('stroke',col); el.setAttribute('stroke-width',w); el.setAttribute('stroke-linecap','round'); svg.appendChild(el); }
  function circle(svg,cx,cy,r,col,w,fill){ var el=document.createElementNS('http://www.w3.org/2000/svg','circle'); el.setAttribute('cx',cx); el.setAttribute('cy',cy); el.setAttribute('r',r); el.setAttribute('fill',fill||'none'); el.setAttribute('stroke',col); el.setAttribute('stroke-width',w); svg.appendChild(el); }
  function rect(svg,x,y,w,h,fill){ var el=document.createElementNS('http://www.w3.org/2000/svg','rect'); el.setAttribute('x',x); el.setAttribute('y',y); el.setAttribute('width',w); el.setAttribute('height',h); el.setAttribute('fill',fill); svg.appendChild(el); }
  function text(svg, s, x, y, fill, size){ var el=document.createElementNS('http://www.w3.org/2000/svg','text'); el.setAttribute('x',x); el.setAttribute('y',y); el.setAttribute('fill',fill||'#000'); el.setAttribute('font-size', size||'34'); el.setAttribute('font-weight','800'); el.setAttribute('text-anchor','middle'); el.setAttribute('dominant-baseline','middle'); el.textContent = s; svg.appendChild(el); }

  function hideInnerTexts(){
    var box = $('#muhely_box'); if(!box) return;
    var kids = box.children;
    for(var i=0;i<kids.length;i++){
      var el = kids[i];
      if(el.id==='muhely_bg_host' || el.id==='muhely_fg_host') continue;
      el.style.display='none'; el.style.visibility='hidden'; el.style.pointerEvents='none';
    }
  }
  function observeMuhely(){
    var box = $('#muhely_box'); if(!box || box._obsAttached) return;
    var obs = new MutationObserver(function(){ hideInnerTexts(); });
    obs.observe(box, {childList:true, subtree:false}); box._obsAttached = true;
  }
  function enforceWaterConsistency(){
    {
      var S = String(window.SARKOK || '????');
      var D = String(window.DARAB || '---');
      if (S[3]==='V' && (D[0]||'-')!=='V'){ window.DARAB = 'V' + (D[1]||'-') + (D[2]||'-'); }
    }
  }
  function draw()
  {
        
    var hosts = ensureHosts(); if(!hosts) return;
    var bg=hosts.bg, fg=hosts.fg;
    while(bg.firstChild) bg.removeChild(bg.firstChild);
    while(fg.firstChild) fg.removeChild(fg.firstChild);
    var D = String(window.DARAB || '---'); var S = String(window.SARKOK || '????');
    var t = (D[0]||'-').toUpperCase();
    var fill = COL.gray; if('HABGD'.indexOf(t)>=0) fill = COL.darkBlue; else if(t==='V') fill = COL.lightBlue;
    if(S[3]==='V') fill = COL.lightBlue;
    var m=12; rect(bg, m,m, 100-2*m, 100-2*m, fill);
    var v = (D[1]||'-').toLowerCase(), h = (D[2]||'-').toLowerCase();
    var mid=50, pad=14, w=8;
    var colV = v==='p'?COL.red : v==='z'?COL.green : v==='x'?COL.amber : v==='-'?COL.white : null;
    var colH = h==='p'?COL.red : h==='z'?COL.green : h==='x'?COL.amber : h==='-'?COL.white : null;
    if(colV) line(fg, mid, pad, mid, 100-pad, colV, w);
    if(colH) line(fg, pad, mid, 100-pad, mid, colH, w);
    var r=9, sM=10;
    if(S[0]==='H') circle(fg,sM,sM,r,COL.black,2,COL.black);
    if(S[1]==='H') circle(fg,100-sM,sM,r,COL.black,2,COL.black);
    if(S[2]==='H') circle(fg,sM,100-sM,r,COL.black,2,COL.black);
    if(S[3]==='H') circle(fg,100-sM,100-sM,r,COL.black,2,COL.black);
    if(S[3]==='V') circle(fg,84,84,8,COL.ring,4,'none');
    if('HABGD'.indexOf(t)>=0){ text(fg, t, 50, 52, COL.yellow, 52); } 
  }
  var prev = window.fn_action;
  window.fn_action = function(){ var r; if(typeof prev==='function') r = prev.apply(this, arguments); enforceWaterConsistency(); hideInnerTexts(); observeMuhely(); draw(); return r; };
  function init(){ enforceWaterConsistency(); hideInnerTexts(); observeMuhely(); draw(); }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init); else init();
  window.addEventListener('resize', function(){ draw(); });
})();
</script>
<script>

(function(){
  
  window.DARAB = window.DARAB || '---';
  window.SARKOK = window.SARKOK || '????';
  window.aktSor = window.aktSor || 0;
  window.aktOszlop = window.aktOszlop || 0;

  function el(id){ return document.getElementById(id); }
  function getD(){ var d=String(window.DARAB||'---'); return (d+'---').slice(0,3); }
  function getS(){ var s=String(window.SARKOK||'????'); return (s+'????').slice(0,4); }

  
  function colorClass(ch){ return ch==='p'?'red': ch==='z'?'green': ch==='x'?'yellow': null; }
  function drawMuhely()
  {
  
    var box=el('muhely_box'); if(!box) return;
    var d=getD(), s=getS();
    var ov=box.querySelector('.overlay'); if(!ov){ ov=document.createElement('div'); ov.className='overlay'; box.appendChild(ov); }
    ov.innerHTML='';
	
    if((d[0]||'').toUpperCase()==='H'){ var fill=document.createElement('div'); fill.className='shipfill'; ov.appendChild(fill); }
    var vcol=colorClass(d[1]); if(vcol){ var v=document.createElement('div'); v.className='seg v '+vcol; ov.appendChild(v); }
    var hcol=colorClass(d[2]); if(hcol){ var h=document.createElement('div'); h.className='seg h '+hcol; ov.appendChild(h); }
    var map={0:'c-tl',1:'c-bl',2:'c-tr',3:'c-br'};
    for(var i=0;i<4;i++){ if((s[i]||'?')==='V'){ var dot=document.createElement('div'); dot.className='corner '+map[i]; ov.appendChild(dot); } }
  }

  
  var base_fn = window.fn_action;
  window.fn_action = function(mask)
  {
    var out = (typeof base_fn==='function') ? base_fn.apply(this, arguments) : undefined;
 
  
   
  
  
  
  
  
    drawMuhely();
    return out;
  };

  
  function applyColorToggle(color, dir){
    var d=getD();
    
    function toggleMask(idx){
      var cur=d[idx];
      var n=(cur===color)?'-':color;
      if(idx===1) return '?'+n+'?';
      if(idx===2) return '??'+n;
      return '???';
    }
    
    if(dir==='V'||dir==='BOTH'){
      var mask=toggleMask(1);
      if(typeof base_fn==='function') base_fn.call(window,mask);
    }
    if(dir==='H'||dir==='BOTH'){
      var mask=toggleMask(2);
      if(typeof base_fn==='function') base_fn.call(window,mask);
    }
    drawMuhely();
  }

  // ---- Eseménybekötés HOMOKOZÓ 4–5. sorhoz ----
  function hookRows(){
    var panel=el('homokozo_panel'); if(!panel) return;
    var rows=Array.prototype.slice.call(panel.children);
    var r4=rows[3]; var r5=rows[4];
    if(r4 && !r4.__v650){
      var c=Array.prototype.slice.call(r4.children);
      if(c[0]) c[0].addEventListener('click',()=>setTimeout(()=>applyColorToggle('p','H'),10),true);
      if(c[1]) c[1].addEventListener('click',()=>setTimeout(()=>applyColorToggle('p','V'),10),true);
      if(c[2]) c[2].addEventListener('click',()=>setTimeout(()=>applyColorToggle('p','BOTH'),10),true);
      r4.__v650=true;
    }
    if(r5 && !r5.__v650){
      var c2=Array.prototype.slice.call(r5.children);
      if(c2[0]) c2[0].addEventListener('click',()=>setTimeout(()=>applyColorToggle('z','H'),10),true);
      if(c2[1]) c2[1].addEventListener('click',()=>setTimeout(()=>applyColorToggle('z','V'),10),true);
      if(c2[2]) c2[2].addEventListener('click',()=>setTimeout(()=>applyColorToggle('z','BOTH'),10),true);
      r5.__v650=true;
    }
  }

  
  
  function setupDokuToggle(){
    var cb = document.getElementById('dokuToggle');
    if(!cb) return;

    var key = 'SMYOZ_DOKU_MODE';
    var p = (new URLSearchParams(window.location.search)).get('doku');
    var on = (p === '1') ? true : (p === '0') ? false : ((localStorage.getItem(key) === '1') || (String(window.location.hash || '').toLowerCase().indexOf('doku') >= 0));

    cb.checked = !!on;
    var topBlocks = document.getElementById('topBlocks');
    if(topBlocks){ topBlocks.classList.toggle('doku-on', cb.checked); }

    cb.addEventListener('change', function(){
      var topBlocks = document.getElementById('topBlocks');
    if(topBlocks){ topBlocks.classList.toggle('doku-on', cb.checked); }
      localStorage.setItem(key, cb.checked ? '1' : '0');
    });
  }


  function bumpTitle(){
    document.title = "SMYOZ Explorer v12.16"   ;
    var h=document.getElementById('hdrTitle'); if(h) h.textContent='SMYOZ Explorer v12.16' ;
  }

  function init(){ hookRows(); drawMuhely(); setupDokuToggle(); bumpTitle(); }
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded',init); else init();
})();
</script>
<style>

#muhely_box .overlay{position:absolute;inset:0;pointer-events:none;z-index:10;}
#muhely_box .shipfill{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
width:78%;height:78%;background:#0b2a5b;border-radius:4px;z-index:9;}
#muhely_box .seg{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);}
#muhely_box .seg.h{height:2px;width:80%;background:currentColor;}
#muhely_box .seg.v{width:2px;height:80%;background:currentColor;}
#muhely_box .seg.red{color:#c00;}
#muhely_box .seg.green{color:#0a0;}
#muhely_box .seg.yellow{color:#cc0;}
#muhely_box .corner{width:6px;height:6px;background:#000;border-radius:50%;position:absolute;z-index:11;}
#muhely_box .c-tl{left:6%;top:6%;}#muhely_box .c-tr{right:6%;top:6%;}
#muhely_box .c-bl{left:6%;bottom:6%;}#muhely_box .c-br{right:6%;bottom:6%;}
</style>


<script>
(function(){
  try{
    const TOP_ID = "tesztTop";
    function getTop(){ return document.getElementById(TOP_ID); }
    function showIndex(val, ok=true)
	{
      const el = getTop(); if(!el) return;
      
      
    }
    function validIndex(v){ return /^[1-9]{2}$/.test(String(v||"").trim()); }

    // Try to locate the HOMOKOZÓ INDEX input by common patterns
    function findIndexInput(){
      const candidates = [
        "#INDEX", "#index", "#indexInput", "input[name=INDEX]", "input[name=index]",
        "input[placeholder*=INDEX i]", "input[placeholder*=INDEX]", "input[id*=INDEX i]", "input[id*=INDEX]"
      ];
      for(const sel of candidates){
        { const el = document.querySelector(sel); if(el) return el; }
      }
      // Fallback: any input with maxlength 2 near label containing 'INDEX'
      const inputs = Array.from(document.querySelectorAll("input[maxlength='2'],input[maxlength='02'],input[type='text']"));
      for(const el of inputs){
        const lbl = el.closest("label") || el.labels && el.labels[0];
        const txt = (lbl ? lbl.textContent : "") || "";
        if(/INDEX/i.test(txt)) return el;
      }
      return null;
    }

    const idxInput = findIndexInput();
    if(idxInput){
      idxInput.addEventListener("input", function(){
        const v = (idxInput.value||"").trim();
        if(validIndex(v)) showIndex(v, true); else showIndex("", false);
      });
    }

    // Listen clicks on the board: try to infer cell index (either data attributes or innerText like '48')
    document.addEventListener("click", function(ev){
      const t = ev.target;
      if(!t) return;
      // Try data attributes r/c
      let r = t.getAttribute && t.getAttribute("data-r");
      let c = t.getAttribute && t.getAttribute("data-c");
      if(r && c){
        const idx = String(Number(c)+1) + String(Number(r)+1);
        if(validIndex(idx)){
          if(idxInput) idxInput.value = idx;
          showIndex(idx, true);
          return;
        }
      }
      
      const txt = (t.textContent||"").trim();
      if(/^[1-9]{2}$/.test(txt)){
        if(idxInput) idxInput.value = txt;
        showIndex(txt, true);
        return;
      }
      
      const cell = t.closest && t.closest("[data-r][data-c]");
      if(cell){
        r = cell.getAttribute("data-r"); c = cell.getAttribute("data-c");
        if(r!==null && c!==null){
          const idx = String(Number(c)+1) + String(Number(r)+1);
          if(validIndex(idx)){
            if(idxInput) idxInput.value = idx;
            showIndex(idx, true);
          }
        }
      }
    }, true);

    
    showIndex("–", true);
  }catch(e){
  }
})();
</script>

<script>
(function(){
  {
    function validIndex(v){ return /^[1-9]{2}$/.test(String(v||'').trim()); }
    
    function showTop(val, ok){
	  
    }
    // bind to HOMOKOZÓ INDEX (placeholder='INDEX' inside #homokozo_panel)
    function bindHomokozoIndex(){
      const hk = document.querySelector('#homokozo_panel');
      if(!hk) return;
      const inp = hk.querySelector('input[placeholder=\"INDEX\"]');
      if(!inp) return;
      if(inp.__idxBound) return;
      inp.__idxBound = true;
      inp.addEventListener('input', function(){
        const v = (inp.value||'').trim();
        if(validIndex(v)) showTop(v, true); else showTop('', false);
      });
      
      inp.addEventListener('focus', function(){ inp.select(); });
    }
    
    if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', bindHomokozoIndex);
    else bindHomokozoIndex();
    // Retry later in case HOMOKOZÓ panel is constructed dynamically
    setTimeout(bindHomokozoIndex, 300);
    setTimeout(bindHomokozoIndex, 1000);
  }
})();
</script>

<script>
(function(){
  {
    function getTop(){ return document.getElementById('tesztTop'); }
    function setTop(text, color){ var el=getTop(); if(!el) return; 
	el.textContent=text; if(color) el.style.color=color; }
    function validIndex(v){ return /^[1-9]{2}$/.test(String(v||'').trim()); }

    function bindAllIndexInputs(){
      var seen = new WeakSet();
      function bind(el){
        if(!el || seen.has(el)) return;
        seen.add(el);
        el.addEventListener('input', function(){
          var v = (el.value||'').trim();
          if(validIndex(v)) setTop('INDEX: '+v, '#ff0'); else setTop('Hibás INDEX', '#f88');
        });
      }
      var list = Array.from(document.querySelectorAll("input,textarea"));
      list.forEach(function(el){
        var id = (el.id||'').toLowerCase();
        var name = (el.name||'').toLowerCase();
        var ph = (el.getAttribute('placeholder')||'').toLowerCase();
        var ar = (el.getAttribute('aria-label')||'').toLowerCase();
        if(id.includes('index') || name.includes('index') || ph.includes('index') || ar.includes('index')){
          bind(el);
        }
      });
    }
    if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', bindAllIndexInputs);
    else bindAllIndexInputs();
    setTimeout(bindAllIndexInputs, 300);
    setTimeout(bindAllIndexInputs, 1000);

    var overlay = document.getElementById('placeOverlay');
    function showOverlayForElement(el, color){
      if(!el || !overlay) return;
      var r = el.getBoundingClientRect();
      var inset = Math.max(2, Math.floor(Math.min(r.width, r.height) * 0.08));
      overlay.style.left = (r.left + inset) + 'px';
      overlay.style.top = (r.top + inset) + 'px';
      overlay.style.width = Math.max(2, (r.width - 2*inset)) + 'px';
      overlay.style.height = Math.max(2, (r.height - 2*inset)) + 'px';
      overlay.style.display = 'block';
      overlay.style.borderColor = (color==='green' ? '#0f0' : color==='red' ? '#f33' : '#ff9800');
      overlay.style.boxShadow = (color==='green'
         ? '0 0 0 2px rgba(0,255,0,.30) inset'
         : color==='red'
         ? '0 0 0 2px rgba(255,0,0,.30) inset'
         : '0 0 0 2px rgba(255,152,0,.40) inset');
    }
function hideOverlay(){ if(overlay) overlay.style.display = 'none'; }

    function currentIndex(){
      var tb = getTop(); if(tb){ var m = tb.textContent.match(/INDEX:\s*([1-9]{2})/); if(m) return m[1]; }
      var any = document.querySelector("input#INDEX, input#index, input[name=INDEX], input[name=index]");
      if(any){ var v = (any.value||'').trim(); if(validIndex(v)) return v; }
      return null;
    }

    var state = { phase:0, idx:null };

    function cellFromIndex(idx){
      var rr = Number(idx[1]) - 1, cc = Number(idx[0]) - 1;
      var list = document.querySelectorAll('[data-r][data-c]');
      for (var i=0;i<list.length;i++){
        var el = list[i], r = Number(el.getAttribute('data-r')), c = Number(el.getAttribute('data-c'));
        if(r===rr && c===cc) return el;
      }
      var all = document.querySelectorAll('*');
      for (var j=0;j<all.length;j++){
        var t = (all[j].textContent||'').trim();
        if(t===idx) return all[j];
      }
      return null;
    }

    function handleElhelyezes()
	{
      if (window.__ensureWorkM__) window.__ensureWorkM__();
      var idx = currentIndex();
      if(!idx){ setTop('Hibás INDEX', '#f88'); hideOverlay(); state.phase=0; state.idx=null; return; }
      var el = cellFromIndex(idx);
      if(!el){ setTop('INDEX: '+idx+' - célmező nem található', '#f88'); hideOverlay(); state.phase=0; state.idx=null; return; }

      if(state.phase===0){ state.phase=1; state.idx=idx; showOverlayForElement(el,'yellow'); setTop('INDEX: '+idx+' - ELHELYEZÉS fázis: 1 (sárga)'); return; }
      if(state.phase===1){ state.phase=2; showOverlayForElement(el,'green'); setTop('INDEX: '+idx+' - ELHELYEZÉS fázis: 2 (zöld)'); return; }
      if(state.phase===2){ state.phase=0; state.idx=null; hideOverlay(); setTop('INDEX: '+idx+' - ELHELYEZÉS lezárva (0)'); return; }
    }

    document.addEventListener('click', function(e)
	{
      var t = e.target && (e.target.closest && e.target.closest('button')) || e.target;
      if(!t) return;
      var txt = (t.textContent||'').toUpperCase();
      if (txt.includes('ELHELYEZÉS') || txt.includes('ELHELYEZ') || txt.includes('ELHELY')){
        handleElhelyezes();
      }
    }, true);

  }
})();
</script>

<script>
(function(){
  "use strict";
  if(window.__f511_patched__) return;
  window.__f511_patched__ = true;

  function $(sel, root){ return (root||document).querySelector(sel); }
  function byText(root, tag, needle){
    needle = String(needle||'').toUpperCase();
    var list = (root||document).getElementsByTagName(tag);
    for(var i=0;i<list.length;i++){
      var t = (list[i].textContent||'').trim().toUpperCase();
      if(t.indexOf(needle) !== -1) return list[i];
    }
    return null;
  }
  function digitsOnly(s){
    var out = "", i=0, c="";
    s = String(s||"");
    for(i=0;i<s.length;i++){
      c = s.charAt(i);
      if(c >= "0" && c <= "9") out += c;
    }
    return out;
  }

  function bindIndexBehavior(inp){
    if(!inp || inp.__f511) return;
    inp.addEventListener('keydown', function(ev){
      var k = ev.key || "";
      if(k==="Backspace"||k==="Delete"||k==="Tab"||k==="Home"||k==="End"||(k.indexOf("Arrow")===0)) return;
      if(!(k >= "0" && k <= "9")) ev.preventDefault();
    }, true);
    inp.addEventListener('input', function(){
      var v = digitsOnly(inp.value);
      if(v.indexOf("0") !== -1){ v = ""; }     
      else if(v.length >= 3){ v = v.slice(-2); } 
      inp.value = v.slice(0,2);
      if(window.__elh_state__>0){ drawRingFromCurrentIndex(); }
      
    }, true);
    inp.__f511 = true;
  }

  var grid = $("#grid");
  var topIndex = $("#indexInput");  
  var hkPanel = $("#homokozo_panel");
  var hkIndex = null, placeBtn = null, resetSq = null, overlay = $("#placeOverlay");

  (function locateHomokozo(){
    if(!hkPanel) return;
    var cont = hkPanel.firstElementChild || hkPanel;
    var rows = cont && cont.children ? cont.children : [];
    // Row1: [RESET square] [INPUT] [ELHELYEZ]
    var row1 = rows[0];
    if(row1){
      var ch = row1.children || [];
      resetSq = ch[0] || null;
      if(resetSq && !resetSq.id) resetSq.id='hk_reset';
      if (resetSq) { resetSq.style.position='absolute'; resetSq.style.top='8px'; 
	  resetSq.style.left='16px'; resetSq.style.minWidth='60px'; }
      // index input (2nd child) - ensure it's text input
      hkIndex = row1.querySelector('input[type="text"]') || ch[1] || null;
      if(hkIndex && !hkIndex.id) hkIndex.id='hk_index';
      if (hkIndex) { hkIndex.style.position='absolute'; hkIndex.style.top='18px'; 
	  hkIndex.style.left='84px'; hkIndex.style.width='60px'; }
      
      placeBtn = byText(row1, 'button', 'ELHELYEZ') || ch[2] || null;
      if(placeBtn && !placeBtn.id) placeBtn.id='hk_elhelyez';
      if (placeBtn) { placeBtn.style.position='absolute'; placeBtn.style.top='20px'; 
	  placeBtn.style.left='152px'; placeBtn.style.minWidth='70px'; }
    }
  })();

  // ELVET button (next to homokozó index)
  var elvetBtn = null;     
  function ensureElvetBtn()
  {
    if(elvetBtn) return elvetBtn;
    var host = hkIndex && hkIndex.parentNode ? hkIndex.parentNode : null;
    if(!host) return false;   
    elvetBtn = document.createElement('button');
    elvetBtn.id = 'hk_toggle'; elvetBtn.textContent = 'ELVET';
      if (elvetBtn) { elvetBtn.style.position='absolute'; elvetBtn.style.top='20px'; 
	  elvetBtn.style.left='246px'; elvetBtn.style.minWidth='70px'; elvetBtn.style.whiteSpace='nowrap'; }
    elvetBtn.style.padding = '5px 10px';
    elvetBtn.style.borderRadius = '8px';
    elvetBtn.style.background = '#ffeeee';
    elvetBtn.style.border = '1px solid #ffd1d1';
    elvetBtn.style.color = '#b3261e';
    elvetBtn.style.display = 'none';
    host.insertBefore(elvetBtn, (placeBtn && placeBtn.nextSibling) || hkIndex.nextSibling);
    elvetBtn.addEventListener('click', function()
	{
      var _cap = (elvetBtn.textContent||'').trim().toUpperCase(); var _st0 = (typeof window!=='undefined' ? window.__elh_state__===0 : true); if (_cap === 'FOLYTAT' && _st0) {
        FOLYTATAS = true;
        
        if (typeof setElhelyezesState==='function') setElhelyezesState(1, 'FOLYTAT');
        return;
      }
      
      setElhelyezesState(0, 'ELVET');
},true);   
    return elvetBtn;
  }

  
 
  function setTesztBar(extra)
  {
    {
     
     // var phase = window.__elh_state__ || 0;
     // var msg = '[ELHELYEZÉS=' + phase + (extra? (','+extra) : '') + ']';
    
    }
  }

  
  if(grid && !grid.__f511_fill){
    grid.addEventListener('click', function(ev){
      var t = ev.target;
      var cell = t && t.closest ? t.closest('[data-r][data-c]') : null;
      if(!cell) return;
      var r = Number(cell.getAttribute('data-r'));
      var c = Number(cell.getAttribute('data-c'));
      if(!isFinite(r) || !isFinite(c)) return;
      var cr = String(c+1) + String(r+1); 
      if(hkIndex){ hkIndex.value = cr; hkIndex.dispatchEvent(new Event('input')); }
      if(topIndex){ topIndex.value = cr; topIndex.dispatchEvent(new Event('input')); }
      
    }, true);
    grid.__f511_fill = true;
  }

  
  bindIndexBehavior(hkIndex);
  bindIndexBehavior(topIndex);

  
  function clearRings(){
    if(!grid) return;
    var rings = grid.querySelectorAll('.f511-ring, .f513R-ring');
    for(var i=0;i<rings.length;i++){
      var n = rings[i]; if(n && n.parentNode) n.parentNode.removeChild(n);
    }
  }
  function cellByIndex(idx){
    if(!grid || !idx || idx.length!==2) return null;
    var r = (idx.charCodeAt(1)-48)-1, c = (idx.charCodeAt(0)-48)-1;

    if(r<0||r>8||c<0||c>8) return null;
    return grid.querySelector('[data-r="'+r+'"][data-c="'+c+'"]');
  }
  function drawRingFromCurrentIndex(){
    var idx = (hkIndex && hkIndex.value) || (topIndex && topIndex.value) || '';
    var cell = cellByIndex(idx);

    clearRings();
    if(!cell) return;
    var div = document.createElement('div');
    div.className = 'f511-ring' + (window.__elh_state__===2 ? ' ok' : '');
    cell.appendChild(div);
  }


  function MUHELYtablaba(r,c,)    	
  {
    var tablabaOK = true;
	// ELHELYEZ számláló: a végleges elfogadáskor növeljük (state 2→0)
	
	var ovatos = !!(window.__MUHELY_OVATOS__);
	var D = String(window.DARAB);  
	var main = (D[0]||'-').toUpperCase();
	var color = D[1]+D[2];
	var S = String(window.SARKOK||'????').toUpperCase();

    var M_R = SMY.M_REAL;
	var P_R = SMY.P_REAL;
	var wP =  workP;

    var __oldManual = window.__MANUAL_WRITE__;
    window.__MANUAL_WRITE__ = true;

	var old = String(M_R[r][c] || '---');	
	var t  = ovatos ? ((old[0] === '-' ? D[0] : old[0]) || '-') : ((D[0] !== '-' ? D[0] : old[0]) || '-');
    var c1 = ovatos ? ((old[1] === '-' ? D[1] : old[1]) || '-') : ((D[1] !== '-' ? D[1] : old[1]) || '-');
    var c2 = ovatos ? ((old[2] === '-' ? D[2] : old[2]) || '-') : ((D[2] !== '-' ? D[2] : old[2]) || '-');
    color = shoreNorm2(r,c,(c1 + c2));
    c1 = color.charAt(0) || '-';
    c2 = color.charAt(1) || '-';
    var MR = (t + c1 + c2);
    main  = t;
	
	if (ovatos) 
	{
	
	if ( r > 0 && c > 0 ) {
	if (S[0]!== '?' && P_R[r-1][c-1] === '-') { P_R[r-1][c-1]= S[0]; wP[r-1][c-1]= S[0]; } }
	if ( r > 0 && c < 8 ) {
	if (S[1]!== '?' && P_R[r-1][c] === '-')	{ P_R[r-1][c]= S[1]; wP[r-1][c]= S[1]; } }
	if ( c > 0 && r < 8 ) {
	if (S[2]!== '?' && P_R[r][c-1] === '-')	{ P_R[r][c-1]= S[2]; wP[r][c-1]= S[2]; } }
	if ( c < 8 && r < 8 ) {
	if (S[3]!== '?' && P_R[r][c] === '-') { P_R[r][c]= S[3]; wP[r][c]= S[3]; } }
	
	
	
	M_R[r][c] = MR;
	
	if (D === "---" && SMY.M_SHOT[r][c] === "---") M_R[r][c] = "---";
	
    if (main==='V' || main==='0' || main==='1' || main==='2' || main==='3' || main==='4')
	{
       setCellWater(r,c, main, color);  
    } 
	else 
	if (main==='H' || main==='A' || main==='B' || main==='G' || main==='D')
	{
       setCellShip(r,c, main, color);   
    }
	else if (main==='-') setCellReset(r,c,'-',color);
	
	
	
	SMY.HOMOK_REAL[r][c]=true;
	// SMY.ISHOT_REAL[r][c]=false; // ELHELYEZÉS: lövés pontosítása -> ISHOT megmarad
window.__MANUAL_WRITE__ = __oldManual;
	}
	else  
	{
	   if ( D === "---" && S === "????" )
	   {
	      setCellReset(r,c,'-',color);
		  SMY.HOMOK_REAL[r][c]=true;
	      // SMY.ISHOT_REAL[r][c]=false; // ELHELYEZÉS: lövés pontosítása -> ISHOT megmarad
		  if (typeof updateStatsHud === 'function') updateStatsHud();
		  return true;
	   }
	
	
	if (S[0]!== '?' &&  r > 0 && c > 0 ) 
	{
	  if (P_R[r-1][c-1] !== '-' && S[0]!== P_R[r-1][c-1]) tablabaOK = false;
 	  P_R[r-1][c-1]= S[0]; wP[r-1][c-1]= S[0]; 
	}
	if (S[1]!== '?' &&  r > 0 && c < 8 ) 
	{
	  if (P_R[r-1][c] !== '-' && S[1]!== P_R[r-1][c]) tablabaOK = false;
	  P_R[r-1][c]= S[1]; wP[r-1][c]= S[1]; 
	}
	if (S[2]!== '?' &&  c > 0 && r < 8 ) 
	{
	  if (P_R[r][c-1] !== '-' && S[2]!== P_R[r][c-1]) tablabaOK = false;
	  P_R[r][c-1]= S[2]; wP[r][c-1]= S[2];  
	}
	if (S[3]!== '?' &&  c < 8 && r < 8 ) 
	{
      if (P_R[r][c] !== '-' && S[3]!== P_R[r][c])  tablabaOK = false;
	  P_R[r][c]= S[3]; wP[r][c]= S[3]; 
	}
	
	
	
	M_R[r][c] = MR;
	
	if (D === "---" && SMY.M_SHOT[r][c] === "---") M_R[r][c] = "---";
	
    if (main==='V' || main==='0' || main==='1' || main==='2' || main==='3' || main==='4')
	{
       setCellWater(r,c, main, color);  
    } 
	else 
	if (main==='H' || main==='A' || main==='B' || main==='G' || main==='D')
	{
       setCellShip(r,c, main, color);   
    }
	else if (main==='-') setCellReset(r,c,'-',color);
	
	
	
	SMY.HOMOK_REAL[r][c]=true;
	// SMY.ISHOT_REAL[r][c]=false; // ELHELYEZÉS: lövés pontosítása -> ISHOT megmarad
window.__MANUAL_WRITE__ = __oldManual;
	}
	if (typeof window.refreshTopBoxes === 'function') window.refreshTopBoxes();
	if (typeof updateStatsHud === 'function') updateStatsHud();
	return tablabaOK;
 }	


  // ELHELYEZÉS állapotgép: 0 → 1 → 2 → 0
  window.__elh_state__ = -1;      
  
  
  
    function drawRingAt(r,c,color)
  {
    var g=$("#grid"); if(!g) return;
    clearRings();
    var cell = g.querySelector('[data-r="'+r+'"][data-c="'+c+'"]');
    if(!cell) return;
    var d = document.createElement('div');
    d.className = 'f513R-ring';
    d.style.position='absolute'; d.style.inset='6%';
    d.style.pointerEvents='none'; d.style.borderRadius='8px'; d.style.zIndex='3';
    d.style.border = '3px solid ' + (color==='green' ? '#34a853' : (color==='red' ? '#d93025' : '#f5d10a'));
    d.style.boxShadow = 'inset 0 0 0 2px ' + (color==='green' ? 'rgba(52,168,83,.30)' : (color==='red' ? 'rgba(217,48,37,.30)' : 'rgba(245,209,10,.35)'));
    cell.style.position = 'relative';
    cell.appendChild(d);
  }

  
  
  function setElhelyezesState(next, reason)
  {
    
    var idx = (hkIndex && hkIndex.value) || (topIndex && topIndex.value) || '';  
    var r = (idx.charCodeAt(1)-48)-1, c = (idx.charCodeAt(0)-48)-1;     
	var CompOK=true;
	var MuhelyOK=true;
    var prevState = (typeof window.__elh_state__ === 'number') ? window.__elh_state__ : 0;
    var REASON = (typeof reason!=='undefined' && reason!=null) ? String(reason).trim().toUpperCase() : '';
    window.__elh_last_reason__ = (typeof reason!=='undefined' && reason!=null) ? String(reason) : '';

    if(next<0 || next>2) next = 0;
    window.__elh_state__ = next;
    var elvet = ensureElvetBtn();
	// if(elvet) console.log('STATE NEXT '+next+' ELVET=TRUE')   // RA log 

    var ov = document.getElementById('placeOverlay'); if(ov) ov.style.display = 'none';
	 
    if(next===0)
	{
      clearRings();
      // ELHELYEZ számláló: csak akkor nő, amikor a preview (state 2) végleg ELHELYEZ-re kerül.
      if (prevState === 2 && REASON === 'ELHELYEZ') {
        elhelyezesek++;
        if (typeof updateStatsHud === 'function') updateStatsHud();
      }
      if (placeBtn)
	  {
		placeBtn.style.background = '';
		placeBtn.style.border = '';
		placeBtn.style.color = '';
	  }
      if(elvet){ elvet.style.display=''; elvet.textContent='FOLYTAT'; }
      if (reason === 'ELVET' && vanMENTES) VISSZATOLTES();

    } 
	else if(next===1)
	{
      if (placeBtn)
	  {
		placeBtn.style.background = '';
		placeBtn.style.border = '';
		placeBtn.style.color = '';
	  }
      if(elvet){ elvet.style.display=''; elvet.textContent=' ELVET '; }
      drawRingFromCurrentIndex();

    } 
	else if(next===2)
	{
      if(elvet){ elvet.style.display=''; elvet.textContent=' ELVET '; }
      drawRingFromCurrentIndex();
	   {
	      if (!FOLYTATAS) { MENTES(); vanMENTES=true; }
		
	    

	    MuhelyOK = MUHELYtablaba(r,c);     
		
		if (typeof window.SMY_runAllAutosFixpoint18Last === 'function') window.SMY_runAllAutosFixpoint18Last('MUHELY'); else window.runAllAutosPass();
		window.redrawFromRealAll();
		if (typeof window.refreshTopBoxes === 'function') window.refreshTopBoxes();

		
		CompOK = checkCompatibility(r,c);
		
		if (CompOK && MuhelyOK)
		{
		   
		   if (placeBtn)
		   {
		     placeBtn.style.background = '#00c853';
		     placeBtn.style.border = '2px solid #00a844';
		     placeBtn.style.color = '#ffffff';
		   }
		   if (elvet)
		   {
		     
		     elvet.style.background = '#616161';
		     elvet.style.border = '1px solid #424242';
		     elvet.style.color = '#f5f5f5';
		   }
		   drawRingAt(r,c,'green');
		}
		else
		{
		   
		   if (placeBtn)
		   {
		     placeBtn.style.background = '#d50000';
		     placeBtn.style.border = '2px solid #b71c1c';
		     placeBtn.style.color = '#ffffff';
		   }
		   if (elvet)
		   {
		     
		     elvet.style.background = '#00c853';
		     elvet.style.border = '2px solid #00a844';
		     elvet.style.color = '#ffffff';
		   }
		   drawRingAt(r,c,'red');
		}
	  }  
    }
  }

  if(placeBtn && !placeBtn.__f511)
  {
    placeBtn.addEventListener('click', function()
	{
      var st = window.__elh_state__||0;
      var next = (st===0)?1 : (st===1)?2 : 0;
      setElhelyezesState(next, 'ELHELYEZ');
    }, true);
    placeBtn.__f511 = true;
  }

  
  var rezTimer=null;
  window.addEventListener('resize', function()
  {
    clearTimeout(rezTimer);
    rezTimer=setTimeout(function(){ if(window.__elh_state__>0) drawRingFromCurrentIndex(); }, 100);
  });

  
  function clearTopIndex()
  {
    if(topIndex)
	{
      topIndex.value='';
      topIndex.dispatchEvent(new Event('input'));
    }
  }
  // Wrap loadFromSeedText if exists
  if(typeof window.loadFromSeedText === 'function' && !window.loadFromSeedText.__f511wrap)
  {
    var _lft = window.loadFromSeedText;
    window.loadFromSeedText = function()
	{
      var r = _lft.apply(this, arguments);
      clearTopIndex();
      setElhelyezesState(0, 'load');
      return r;
    };
    window.loadFromSeedText.__f511wrap = true;
  }
  
  document.addEventListener('click', function(ev)
  {
    var b = ev.target && ev.target.closest ? ev.target.closest('button') : null;
    if(!b) return;
    var t = (b.textContent||'').toUpperCase();
    if(t.indexOf('TÁBLA')!==-1 || t.indexOf('TABLA')!==-1 || t.indexOf('RESET')!==-1)
	{
      setTimeout(function(){ clearTopIndex(); setElhelyezesState(0, 'btn'); }, 0);
    }
  }, true);

  
  if(hkIndex && !hkIndex.__f511_ringSync)
  {
    hkIndex.addEventListener('input', function(){ if(window.__elh_state__>0) drawRingFromCurrentIndex(); }, true);
    hkIndex.__f511_ringSync = true;
  }
  if(topIndex && !topIndex.__f511_ringSync)
  {
    topIndex.addEventListener('input', function(){ if(window.__elh_state__>0) drawRingFromCurrentIndex(); }, true);
    topIndex.__f511_ringSync = true;
  }

  
  
})();
</script>

<script>
// f512: Robust LÖVÉS INDEX clearing on board rebuild (MutationObserver) and on load/clear buttons.
(function(){
  "use strict";
  if (window.__f512_applied__) return; window.__f512_applied__ = true;

  function $(sel, root){ return (root||document).querySelector(sel); }
  function debounce(fn, ms){
    var t = null; return function(){ var args=arguments, self=this;
      clearTimeout(t); t=setTimeout(function(){ fn.apply(self,args); }, ms);
    };
  }

  function clearTopIndexVisual(){
    {
      var topIndex = $("#indexInput");
      if(topIndex){
        topIndex.value = "";
        if(!topIndex.getAttribute("data-orig-ph")){
          topIndex.setAttribute("data-orig-ph", topIndex.getAttribute("placeholder")||"");
        }
        topIndex.setAttribute("placeholder","??");
        topIndex.dispatchEvent(new Event("input"));
      }
    }
  }

  function bindButtonHooks(){
    document.addEventListener("click", function(e){
      var b = e.target && e.target.closest ? e.target.closest("button, [role='button']") : null;
      if(!b) return;
      var t = (b.textContent||"").toUpperCase();
      
      var hit = t.indexOf("TÁBLA")!==-1 || t.indexOf("TABLA")!==-1 ||
                t.indexOf("TÖRLÉS")!==-1 || t.indexOf("TORLES")!==-1 ||
                t.indexOf("LELTÁR")!==-1 || t.indexOf("LELTAR")!==-1 ||
                t.indexOf("BETÖLT")!==-1 || t.indexOf("BETOLT")!==-1 ||
                t.indexOf("ÚJ")===0     || t.indexOf("UJ")===0;
      if(hit){
        setTimeout(function(){
          clearTopIndexVisual();
          if(typeof window.setElhelyezesState === "function"){
            window.setElhelyezesState(0,"btn");
          }
        }, 0);
      }
    }, true);
  }

  function bindGridObserver(){
    var grid = $("#grid");
    if(!grid || grid.__f512_obs) return;
    var getCount = function(){
      try{ return grid.querySelectorAll("[data-r][data-c]").length; }catch(e){ return 0; }
    };
    var lastCount = getCount();
    var check = debounce(function(){
      var n = getCount();
      // treat as rebuild if number of cells changes significantly (>= 5) or goes from 0 to >0
      if( (lastCount===0 && n>0) || Math.abs(n-lastCount) >= 5 ){
        lastCount = n;
        clearTopIndexVisual();
        if(typeof window.setElhelyezesState === "function"){
          window.setElhelyezesState(0,"grid-rebuild");
        }
      }
    }, 120);

    var mo = new MutationObserver(function(){
      check();
    });
    mo.observe(grid, { childList:true, subtree:true });
    grid.__f512_obs = mo;
  }

  
  if(document.readyState === "complete" || document.readyState === "interactive"){
    bindButtonHooks(); bindGridObserver();
  } else {
    document.addEventListener("DOMContentLoaded", function(){ bindButtonHooks(); bindGridObserver(); });
  }
})();
</script>

<script>
// f513R - ELHELYEZÉS 2. fázis: MŰHELY beírás + ellenőrzés + színezés; 3. fázis: véglegesítés vagy visszaállítás
(function()
{
  "use strict";
  if (window.__f513R_applied__) return; window.__f513R_applied__ = true;

  function $(sel,root){ return (root||document).querySelector(sel); }

  
  function deepCopy2D(arr)
  {
    if(!arr) return null;
    var out = new Array(arr.length);
    for(var i=0;i<arr.length;i++)
	{
      var row = arr[i];
      if(!row){ out[i]=row; continue; }
      var rr = new Array(row.length);
      for(var j=0;j<row.length;j++)
	  {
        var v = row[j];
        rr[j] = (v && typeof v==='object') ? Object.assign({}, v) : v;
      }
      out[i]=rr;
    }
    return out;
  }
  function parseIndex2RC(idx)
  {
    idx = String(idx||'').trim();
    if(!/^[1-9]{2}$/.test(idx)) return null;
    var c = (idx.charCodeAt(0)-48)-1;
    var r = (idx.charCodeAt(1)-48)-1;
    if(r<0||r>8||c<0||c>8) return null;
    return {r:r, c:c};
  }

  
  window.__snapM = null; window.__snapP = null; window.__snapActive = false;
  window.__elh_ok = null;

  function takeSnapshot()
  {  

      window.__snapM = deepCopy2D(window.workM);
      window.__snapP = deepCopy2D(workP);
      window.__snapActive = true;
      window.__snapM [4][7]= "Gpz";       
      window.__snapP [4][5]= "H";
  }
  function restoreSnapshot()
  {
  if(window.SMY_hardResetView) window.SMY_hardResetView();

    {
	  
      if(!window.__snapActive) return;
      if(window.__snapM) window.workM = deepCopy2D(window.__snapM);
      if(window.__snapP) workP = deepCopy2D(window.__snapP);
      window.__snapActive = false;
      redrawAll();
    }
  }
  function clearSnapshot(){ window.__snapM=null; window.__snapP=null; window.__snapActive=false; }

  
  function redrawAll()
  {
    if(typeof drawPointsOverlay === 'function') drawPointsOverlay();
  }

  
  function clearRings()
  {
    var g = $("#grid"); if(!g) return;
    var rings = g.querySelectorAll('.f513R-ring');
    for(var i=0;i<rings.length;i++){ var n=rings[i]; if(n && n.parentNode) n.parentNode.removeChild(n); }
  }
  function drawRingAt(r,c,color)
  {
    var g=$("#grid"); if(!g) return;
    clearRings();
    var cell = g.querySelector('[data-r="'+r+'"][data-c="'+c+'"]');
    if(!cell) return;
    var d = document.createElement('div');
    d.className = 'f513R-ring';
    d.style.position='absolute'; d.style.inset='6%';
    d.style.pointerEvents='none'; d.style.borderRadius='8px'; d.style.zIndex='3';
    d.style.border = '3px solid ' + (color==='green' ? '#34a853' : (color==='red' ? '#d93025' : '#f5d10a'));
    d.style.boxShadow = 'inset 0 0 0 2px ' + (color==='green' ? 'rgba(52,168,83,.30)' : (color==='red' ? 'rgba(217,48,37,.30)' : 'rgba(245,209,10,.35)'));
    cell.style.position = 'relative';
    cell.appendChild(d);
  }

  
  function colorPairFromDARAB(d)
  {
    d = String(d||'---');
    var v = (d[1]||'x'), h = (d[2]||'x');
    if(v!=='p' && v!=='z') v='x';
    if(h!=='p' && h!=='z') h='x';
    return v+h;
  }
  function applyWorkshopAt(r,c)
  {
    var D = String(window.DARAB||'---');
    var S = String(window.SARKOK||'????').toUpperCase();
    var main = (D[0]||'-').toUpperCase();
    var sub  = colorPairFromDARAB(D);
	
    try
	{
      if(main==='V')
	  {
        if(window.workM?.[r]?.[c]?.kind === 'ship') return {ok:false,reason:'ship→water tiltott'};
        if(typeof setCellWater==='function') setCellWater(r,c,'0','-');
      }
	  else if('HABGD'.indexOf(main)>=0)
	  {
        if(window.workM?.[r]?.[c]?.kind === 'water') return {ok:false,reason:'water→ship tiltott'};
        if(typeof setCellShip==='function') setCellShip(r,c,(main==='H'?'H':main), sub);
      }
      
      var map = [ [-1,-1],[-1,0],[0,-1],[0,0] ];
      for(var i=0;i<4;i++)
	  {
        var ch = (S[i]||'?').toUpperCase(); if(ch!=='H') continue;
        var pr=r+map[i][0], pc=c+map[i][1];
        if(pr<0||pc<0||pr>=9||pc>=9) continue;
        var cur = workP?.[pr]?.[pc];
        if(cur && cur!=='X') return {ok:false,reason:'pont-foglalt ('+pr+','+pc+')'};
        if(typeof markPoint==='function') markPoint(pr,pc,'H'); else 
		{
          if(workP){ if(!workP[pr]) workP[pr]=[]; workP[pr][pc]='H'; }
        }
      }
      redrawAll();
      return {ok:true};
    }catch(e){
      return {ok:false, reason: 'apply hiba'};
    }
  }
  
  // ELVET gomb (ha külön van): állapot 0 + restore
  document.addEventListener('click', function(ev)
  {
    var b = ev.target && ev.target.closest ? ev.target.closest('button') : null;
    if(!b) return;
    var t = (b.textContent||'').toUpperCase();
    if(t.indexOf('ELVET')!==-1)
	{
      if(typeof window.setElhelyezesState==='function')
	  {
        window.setElhelyezesState(0,'ELVET');
      }
    }
  }, true);

})();
</script>

<script>

(function()
{
  "use strict"; if(window.__f513R2_applied__) return; window.__f513R2_applied__=true;
  function $(sel,root){ return (root||document).querySelector(sel); }
  function parseIndex2RC(idx){
    idx = String(idx||'').trim();
    if(!/^[1-9]{2}$/.test(idx)) return null;
    var c = (idx.charCodeAt(0)-48)-1, r = (idx.charCodeAt(1)-48)-1;
    if(r<0||r>8||c<0||c>8) return null;
    return {r:r,c:c};
  }
  function setTeszt(msg)
  {

  }
  function redraw()
  {
    if(typeof drawIndexes==='function') drawIndexes();
      if(typeof drawPointsOverlay==='function') drawPointsOverlay();
      if(window.SMY && typeof SMY.drawShotFallbackText==='function') SMY.drawShotFallbackText();
  }

  
  var prev = window.setElhelyezesState;
 /* if(typeof prev === 'function' && !prev.__f513R2){
    window.setElhelyezesState = function(next, reason){
      var before = window.__elh_state__||0;
      var hk = $("#homokozo_panel input[type='text']");
      var idx = (hk && hk.value) || ($("#indexInput") && $("#indexInput").value) || '';
      var rc  = parseIndex2RC(idx);
	  	  console.log('MÁSIK ??? 5144');
      // Intercept 1->2 to force commit + redraw + trace
      if(before===1 && next===2 && rc){
        var D = String(window.DARAB||'---'); var S = String(window.SARKOK||'????');
        if(typeof applyWorkshopAt==='function'){
          var res = applyWorkshopAt(rc.r, rc.c);
          // redraw aggressively
          redraw(); requestAnimationFrame(redraw);
          setTeszt(`APPLY r${rc.r+1}c${rc.c+1} D=${D} S=${S} ok=${res&&res.ok}`);
        }else{
          setTeszt(`APPLY? (függvény hiányzik) idx=${idx}`);
        }
      }
      var r = prev.apply(this, arguments);
      return r;
    };
    window.setElhelyezesState.__f513R2 = true;
  }*/
})();
</script>
  
  </div>

</div>

<script>
document.addEventListener('DOMContentLoaded', function(){
  {
    var hud = document.getElementById('ezuestHUD');
    if(hud){ hud.style.display = 'block'; }
  }
});
</script>

<script id="ezuest_snap_tag">
(function(){
  function byId(id){ return document.getElementById(id); }
  var bodyEl = byId('ezuestHUDBody');
  function now(){ try{ return new Date().toLocaleTimeString(); }catch(_){ return ''; } }
  function log(msg)
  {
 
  }
  window.ezuestLog = function(m){ log(m); };
  var clearBtn = document.getElementById('hudClearBtn');
  var hideBtn = document.getElementById('hudHideBtn');
  if(clearBtn){ clearBtn.addEventListener('click', function(){ byId('ezuestHUDBody').textContent=''; }); }
  if(hideBtn){ hideBtn.addEventListener('click', function(){ byId('ezuestHUD').style.display='none'; }); }
  log('HUD kész - SNAP-tag diagnosztika.');

  function deepClone(m){ try{ return JSON.parse(JSON.stringify(m)); }catch(_){ return (m && m.slice)? m.slice(): m; } }
  function isNxNMatrix(x, n){ try{ return Array.isArray(x) && x.length===n && Array.isArray(x[0]) && x[0].length===n; }catch(_){ return false; } }

  var SNAP = null;
  function saveAllAndTag(){
  try{
    var N9 = 9;
    function dclone(x){ try{ return JSON.parse(JSON.stringify(x)); }catch(_){ return x; } }
    function norm(ref){
      var out = Array.from({length:N9},()=>Array(N9));
      if (Array.isArray(ref)){
        for (var r=0;r<N9;r++){
          var row = ref[r] || [];
          for (var c=0;c<N9;c++){ out[r][c] = (row[c]!==undefined)?row[c]:'-'; }
        }
      } else {
        for (var r=0;r<N9;r++){ for (var c=0;c<N9;c++){ out[r][c]='-'; } }
      }
      return out;
    }

    var S = {
      full: true,
      M_REAL: norm(dclone(SMY.M_REAL)),
      workM:           norm(dclone(window.workM)),
      workP:           norm(dclone(workP))
    };

    
    

    window.SNAP = S;
    // if (window.ezuestLog|| console.log)("SNAP mentve - FULL SNAP (9×9×3)");
  }catch(e){
    //(window.ezuestLog||console.log)("SNAP mentés HIBA: "+e);
  }
}

  function restoreAll()
  {
  // FIX18 begin: prevent recursive ELVET→restoreALL loop
  __isRestoring = true;
  try {

  HUD_write("[RESTORE TEST] Restoring from SNAP...");
  try {
    if (SNAP && SNAP.workM && workM) {
      for (let r=0;r<9;r++) for (let c=0;c<9;c++) workM[r][c] = SNAP.workM[r][c];
    }
    if (SNAP && SNAP.workP && workP) {
      for (let r=0;r<9;r++) for (let c=0;c<9;c++) workP[r][c] = SNAP.workP[r][c];
    }
    HUD_write("[RESTORE OK] workM/workP reloaded");
  } catch(e) { HUD_write("RESTORE error:"+e); }

    try{
      if(!SNAP){ log('Nincs SNAP - nincs mit visszatölteni.'); return; }
      var n=0;
      for (var k in SNAP){ window[k] = deepClone(SNAP[k]); n++; }
      if (typeof buildEmptyBoard==='function') buildEmptyBoard();
        
        
        if (typeof drawPointsOverlay==='function') drawPointsOverlay();
        if (typeof recomputeGlobals==='function') recomputeGlobals();
        if (typeof diagRecompute2==='function') diagRecompute2();
      log('SNAP visszatöltve: '+n+' mátrix. (Keress „Bpz-SNAPTAG”-et a (7,7)-en.)');
    }catch(e){ log('SNAP visszatöltés HIBA'); }

  {
    // === SNAP HARD RESTORE (min) ===
    var S = window.SNAP || window.snap || null;
    if (S){
      function dclone(x){ try{ return JSON.parse(JSON.stringify(x)); }catch(_){ return x; } }
      function norm9x9(ref){
        var N9 = 9;
        var out = Array.from({length:N9},()=>Array(N9));
        if (Array.isArray(ref)){
          for (var r=0;r<N9;r++){
            var row = ref[r] || [];
            for (var c=0;c<N9;c++){ out[r][c] = (row[c]!==undefined)?row[c]:'-'; }
          }
        } else {
          for (var r=0;r<N9;r++){ for (var c=0;c<N9;c++){ out[r][c]='-'; } }
        }
        return out;
      }
      if ('workM' in S) window.workM = norm9x9(dclone(S.workM));
      if ('SMY.M_REAL' in S) SMY.M_REAL = norm9x9(dclone(S.SMY.M_REAL));
      if ('workP' in S) workP = norm9x9(dclone(S.workP));
      if ('munkaPONTOK' in S) window.munkaPONTOK = norm9x9(dclone(S.munkaPONTOK));
      if ('munkaOSZLOPOK' in S) window.munkaOSZLOPOK = dclone(S.munkaOSZLOPOK);
      if ('munkaSOROK' in S) window.munkaSOROK = dclone(S.munkaSOROK);
      if ('munkaGLOBÁLISOK' in S) window.munkaGLOBÁLISOK = dclone(S.munkaGLOBÁLISOK);
      if (typeof drawBoard==='function') drawBoard();
      if (typeof drawPointsOverlay==='function') drawPointsOverlay();
      // (window.ezuestLog|| console.log)('SNAP: hard-restore done');
    } else {
      // (window.ezuestLog|| console.log)('SNAP: missing - nothing to restore');
    }
    // === /SNAP HARD RESTORE (min) ===
  }

  {
    // === SNAP RESTORE DIAG ===
    (function(){
      var cellsSet=0, ptsSet=0;
      try{
        var N = window.N || 9;
        
        if (typeof clearCell === 'function' && typeof setCellWater === 'function' && typeof setCellShip === 'function') {
          for (var r=0; r<N; r++){
            for (var c=0; c<N; c++){
              try{
                var t = (window.workM && window.workM[r]) ? window.workM[r][c] : null;
                if (!t) { clearCell(r,c); continue; }
                if (typeof t === 'string'){
                  var main = (t.match(/[ABGD0-4V]/i)||[''])[0].toUpperCase();
                  var colm = (t.match(/[pz]/gi)||[]).map(x=>x.toLowerCase());
                  var color = (colm[0]||'-');
                  if (main==='V' || main==='0' || main==='1' || main==='2' || main==='3' || main==='4'){
                    setCellWater(r,c, main, color);
					cellsSet++;
                  } 
				  else 
				  if (main==='H' || main==='A' || main==='B' || main==='G' || main==='D')
				  {
                    setCellShip(r,c, main, color);       
					cellsSet++;
                  }
				  else if (main==='-') setCellReset(r,c,'-',color);
                  
                } else if (t && typeof t === 'object'){
                  if (t.kind==='water'){ setCellWater(r,c, t.main||'V', t.color||'-'); cellsSet++; }
                  else if (t.kind==='ship'){ setCellShip(r,c, t.main||'A', t.color||'-'); cellsSet++; }
                  else { clearCell(r,c); }
                } else {
                  clearCell(r,c);
                }
              }catch(_){}
            }
          }
        }
        
        if (Array.isArray(workP)){
          for (var r2=0; r2<N-1; r2++){
            var row = workP[r2] || [];
            for (var c2=0; c2<N-1; c2++){
              var pv = row[c2];
              workP[r2][c2] = pv; ptsSet++;
            }
          }
          if (typeof drawPointsOverlay==='function'){ drawPointsOverlay(); }
        }
        
        if (typeof drawBoard==='function') drawBoard();
        
      }catch(_){}
    })();
    
  }

  } finally {
    __lastRestoreTime = Date.now(); 
__isRestoring = false;
  }
  

{
  
  if (window.SMY_forceSegmentsRedraw) window.SMY_forceSegmentsRedraw();
}

  
 // })();  // close ezuest_snap_tag IIFE
}
  // === Event-driven phase watcher (no timers) ===
  (function(){
    {
      var _log = (window.ezuestLog || window.console  || function(){});
      var __state = (typeof window.__elh_state__ === 'number') ? window.__elh_state__ : 0;
      delete window.__elh_state__;
      Object.defineProperty(window, '__elh_state__', {
        get: function(){ return __state; },
        set: function(v){
          var last = __state; __state = v;
          try {
          //  _log('PHASE: ' + last + ' → ' + v);
            if (last === 1 && v === 2) { saveAllAndTag(); }
            if (last === 2 && v === 0 && String(window.__elh_last_reason__ || '') === 'ELVET') {
              _log('ELVET detektálva - SNAP visszatöltés.');
              restoreAll();
              window.__elh_last_reason__ = '';
            }
          } catch(_){}
        },
        configurable: true
      });
    }
  })();
  // === /Event-driven phase watcher ===
})();
</script>

<script>
document.addEventListener('DOMContentLoaded', function(){
  { var x=document.getElementById('muhely_debug_hud'); if(x){ x.remove(); } }
});
</script>

<script>
document.addEventListener('DOMContentLoaded', function(){
  {
    var cb = document.getElementById('muhely_ovatos_toggle');
    if(cb){
      window.__MUHELY_OVATOS__ = !!cb.checked;
      cb.addEventListener('change', function(){
        window.__MUHELY_OVATOS__ = !!cb.checked;
        
      });
    }
  }
});
</script>

  </div>
  <div class="hud-body" id="ezuestHUDBody"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function(){
  const bodyEl = document.getElementById('ezuestHUDBody');
  const clearBtn = document.getElementById('hudClearBtn');
  const hideBtn = document.getElementById('hudHideBtn');

  function log(msg){
    {
	
	}
  }

  window.ezuestLog = log;
  if(clearBtn) clearBtn.addEventListener('click', ()=>{ bodyEl.textContent=''; });
  if(hideBtn) hideBtn.addEventListener('click', ()=>{ document.getElementById('ezuestHUD').style.display='none'; });



});
</script>

<style id="ezuest_big_hud_style">
  #ezuestHUD { position: fixed; bottom: 600px; left: 8px; width: min(640px, 70vw); max-height: 40vh;
    overflow: auto; background: rgba(0,0,0,0.80); color: #c8f7c5; font-family: ui-monospace, Menlo, Monaco, Consolas, "Courier New", monospace;
    font-size: 12px; line-height: 1.35; padding: 8px 10px 10px 10px; border: 2px solid #6df06d; border-radius: 10px;
    z-index: 999999; box-shadow: 0 6px 22px rgba(0,0,0,0.45); }
  #ezuestHUD .hud-head { display:flex; align-items:center; justify-content:space-between; font-weight:700; margin-bottom:6px; }
  #ezuestHUD .hud-head .btn { cursor:pointer; padding:2px 6px; border:1px solid #6df06d; border-radius:6px; background:transparent; color:#c8f7c5; font-weight:700; }
  #ezuestHUD .hud-body { white-space: pre-wrap; }
</style>
 
<script>
document.addEventListener('DOMContentLoaded', function(){
  
  const bodyEl = document.querySelector('#ezuestHUD .hud-body');
  const clearBtn = document.getElementById('hudClearBtn');
  const hideBtn = document.getElementById('hudHideBtn');

  function log(msg){
    {
	   }
  }

  window.ezuestLog = log;
  if(clearBtn) clearBtn.addEventListener('click', ()=>{ if(bodyEl) bodyEl.textContent=''; });
  if(hideBtn) hideBtn.addEventListener('click', ()=>{ document.getElementById('ezuestHUD').style.display='none'; });

  
  
});
</script>



<script>
(function(){
  function logTop(msg){
    {
	  
    }
  }
  function hudLog(msg){ }
  function is9x9(g){
    if (!Array.isArray(g) || g.length !== 9) return false;
    for (var i=0;i<9;i++){ if (!Array.isArray(g[i]) || g[i].length !== 9) return false; }
    return true;
  }
  function norm9(g,fill){
    var out = Array.from({length:9},()=>Array(9).fill(fill||'-'));
    if (Array.isArray(g)){
      for (var r=0;r<9;r++){
        var row = g[r] || [];
        for (var c=0;c<9;c++){ out[r][c] = (row[c]!==undefined? row[c] : (fill||'-')); }
      }
    }
    return out;
  }
  function redrawAll()
  {
    if (typeof buildEmptyBoard==='function') buildEmptyBoard();
    
    
    if (typeof drawPointsOverlay==='function') drawPointsOverlay();
  }
  function forceRestore(){
    
    
    {
      if (typeof restoreAll === 'function'){
        restoreAll();
        return;
      }
    }
    try{
      var S = window.SNAP || window.snap || null;
      if (!S){ hudLog('[forceRestore] SNAP missing'); return; }
      window.workM = norm9(S.workM, '-');
      if (S.SMY.M_REAL) SMY.M_REAL = norm9(S.SMY.M_REAL, '-');
      if (S.workP) workP = norm9(S.workP, '-');
      if (S.munkaPONTOK) window.munkaPONTOK = norm9(S.munkaPONTOK, '-');
      redrawAll();
      hudLog('[forceRestore] hard applied (workM/workP/SMY.M_REAL/munkaPONTOK)');
    }catch(e){
      hudLog('[forceRestore] error: '+(e && e.message? e.message : e));
    }
  }

  
  {
    var __oldOn = window.onPhaseChange;
    window.onPhaseChange = function(prev, next, reason){
      if (typeof __oldOn === 'function') __oldOn.apply(this, arguments);
      if (prev === 2 && next === 0){
        
        forceRestore();
      }
    };
  }

  
  {
    var elvetBtn = document.querySelector('[data-action="ELVET"], #ELVET, .btn-elvet');
    if (elvetBtn){
      elvetBtn.addEventListener('click', function(){
        setTimeout(forceRestore, 0);
      });
    }
  }
})();
</script>



<style id="smyoz_rc_patch_css_v12">
.cell { position: relative; }
.rc-segV, .rc-segH { position: absolute; pointer-events: none; opacity: 0.95; background: currentColor; z-index:2; }
.rc-segV { left: 50%; transform: translateX(-50%); width: 5px; top: 0; bottom: 0; }
.rc-segH { top: 50%; transform: translateY(-50%); height: 5px; left: 0; right: 0; }
.rc-rejtveny-footer { margin-top: .5rem; font-size: .92em; white-space: pre-wrap; line-height: 1.25; }
</style>

<script id="smyoz_rc_patch_js_v12">
(function(){
  "use strict";
  window.RC_CONF = Object.assign({ colorMap:{ p:'#ff1744', z:'#00c853', '-':null }, thickness:{ v:5, h:5 }, overlapPx:0 }, window.RC_CONF||{});
  function onReady(fn){ if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', fn); else fn(); }
  onReady(function(){
    function rcEnsureRealCellOnly(){
      var wm=window.workM; if(!wm||!Array.isArray(wm)) return;
      for(var r=0;r<wm.length;r++){ var row=wm[r]; if(!row||!Array.isArray(row)) continue;
        for(var c=0;c<row.length;c++){ var cell=row[c];
          if(cell&&typeof cell==='object'){ if(typeof cell.realCell!=='string'||cell.realCell.length!==3) cell.realCell='---'; }
        }
      }
    }
    function colorFromCode(ch){ var m=(window.RC_CONF&&RC_CONF.colorMap)?RC_CONF.colorMap:null; return (m&&(ch in m))?m[ch]:null; }
    function ensureSegLayer(r,c){
      var cellEl=document.querySelector('.cell[data-r="'+r+'"][data-c="'+c+'"]'); if(!cellEl) return null;
      var v=cellEl.querySelector('.rc-segV'); if(!v){ v=document.createElement('div'); v.className='rc-segV'; cellEl.appendChild(v); }
      var h=cellEl.querySelector('.rc-segH'); if(!h){ h=document.createElement('div'); h.className='rc-segH'; cellEl.appendChild(h); }
      var cs=getComputedStyle(cellEl);
      var bTop=parseFloat(cs.borderTopWidth)||0, bRight=parseFloat(cs.borderRightWidth)||0, bBottom=parseFloat(cs.borderBottomWidth)||0, bLeft=parseFloat(cs.borderLeftWidth)||0;
      var extra=(RC_CONF&&RC_CONF.overlapPx|0)||0;
      v.style.top=(-Math.max(bTop,bBottom)-extra)+'px'; v.style.bottom=(-Math.max(bTop,bBottom)-extra)+'px';
      h.style.left=(-Math.max(bLeft,bRight)-extra)+'px'; h.style.right=(-Math.max(bLeft,bRight)-extra)+'px';
      return {v:v,h:h};
    }
    window.drawSegmentsFromRealCell=function(r,c){
      {
        rcEnsureRealCellOnly();
        var rc=(window.SMY&&SMY.M_REAL&&SMY.M_REAL[r])?(SMY.M_REAL[r][c]||'---'):'---';
        var layers=ensureSegLayer(r,c); if(!layers) return;
        var colV=colorFromCode(rc.charAt(1)); var colH=colorFromCode(rc.charAt(2));
        var tV=(RC_CONF&&RC_CONF.thickness&&(RC_CONF.thickness.v|0))||5; var tH=(RC_CONF&&RC_CONF.thickness&&(RC_CONF.thickness.h|0))||5;
        if(colV){ layers.v.style.color=colV; layers.v.style.width=tV+'px'; layers.v.style.display='block'; } else { layers.v.style.display='none'; }
        if(colH){ layers.h.style.color=colH; layers.h.style.height=tH+'px'; layers.h.style.display='block'; } else { layers.h.style.display='none'; }
      }
    };
    function tryWrapSetter(name){
      var orig=window[name]; if(typeof orig!=='function'||orig.__rcWrapped) return;
      function wrapped(){ var r=arguments[0],c=arguments[1],typeChar=arguments[2],pair2=arguments[3]; var ret=orig.apply(this,arguments);
        { rcEnsureRealCellOnly(); var wm=window.workM; if(wm&&typeof r==='number'&&typeof c==='number'){ var cell=wm[r]&&wm[r][c];
          if(cell&&typeof cell==='object'){ var rc=(typeof cell.realCell==='string'&&cell.realCell.length===3)?cell.realCell:'---'; var a=rc.split('');
            if(typeof typeChar==='string'&&typeChar.length===1) a[0]=typeChar;
            if (typeof pair2==='string' && pair2.length===2) {  var A = pair2.charAt(0).toLowerCase();  var B = pair2.charAt(1).toLowerCase();  if ((A==='x' && (B===''||B==='x')) || (A && B && A===B && (A==='p'||A==='z'))) {    a[1]=A; a[2]=(A==='x')?'x':A;  } else if (A==='-' && (B==='p'||B==='z')) {    a[2]=B;  } else if ((A==='p'||A==='z') && B==='-') {    a[1]=A;  }}
            cell.realCell=a.join(''); window.drawSegmentsFromRealCell(r,c);
      if(window.workM && workM[r] && workM[r][c]) workM[r][c].rawPair = pair2; } } }
        return ret; }
      wrapped.__rcWrapped=true; window[name]=wrapped;
    }
    tryWrapSetter('setCellWater'); tryWrapSetter('setCellShip');
    window.applyShotToRealCell=function(r,c,typeChar,pair2chars){ {
      rcEnsureRealCellOnly(); var wm=window.workM, cell=wm&&wm[r]&&wm[r][c]; if(!cell||typeof cell!=='object') return;
      var rc=(typeof cell.realCell==='string'&&cell.realCell.length===3)?cell.realCell:'---'; var a=rc.split('');
      if(typeof typeChar==='string'&&typeChar.length===1) a[0]=typeChar;
      var explicit={'zz':1,'pp':1,'x ':1,'xx':1,'--':1,'-p':1,'-z':1,'p-':1,'z-':1,'pz':1,'zp':1};
      if(typeof pair2chars==='string'&&pair2chars.length===2&&explicit[pair2chars]){ a[1]=pair2chars.charAt(0); a[2]=pair2chars.charAt(1); }
      cell.realCell=a.join(''); window.drawSegmentsFromRealCell(r,c);
    if(window.workM && workM[r] && workM[r][c]) workM[r][c].rawPair = pair2; }};
    /*************************************************
    // REJTVÉNY támogatás
    function RC_extractRejtveny(text){ if(typeof text!=='string') return null; var m=text.match(/REJTVÉNY[\s\S]*$/); return m?m[0]:null; }
    function RC_findHajokPanel(){
      var el=document.querySelector('#hajokPanel,[data-panel="hajok"],.hajok-panel'); if(el) return el;
      var cand=Array.prototype.slice.call(document.querySelectorAll('h1,h2,h3,h4,div,span'))
        .find(function(x){ return /HAJÓK/i.test(x.textContent||''); });
      return cand ? (cand.closest('.panel') || cand.parentElement || cand) : null;
    }
    window.RC_renderRejtvenyFooter=function(text){
      var part=RC_extractRejtveny(text); if(!part) return;
      var panel=RC_findHajokPanel(); if(!panel) return;
      var foot=panel.querySelector('.rc-rejtveny-footer'); if(!foot){ foot=document.createElement('div'); foot.className='rc-rejtveny-footer'; 
	  panel.appendChild(foot); }
      foot.textContent=part;
    };
    document.addEventListener('input',function(ev){
      var t=ev.target; if(t&&(t.tagName==='TEXTAREA'||(t.tagName==='INPUT'&&t.type==='text'))){ if(t.value&&/REJTVÉNY/.test(t.value)){ window.RC_renderRejtvenyFooter(t.value); } }
    },true);
    document.addEventListener('change',function(ev){
      var t=ev.target; if(t&&(t.tagName==='TEXTAREA'||(t.tagName==='INPUT'&&t.type==='text'))){ if(t.value&&/REJTVÉNY/.test(t.value)){ window.RC_renderRejtvenyFooter(t.value); } }
    },true);
    setTimeout(function(){
      var arr=document.querySelectorAll('textarea, input[type="text"]');
      for(var i=0;i<arr.length;i++){ var v=arr[i].value; if(v&&/REJTVÉNY/.test(v)){ window.RC_renderRejtvenyFooter(v); break; } }
    }, 1000);
	*/
  });
})();
</script>



<script id="ui_teendok1018_js">
(function(){
  function onReady(fn){ if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', fn); else fn(); }
  onReady(function(){
    {
      
      var fileIn = document.getElementById('seedFileInput');
      if(fileIn && !fileIn.__ui_keep_visible){
        fileIn.addEventListener('change', function(){
          setTimeout(function(){
            var p=document.getElementById('seedPastePanel'); if(p) p.style.display='block';
            var b=document.getElementById('loadSeed'); if(b) b.style.display='inline-block';
          }, 0);
        });
        fileIn.__ui_keep_visible = true;
      }

      // Turn 'Automatizmusok' header into toggler and move switches into overlay
      var header = Array.from(document.querySelectorAll('#autoSwitches div')).find(function(el){
        return (el.textContent||'').trim().toLowerCase() === 'automatizmusok';
      });
      if(header){
        header.classList.add('auto-link');
        header.addEventListener('click', function(){ toggleAutoOverlay(true); });
      }

      var rows = document.getElementById('autoRows');
      var host = document.getElementById('autoRowsHost');
      if(rows && host && !rows.__ui_moved){
        host.appendChild(rows);
        rows.style.display = 'block'; 
        rows.__ui_moved = true;
      }

      var overlay = document.getElementById('autoOverlay');
      var closeBtn = document.getElementById('autoClose');
      function toggleAutoOverlay(show){
        if(!overlay) return;
        overlay.style.display = show ? 'flex' : 'none';
      }
      window.toggleAutoOverlay = toggleAutoOverlay;
      if(closeBtn){ closeBtn.addEventListener('click', function(){ toggleAutoOverlay(false); }); }
      if(overlay){
        overlay.addEventListener('click', function(ev){ if(ev.target === overlay) toggleAutoOverlay(false); });
      }
      document.addEventListener('keydown', function(ev){ if(ev.key==='Escape') toggleAutoOverlay(false); });

    }
  });
})();
</script>

<script id="ui_teendok1018C_js">
(function(){
  function onReady(fn){ if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', fn); } else { fn(); } }
  onReady(function(){
    {
      var tb = document.querySelector('.toolbar');
      if(tb && !tb.__patchedC){
        tb.__patchedC = true;
        var firstGroup = tb.querySelector('.group');
        if(firstGroup){
          var slot = document.createElement('div');
          slot.id = 'slotLoadBtn';
          slot.style.minWidth = '140px';
          firstGroup.insertAdjacentElement('afterend', slot);
          var btn = document.getElementById('loadSeed');
          if(btn){ slot.appendChild(btn); }
        }
      }
      // Automations overlay
      var header = Array.from(document.querySelectorAll('#autoSwitches div')).find(function(el){
        return (el.textContent||'').trim().toLowerCase() === 'automatizmusok';
      });
      var rows = document.getElementById('autoRows');
      var host = document.getElementById('autoRowsHost');
      var overlay = document.getElementById('autoOverlay');
      var closeBtn = document.getElementById('autoClose');
      function toggleAuto(show){ if(!overlay) return; overlay.style.display = show ? 'flex' : 'none'; }
      if(header){ header.classList.add('auto-link'); header.addEventListener('click', function(){ toggleAuto(true); }); }
      if(rows && host && !rows.__moved){
        host.appendChild(rows); rows.style.display='block'; rows.__moved=true;
      }
      if(closeBtn){ closeBtn.addEventListener('click', function(){ toggleAuto(false); }); }
      if(overlay){ overlay.addEventListener('click', function(ev){ if(ev.target===overlay) toggleAuto(false); }); }
      document.addEventListener('keydown', function(ev){ if(ev.key==='Escape') toggleAuto(false); });

      
      var fileIn = document.getElementById('seedFileInput');
      if(fileIn && !fileIn.__keepVisibleC){
        fileIn.addEventListener('change', async function(ev){
          try{
            var f = ev.target.files && ev.target.files[0];
            if(f){ window.__lastFileText = await f.text(); }
          }catch(e){}
          // re-show UI (some older handler might hide)
          setTimeout(function(){
            var p=document.getElementById('seedPastePanel'); if(p) p.style.display='block';
            var b=document.getElementById('loadSeed'); if(b) b.style.display='inline-block';
          }, 0);
        });
        fileIn.__keepVisibleC = true;
      }

      
      var loadBtn = document.getElementById('loadSeed');
      /* [SEED] prefer-file click intercept removed: BETÖLTÉS always runs the normal reset+load path. */


      // STOP attention in LÖVÉS input
      try{
        var idx = document.getElementById('indexInput');
        if(idx && !idx.__stopWarn){
          function flashSTOP(){
            var note = document.createElement('div');
            note.textContent = 'STOP';
            note.style.cssText='position:fixed;left:0;right:0;top:20px;margin:auto;width:120px;text-align:center;padding:8px 0;font-weight:900;border-radius:10px;background:#ffe08a;color:#222;box-shadow:0 8px 18px rgba(0,0,0,.2);z-index:100000';
            document.body.appendChild(note);
            setTimeout(function(){ note.remove(); }, 1200);
          }
          idx.addEventListener('keydown', function(ev){
            var v = (idx.value||'').trim().toUpperCase();
            if(ev.key==='Enter' && v==='STOP'){ ev.preventDefault(); flashSTOP(); }
          });
          idx.__stopWarn = true;
        }
      }catch(e){}

    }
  });
})();
</script>

<script id="teendok1018C2_js">
(function(){
  function ready(f){ if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', f); } else { f(); } }
  ready(function(){
    {
      var tb = document.querySelector('.toolbar');
      if(tb && !tb.__slotC2){
        tb.__slotC2 = true;
        
        var groups = tb.querySelectorAll(':scope > .group');
        if(groups && groups.length >= 2){
          
          var slot = document.getElementById('slotLoadBtn');
          if(!slot){
            slot = document.createElement('div');
            slot.id = 'slotLoadBtn';
            groups[0].insertAdjacentElement('afterend', slot);
          }
          var btn = document.getElementById('loadSeed');
          if(btn && btn.parentElement !== slot){
            slot.appendChild(btn);
          }
        }
      }

      
      var fileIn = document.getElementById('seedFileInput');
      if(fileIn && !fileIn.__c2){
        fileIn.addEventListener('change', async function(ev){
          try{
            var f = ev.target.files && ev.target.files[0];
            if(f){
              window.__lastSeedText = await f.text();
            }
          }catch(e){}
          
          try{ var p=document.getElementById('seedPastePanel'); if(p){ p.style.display='block'; } }catch(e){}
          try{ var b=document.getElementById('loadSeed'); if(b){ b.style.display='inline-block'; } }catch(e){}
        });
        fileIn.__c2 = true;
      }

      
      var loadBtn = document.getElementById('loadSeed');
      if(loadBtn && !loadBtn.__c2){
        // [SEED] click intercept removed: BETÖLTÉS always runs the normal reset+load handler.
        loadBtn.__c2 = true;
        loadBtn.style.fontFamily = getComputedStyle(document.body).fontFamily;
        loadBtn.style.fontWeight = '800';
        loadBtn.style.fontSize = '16px';
      }
    }
  });
})();
</script>

<script id="ui_teendok1018C3_js">
(function(){
  function ready(f){ if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', f); } else { f(); } }

  function addMarker(id){
    var host = document.getElementById(id);
    if(!host) return;
    if(host.querySelector('.hk-marker')) return;
    var m = document.createElement('div');
    m.className = 'hk-marker';
    host.appendChild(m);
  }

  function visible(el){
    return !!(el && el.offsetParent !== null);
  }

  function setupElvetPlaceholder(containerId, phId){
    var host = document.getElementById(containerId);
    if(!host) return false;

    
    var elhelyezBtn = null;
    var rows = host.querySelectorAll('button');
    for(var i=0;i<rows.length;i++){
      var b = rows[i];
      var t = (b.textContent||'').trim().toUpperCase();
      if(t === 'ELHELYEZ'){ elhelyezBtn = b; break; }
    }
    if(!elhelyezBtn) return false;

    
    var ph = document.getElementById(phId);
    if(!ph){
      ph = document.createElement('span');
      ph.id = phId;
      ph.style.display = 'inline-block';
      ph.style.verticalAlign = 'middle';
      
      var meas = document.createElement('button');
        meas.textContent = 'ELVET';
        meas.style.cssText = 'position:absolute;visibility:hidden;white-space:nowrap;padding:5px 10px;font-weight:800;';
        document.body.appendChild(meas);
        var w = Math.max(meas.offsetWidth, 70);
        var h = Math.max(meas.offsetHeight, elhelyezBtn.offsetHeight || 28);
        meas.remove();
        ph.style.width = w + 'px';
        ph.style.height = h + 'px';
      elhelyezBtn.insertAdjacentElement('afterend', ph);
    }

    function sync(){
      // If a real ELVET button is visible in the same row container, hide placeholder; otherwise show it.
      var parentRow = elhelyezBtn.parentElement;
      var elvetBtn = null;
      if(parentRow){
        var btns = parentRow.querySelectorAll('button');
        for(var j=0;j<btns.length;j++){
          var tt = (btns[j].textContent||'').trim().toUpperCase();
          if(tt === 'ELVET'){ elvetBtn = btns[j]; break; }
        }
      }
      var showPh = !(elvetBtn && visible(elvetBtn));
      ph.style.display = showPh ? 'inline-block' : 'none';
    }

    var mo = new MutationObserver(sync);
    mo.observe(host, { childList:true, subtree:true, attributes:true, attributeFilter:['style','class'] });
    window.addEventListener('resize', sync);
    setInterval(sync, 400);
    sync();
    return true;
  }

  ready(function(){
    // Markers to see which homokozó van használatban
      addMarker('homokozo_panel');
      addMarker('homokozo_card');

      
      var ok1 = setupElvetPlaceholder('homokozo_panel', 'elvet_placeholder_panel');
      var ok2 = setupElvetPlaceholder('homokozo_card', 'elvet_placeholder_card');
      
  });
})();
</script>

<!-- SAFE1: SMY skeleton appended automatically on 2025-10-27T10:58:19 -->
<script>
(function() {
  {
    if (!window.SMY) {
      const N = 9;              
      const P = N + 1;          
      const fill2d = (r, c, v) => Array.from({length:r}, () => Array.from({length:c}, () => v));
      const fill1d = (n, v) => Array.from({length:n}, () => v);

      const M_EMPTY = fill2d(N, N, '---');   
      const P_EMPTY = fill2d(P, P, '-');     
      const V9 = fill1d(N, 0);

      const cfg = { N, P, version: 'v8.19_BAZIS_SAFE1', ts: new Date().toISOString() };
      const counts = { shots: 0, deducedCells: 0, deducedPoints: 0 };

      const real = {
        M: M_EMPTY.map(r => r.slice()),
        P: P_EMPTY.map(r => r.slice()),
        SOROK: V9.slice(),
        OSZL: V9.slice(),
        KERET: P_EMPTY.map(r => r.slice())
      };

      const snap = {
        M: real.M.map(r => r.slice()),
        P: real.P.map(r => r.slice()),
        SOROK: real.SOROK.slice(),
        OSZL: real.OSZL.slice(),
        KERET: real.KERET.map(r => r.slice()),
        COUNTS: Object.assign({}, counts),
        CFG: Object.assign({}, cfg)
      };

      window.SMY = {
        // INPUT-only (seedből töltve)
        MATRIX_INPUT: M_EMPTY.map(r => r.slice()),
        POINTS_INPUT: P_EMPTY.map(r => r.slice()),
        SOROK_INPUT: V9.slice(),
        OSZL_INPUT: V9.slice(),

        // SHOT (kézi lövések / beviteli jelek) - NEM promótál automatikusan REAL-ba
        M_SHOT: fill2d(N, N, '---'),
        P_SHOT: fill2d(P, P, '-'),

        // REAL - kizárólag megfejtés és automatizmusok eredménye
        M_REAL: real.M,
        P_REAL: real.P,
        SOROK_REAL: real.SOROK,
        OSZL_REAL: real.OSZL,
        KERET_REAL: real.KERET,

        // SNAP - REAL teljes tükre + kért kiegészítők
        SNAP: snap,

        
        CFG: cfg,           // kérésedre SNAP-be is bekerül
        VIEW: { hud: true },
        COUNTS: counts      // esemény-alapú frissítés: ott növeljük, ahol változik az állapot
      };

      // Minimális, nem tolakodó konzol-diagnosztika (UI-t nem módosítunk SAFE1-ben)
      void 0;
    }

  }
})();
</script>

<!-- SAFE2: SMY seed-sync + SHOT→REAL promotion (type auto; color only if unambiguous) - 2025-10-27T11:10:30 -->
<script>
(function() {
  function copy2d(dst, src) { 
    if(!dst || !src) return;
    for (let i=0; i<Math.min(dst.length, src.length); i++) {
      for (let j=0; j<Math.min(dst[i].length, src[i].length); j++) {
        dst[i][j] = src[i][j];
      }
    }
  }
  function ensure3(s){ 
    s = (s||'').toString(); 
    if (s.length>=3) return s.slice(0,3); 
    return (s+'---').slice(0,3); 
  }

  // === 1) loadFromSeed wrapper: legacy INPUT -> SMY.*_INPUT (név-egységesítés, viselkedés változtatása nélkül) ===
  {
    if (window.loadFromSeed && !window._SMY_wrapped_loadFromSeed) {
      const _orig = window.loadFromSeed;
      window.loadFromSeed = function() {
        const ret = _orig.apply(this, arguments);
        try {
          if (window.SMY) {
            const S = window.SMY;
            if (window.MATRIX_INPUT) copy2d(S.MATRIX_INPUT, window.MATRIX_INPUT);
            if (window.POINTS_INPUT) copy2d(S.POINTS_INPUT, window.POINTS_INPUT);
            if (window.SOROK_INPUT)  for(let i=0;i<Math.min(S.SOROK_INPUT.length, window.SOROK_INPUT.length);i++) S.SOROK_INPUT[i] = window.SOROK_INPUT[i];
            if (window.OSZL_INPUT)   for(let i=0;i<Math.min(S.OSZL_INPUT.length,  window.OSZL_INPUT.length); i++) S.OSZL_INPUT[i]  = window.OSZL_INPUT[i];
            
            
          }
        } catch(e) {  }
        return ret;
      };
      window._SMY_wrapped_loadFromSeed = true;
    }
  }

  // === 2) SHOT→REAL promóciós segédek ===
  window.SMY_promoteCellFromShot = function(r,c) {
    {
      const S = window.SMY; if(!S) return;
      const shot = ensure3(S.M_SHOT[r][c]||'---');
      const t = shot[0], a = shot[1], b = shot[2];
      let cur = ensure3(S.M_REAL[r][c]||'---').split('');
      
      const inp = (S.MATRIX_INPUT && S.MATRIX_INPUT[r]) ? S.MATRIX_INPUT[r][c] : null;
        const sh  = (S.M_SHOT && S.M_SHOT[r]) ? S.M_SHOT[r][c] : null;


      
      if ('ABGD01234HV'.indexOf(t) !== -1) cur[0] = t;

      
      const rowClr = ((S.SOROK_REAL && S.SOROK_REAL[r]) || '-').toUpperCase();
      const colClr = ((S.OSZL_REAL && S.OSZL_REAL[c]) || '-').toUpperCase();
      const isPZ = (x)=> x==='P' || x==='Z';
      const lc = (X)=> (X==='P'?'p': (X==='Z'?'z':'-'));

      
      if (a === b && (a==='p' || a==='z')) {
        
        cur[1] = a; cur[2] = b;
        const up = a.toUpperCase();
        if (up==='P' || up==='Z') {
          if (rowClr !== 'V') S.SOROK_REAL[r] = up;
          if (colClr !== 'V') S.OSZL_REAL[c] = up;
        }
      } else if (b==='-' && (a==='p' || a==='z') && cur[1]==='-' && cur[2]==='-') {
        const shotU = a.toUpperCase(); // 'P' or 'Z'
        const isKnown = (x)=> x==='P' || x==='Z' || x==='V';
        const match = (vec)=> (vec===shotU) || (shotU==='Z' && vec==='V');
        const rowKnown = isKnown(rowClr);
        const colKnown = isKnown(colClr);
        const rowMatch = match(rowClr);
        const colMatch = match(colClr);
        const isWaterT = (x)=> ('01234V'.indexOf(x) !== -1);

        if (!Array.isArray(S.SOROK_REAL)) S.SOROK_REAL = Array(10).fill('-');
        if (!Array.isArray(S.OSZL_REAL))  S.OSZL_REAL  = Array(10).fill('-');

        if (rowKnown && colKnown) {
          if (rowClr !== colClr) {
            if (rowMatch) { cur[2] = a; cur[1] = '-'; }
            else if (colMatch) { cur[1] = a; cur[2] = '-'; }
          }
        } else if (rowKnown && !colKnown) {
          if (!rowMatch) {
            S.OSZL_REAL[c] = (shotU==='Z' && isWaterT(t)) ? 'V' : shotU;
            cur[1] = a; cur[2] = '-';
          }
        } else if (!rowKnown && colKnown) {
          if (!colMatch) {
            S.SOROK_REAL[r] = (shotU==='Z' && isWaterT(t)) ? 'V' : shotU;
            cur[2] = a; cur[1] = '-';
          }
        }
} else if ((a==='p' && b==='z') || (a==='z' && b==='p')) {
        
        
        if (isPZ(rowClr) && !isPZ(colClr)) {
          if (colClr !== 'V') S.OSZL_REAL[c] = (rowClr==='P' ? 'Z' : 'P');
        } else if (!isPZ(rowClr) && isPZ(colClr)) {
          if (rowClr !== 'V') S.SOROK_REAL[r] = (colClr==='P' ? 'Z' : 'P');
        }
        
        let rC = ((S.SOROK_REAL && S.SOROK_REAL[r]) || '-').toUpperCase();
        let cC = ((S.OSZL_REAL && S.OSZL_REAL[c]) || '-').toUpperCase();
		if (rC === 'V') rC='Z'; if (cC === 'V') cC='Z';
        if (isPZ(rC) && isPZ(cC)) {
          cur[1] = lc(cC);
          cur[2] = lc(rC);
        }
      }

      const next = cur.join('');
      S.M_REAL[r][c] = next;

      // HOMOK_REAL / ISHOT_REAL flageket NEM itt piszkáljuk:
      // - kézi LÖVÉS: shoot() ág állítja S.ISHOT_REAL / S.HOMOK_REAL értékeket
      // - HOMOKOZÓ: MUHELYtablaba kezeli a S.HOMOK_REAL / S.ISHOT_REAL értékeket
      // - Automatizmusok (MINDEN AUT) futása közben keletkezett mezők NEM kézi lövések,
      //   ezért a flageket változatlanul hagyjuk; computeLabel ez alapján ismeri fel az AUT mezőket.

      try{ if (window.SMY_autoOrientFromVectors) { window.SMY_autoOrientFromVectors(); if(window.SMY_forceSegmentsRedraw) window.SMY_forceSegmentsRedraw(); } }catch(_e){}

      

    }

  }

// === AUTO: Orient colors from SOROK/OSZL vectors across the whole board ===
    window.SMY_autoOrientFromVectors = function() {
      try {
        const S = window.SMY; if (!S) return 0;
        const N = S.N || 9;
        let applied = 0;
        for (let r=0; r<N; r++)
		{
          for (let c=0; c<N; c++)
		  {
            const shot = ensure3(S.M_SHOT[r][c] || '---');
            if (!(S.ISHOT_REAL && S.ISHOT_REAL[r] && S.ISHOT_REAL[r][c])) continue; // csak tényleges lövésből
            const a = shot[1], b = shot[2];
            if (a==='-' && b==='-') continue; // no color info in SHOT
            let cur = ensure3(S.M_REAL[r][c] || '---').split('');
            const rowClr = ((S.SOROK_REAL && S.SOROK_REAL[r]) || '-').toUpperCase();
            const colClr = ((S.OSZL_REAL && S.OSZL_REAL[c]) || '-').toUpperCase();
            const isPZ = (x)=> x==='P' || x==='Z';
            const lc = (X)=> (X==='P'?'p': (X==='Z'?'z':'-'));
            const bothKnown = (rowClr==='P'||rowClr==='Z'||rowClr==='V') && (colClr==='P'||colClr==='Z'||colClr==='V');
            // equal colors 'pp'/'zz' -> set both lines; also seed vectors if empty
            if (a===b && (a==='p' || a==='z'))
			{
              if (cur[1] !== a || cur[2] !== b)
			  {
                cur[1]=a; cur[2]=b; applied++;
              }
              const up = a.toUpperCase();
              if (up==='P' || up==='Z')
			  {
                if (!isPZ(rowClr)) if (rowClr !== 'V')S.SOROK_REAL[r] = up;
                if (!isPZ(colClr)) if (colClr !== 'V')S.OSZL_REAL[c] = up;
              }
            }
            
            else if ((a==='p' || a==='z') && b==='-' && cur[1]==='-' && cur[2]==='-'){
              const shotU = a.toUpperCase();
              const isKnown = (x)=> x==='P' || x==='Z' || x==='V';
              const match = (vec)=> (vec===shotU) || (shotU==='Z' && vec==='V');
              const rowKnown = isKnown(rowClr);
              const colKnown = isKnown(colClr);
              const rowMatch = match(rowClr);
              const colMatch = match(colClr);
              const isWaterT = (x)=> ('01234V'.indexOf(x) !== -1);
              const t = shot[0];

              if (!Array.isArray(S.SOROK_REAL)) S.SOROK_REAL = Array(N).fill('-');
              if (!Array.isArray(S.OSZL_REAL))  S.OSZL_REAL  = Array(N).fill('-');

              if (rowKnown && colKnown) {
                if (rowClr !== colClr) {
                  if (rowMatch && cur[2] !== a){ cur[2]=a; cur[1]='-'; applied++; }
                  else if (colMatch && cur[1] !== a){ cur[1]=a; cur[2]='-'; applied++; }
                }
              } else if (rowKnown && !colKnown) {
                if (!rowMatch) {
                  S.OSZL_REAL[c] = (shotU==='Z' && isWaterT(t)) ? 'V' : shotU;
                  if (cur[1] !== a){ cur[1]=a; cur[2]='-'; applied++; }
                }
              } else if (!rowKnown && colKnown) {
                if (!colMatch) {
                  S.SOROK_REAL[r] = (shotU==='Z' && isWaterT(t)) ? 'V' : shotU;
                  if (cur[2] !== a){ cur[2]=a; cur[1]='-'; applied++; }
                }
              }
            }
else if ((a==='p' && b==='z') || (a==='z' && b==='p')){
              if (!isPZ(rowClr) && isPZ(colClr)) 
			     if (S.SOROK_REAL[r] !== 'V') S.SOROK_REAL[r] = (colClr==='P' ? 'Z' : 'P');
              if (isPZ(rowClr) && !isPZ(colClr)) 
			     if (S.OSZL_REAL[c] !== 'V') S.OSZL_REAL[c] = (rowClr==='P' ? 'Z' : 'P');
              let rC = ((S.SOROK_REAL && S.SOROK_REAL[r]) || '-').toUpperCase();
              let cC = ((S.OSZL_REAL && S.OSZL_REAL[c]) || '-').toUpperCase();
			  if (rC === 'V') rC='Z'; if (cC === 'V') cC='Z';
              if (isPZ(rC) && isPZ(cC)){
                if (cur[1] !== lc(cC)) { cur[1] = lc(cC); applied++; }
                if (cur[2] !== lc(rC)) { cur[2] = lc(rC); applied++; }
              }
            }
            const next = cur.join('');
            if (next !== S.M_REAL[r][c])
			{
              S.M_REAL[r][c] = next;
              
              { if (window.SMY_autoOrientFromVectors) { window.SMY_autoOrientFromVectors(); 
	          if(window.SMY_forceSegmentsRedraw) window.SMY_forceSegmentsRedraw(); } }
               
              {  }
            }
          }
        }
		
		
		for (let r=0; r<N; r++)
		  if (S.SOROK_REAL[r] === 'V')
          for (let c=0; c<N; c++) S.M_REAL[r][c][2] = 'z';
		  
		for (let c=0; c<N; c++)
		  if (S.OSZL_REAL[c] === 'V')
          for (let r=0; r<N; r++) S.M_REAL[r][c][1] = 'z';  
		
        if (window.SMY_forceSegmentsRedraw) window.SMY_forceSegmentsRedraw();
return applied;
      } catch(e){  return -1; }
    };
;;

  // === 3) setCellShip / setCellWater monkey-patch: M_SHOT rögzítés + promóció meghívás ===
  {
    
    if (window.setCellShip && !window._SMY_wrapped_setCellShip) {
      const _origShip = window.setCellShip;
      window.setCellShip = function(r,c,code,subTxt) {
        const ret = _origShip.apply(this, arguments);
        try {
          const S = window.SMY; if(!S || window._PAINT_ONLY) return ret;
          const type = (code && typeof code==='string' && code[0]) ? code[0] : '?';
          const s = (typeof subTxt==='string') ? subTxt.trim().toLowerCase() : '';
let c2='-', c3='-';
if (s.length===2 && /^[pzx]{2}$/.test(s)) { c2 = s[0]; c3 = s[1]; }
else if (s.length===1 && /^[pzx]$/.test(s)) { c2 = s[0]; c3 = '-'; }
const prevShot1 = (S.M_SHOT && S.M_SHOT[r]) ? S.M_SHOT[r][c] : '---';
let candShot1 = ensure3(type + c2 + c3);

if (type === 'G' &&
    typeof prevShot1 === 'string' &&
    prevShot1.charAt(0) === 'G' &&
    prevShot1.substring(1) !== '--' &&                
    candShot1.substring(1) === '--') {
  candShot1 = prevShot1;
}
S.M_SHOT[r][c] = candShot1;  

          window.SMY_promoteCellFromShot(r,c);
        } catch(e) {  }
        return ret;
      };
      window._SMY_wrapped_setCellShip = true;
    }

    
    if (window.setCellWater && !window._SMY_wrapped_setCellWater) {
      const _origWater = window.setCellWater;
      window.setCellWater = function(r,c,numTxt,subTxt) {
        const ret = _origWater.apply(this, arguments);
        try {
          const S = window.SMY; if(!S || window._PAINT_ONLY) return ret;
          const tStr = (numTxt==null ? '0' : String(numTxt));
          const type = tStr && tStr[0] ? tStr[0] : '0';
          const s = (typeof subTxt==='string') ? subTxt.trim().toLowerCase() : '';
let c2='-', c3='-';
if (s.length===2 && /^[pzx]{2}$/.test(s)) { c2 = s[0]; c3 = s[1]; }
else if (s.length===1 && /^[pzx]$/.test(s)) { c2 = s[0]; c3 = '-'; }
S.M_SHOT[r][c] = ensure3(type + c2 + c3);

          
          window.SMY_promoteCellFromShot(r,c);
        } catch(e) {  }
        return ret;
      };
      window._SMY_wrapped_setCellWater = true;
    }
  }

})();
</script>

<!-- SAFE2-INPUT2SHOT-FIX: Strict INPUT→SHOT copy (no color normalization). (2025-10-27T12:23:50) -->
<script>
(function(){
  function strictCopyInputToShot(){ 
    {
      const S = window.SMY || (window.SMY={});
      // Prefer SMY.MATRIX_INPUT; fallback to legacy globals
      const mat = (S.MATRIX_INPUT && Array.isArray(S.MATRIX_INPUT) && S.MATRIX_INPUT) ||
                  (window.MATRIX_INPUT && Array.isArray(window.MATRIX_INPUT) && window.MATRIX_INPUT) ||
                  (window.MATRIX && Array.isArray(window.MATRIX) && window.MATRIX) || null;
      if(!mat) {  return; }
      const N = mat.length;
      if(!S.M_SHOT || !Array.isArray(S.M_SHOT) || S.M_SHOT.length!==N) {
        S.M_SHOT = Array.from({length:N}, ()=>Array(N).fill('---'));
      }
      for(let r=0;r<N;r++) {
        for(let c=0;c<N;c++) {
          const tok = (mat[r] && typeof mat[r][c]==='string') ? mat[r][c] : '---';
          
          S.M_SHOT[r][c] = (tok + '---').slice(0,3);

        }
      }
      
    }
  }

  // Wrap loadFromSeed (SAFE2-ben már létezik), és loadFromSeedText ha van
  {
    if(window.loadFromSeed && !window._I2S_fix_wrap_lfs) {
      const _orig = window.loadFromSeed;
      window.loadFromSeed = function() {
        const ret = _orig.apply(this, arguments);
        strictCopyInputToShot();
        return ret;
      };
      window._I2S_fix_wrap_lfs = true;
    }
  }

  {
    if(window.loadFromSeedText && !window._I2S_fix_wrap_lfst) {
      const _orig = window.loadFromSeedText;
      window.loadFromSeedText = function(raw) {
        const ret = _orig.apply(this, arguments);
        strictCopyInputToShot();
        return ret;
      };
      window._I2S_fix_wrap_lfst = true;
    }
  }

  
  strictCopyInputToShot();
})();
</script>

<!-- SAFE4: Csak inicializálás - nincs auto INPUT→SHOT, nincs auto SHOT→REAL. (2025-10-27T13:00:02) -->
<script>
(function(){ 'use strict';
  function initAll(){ 
    {
      const S = window.SMY || (window.SMY = {});
      const N = (S.CFG && S.CFG.N) || 9;
      const P = N;
      const fill2d = (r,c,v) => Array.from({length:r},()=>Array.from({length:c},()=>v));
      const fill1d = (n,v) => Array.from({length:n},()=>v);
      S.M_SHOT = fill2d(N,N,'---');
      S.M_REAL = fill2d(N,N,'---');
      S.P_SHOT = fill2d(N,N,'-');
      S.P_REAL = fill2d(N,N,'-');
      S.SOROK_REAL = fill1d(N,'-');
      S.OSZL_REAL  = fill1d(N,'-');
      S.KERET_REAL = fill2d(N,N,'-');
// STEP1: SNAP globals (declarations only)





  var r=0,c=0;

  if (typeof S.M_SNAP === 'undefined'){ S.M_SNAP = new Array(N); for(r=0;r<N;r++){ S.M_SNAP[r] = new Array(N); } }
  if (typeof S.P_SNAP === 'undefined'){ S.P_SNAP = new Array(N); for(r=0;r<N;r++){ S.P_SNAP[r] = new Array(N); } }

  if (typeof S.SOROK_SNAP === 'undefined'){ S.SOROK_SNAP = new Array(S.SOROK_REAL ? S.SOROK_REAL.length : N); }
  if (typeof S.OSZL_SNAP  === 'undefined'){ S.OSZL_SNAP  = new Array(S.OSZL_REAL  ? S.OSZL_REAL.length  : N); }

  if (S.KERET_REAL && typeof S.KERET_SNAP === 'undefined'){
    S.KERET_SNAP = new Array(S.KERET_REAL.length);
    for(r=0;r<S.KERET_REAL.length;r++){ S.KERET_SNAP[r] = new Array(S.KERET_REAL[0].length); }
  }

  if (typeof S.workM_SNAP === 'undefined'){ S.workM_SNAP = new Array(N); for(r=0;r<N;r++){ S.workM_SNAP[r] = new Array(N); } }
  if (typeof S.workP_SNAP === 'undefined'){ S.workP_SNAP = new Array(N); for(r=0;r<N;r++){ S.workP_SNAP[r] = new Array(N); } }
  
  if (typeof S.nMM === 'undefined')  S.nMM = 0;
  if (typeof S.nPP === 'undefined')  S.nPP = 0;
  if (typeof S.nMVP === 'undefined') S.nMVP = 0;
  if (typeof S.nVP === 'undefined')  S.nVP = 0;

  if (typeof S.nMS === 'undefined'){ S.nMS = new Array(N); for(r=0;r<N;r++){ S.nMS[r] = 0; } }
  if (typeof S.nMO === 'undefined'){ S.nMO = new Array(N); for(r=0;r<N;r++){ S.nMO[r] = 0; } }

  if (typeof S.nMS_SNAP === 'undefined'){ S.nMS_SNAP = new Array(N); }
  if (typeof S.nMO_SNAP === 'undefined'){ S.nMO_SNAP = new Array(N); }


  // Munkamásolatok (mindig létezzenek) + induláskor szinkron a REAL-lal
  if (typeof S.workM === 'undefined'){ S.workM = new Array(N); for(r=0;r<N;r++){ S.workM[r] = new Array(N); } }
  if (typeof S.workP === 'undefined'){ S.workP = new Array(N); for(r=0;r<N;r++){ S.workP[r] = new Array(N); } }
  for(r=0;r<N;r++){ for(c=0;c<N;c++){ S.workM[r][c] = S.M_REAL ? S.M_REAL[r][c] : S.workM[r][c]; } }
  for(r=0;r<N;r++){ for(c=0;c<N;c++){ S.workP[r][c] = S.P_REAL ? S.P_REAL[r][c] : S.workP[r][c]; } }


  if (typeof S.nMM_SNAP  === 'undefined'){ S.nMM_SNAP  = S.nMM; }
  if (typeof S.nPP_SNAP  === 'undefined'){ S.nPP_SNAP  = S.nPP; }
  if (typeof S.nMVP_SNAP === 'undefined'){ S.nMVP_SNAP = S.nMVP; }
  if (typeof S.nVP_SNAP  === 'undefined'){ S.nVP_SNAP  = S.nVP; }

  if (typeof S.nMS_SNAP === 'undefined'){
    var nMSlen = (S.nMS && S.nMS.length) ? S.nMS.length : N;
    S.nMS_SNAP = new Array(nMSlen);
  }
  if (typeof S.nMO_SNAP === 'undefined'){
    var nMOlen = (S.nMO && S.nMO.length) ? S.nMO.length : N;
    S.nMO_SNAP = new Array(nMOlen);
  }

  if (typeof S.CFG_SNAP === 'undefined'){ S.CFG_SNAP = {}; }

  var k;
  for (k in S){
    if (k && k.indexOf('CONF_') === 0 && typeof S[k] !== 'function'){
      var sn = k + '_SNAP';
      if (typeof S[sn] === 'undefined'){ S[sn] = S[k]; }
    }
  }


      if(!S.COUNTS) S.COUNTS = {};
      S.COUNTS.shots = 0; S.COUNTS.deducedCells=0; S.COUNTS.deducedPoints=0;
      
    }
  }

  
  initAll();

  // 2) Seed betöltés UTÁN csak inicializálunk (nem másolunk semmit)
  { 
    if(window.loadFromSeed && !window._SAFE4_wrap_lfs){ 
      const _orig = window.loadFromSeed;
      window.loadFromSeed = function(){
        const ret = _orig.apply(this, arguments);
        return ret;
      };
      window._SAFE4_wrap_lfs = true;
    }
  }
  // (SAFE4) seed után nincs auto másolás; csak inicializálás történt.
})();
</script>

<!-- SAFE5: Interaktív írás bekötése - közvetlen SHOT→REAL a megadott cellán. (2025-10-27T13:04:46) -->
<script>
(function(){ 'use strict';
  function tok3(T, sub){
    // T: type char; sub: color text as given by UI (e.g., 'pp','z','x','zp','pz','')
    T = (T||'-').toString().toUpperCase().slice(0,1);
    const s = (typeof sub==='string') ? sub.trim().toLowerCase() : '';
    let c2='-', c3='-';
    if (/^[pzx]{2}$/.test(s)) {
      c2 = s[0]; c3 = s[1];
    } else if (/^[pzx]$/.test(s)) {
      c2 = s[0]; c3 = '-';
    }
    return (T + c2 + c3).slice(0,3);
  }
  function promoteOne(S, r, c){
    
    const shot = (S.M_SHOT && S.M_SHOT[r] && S.M_SHOT[r][c]) ? S.M_SHOT[r][c] : '---';
    const t = shot[0], a = shot[1], b = shot[2];
    if (!S.M_REAL || !S.M_REAL[r]) return;
    const cur = (S.M_REAL[r][c]||'---').split('');
    if (/^[ABGD0-4]$/.test(t)) cur[0] = t;
    if ((a==='p' && b==='p') || (a==='z' && b==='z') || a==='x' || b==='x') {
      const isX = (a==='x' || b==='x');
      cur[1] = isX ? 'x' : a;
      cur[2] = isX ? 'x' : b;
    }
    S.M_REAL[r][c] = cur.join('');
  }
  function setShotAndPromote(r,c,T,subTxt){
    const S = window.SMY; if(!S) return;
    if (!S.M_SHOT || !S.M_SHOT[r]) return;
    const prevShot4 = S.M_SHOT[r][c];
    let candShot4 = tok3(T, subTxt);
    
    // akkor tartsuk meg a régi SHOT-ot.
  /*  if (T === 'G' &&
        typeof prevShot4 === 'string' &&
        prevShot4.charAt(0) === 'G' &&
        prevShot4.substring(1) !== '--' &&
        candShot4.substring(1) === '--') {
      candShot4 = prevShot4;
    }*/
    S.M_SHOT[r][c] = candShot4;

    promoteOne(S, r, c);
  }

  
  {
    if (window.setCellShip && !window._SAFE5_wrap_ship) {
      const _orig = window.setCellShip;
      window.setCellShip = function(r,c,code,subTxt){
        const ret = _orig.apply(this, arguments);
        try { 
          if (window._PAINT_ONLY) return ret;
          const T = (code && typeof code==='string') ? code[0] : '-';
          if(window._PAINT_ONLY){  return ret; }
          setShotAndPromote(r,c,T,subTxt);
        } catch(_ ){}
        return ret;
      };
      window._SAFE5_wrap_ship = true;
    }
  }

  {
    if (window.setCellWater && !window._SAFE5_wrap_water) {
      const _orig = window.setCellWater;
      window.setCellWater = function(r,c,numTxt,subTxt){
        const ret = _orig.apply(this, arguments);
        try {
          if (window._PAINT_ONLY) return ret;
          const T = (numTxt==null ? 'V' : String(numTxt))[0] || 'V';
          if(window._PAINT_ONLY){  return ret; }
          setShotAndPromote(r,c,T,subTxt);
        } catch(_ ){}
        return ret;
      };
      window._SAFE5_wrap_water = true;
    }
  }

  
})();
</script>


<script>
(function(){ 'use strict';
  function ensure3(s){ s=(s||'').toString(); return (s+'---').slice(0,3); }
  {
    const _ensure = (typeof window.ensureSegLayer==='function') ? window.ensureSegLayer : null;
    const _colorFromCode = (typeof window.colorFromCode==='function') ? window.colorFromCode : function(ch){
      const m = (window.RC_CONF && RC_CONF.colorMap) ? RC_CONF.colorMap : {p:'#e53935', z:'#43a047', x:'#fdd835'};
      return m[ch] || null;
    };
    window.drawSegmentsFromRealCell = function(r,c){
      try {
        const S = window.SMY; if(!S || !S.M_REAL || !S.M_REAL[r]) return;
        const rc = ensure3(S.M_REAL[r][c] || '---');
        const layers = _ensure ? _ensure(r,c) : null; if(!layers) return;
        const colV = _colorFromCode(rc.charAt(1));
        const colH = _colorFromCode(rc.charAt(2));
        const tV = (window.RC_CONF && RC_CONF.thickness && (RC_CONF.thickness.v|0)) || 5;
        const tH = (window.RC_CONF && RC_CONF.thickness && (RC_CONF.thickness.h|0)) || 5;
        if(colV){ layers.v.style.color = colV; layers.v.style.width = tV + 'px'; layers.v.style.display='block'; } else { layers.v.style.display='none'; }
        if(colH){ layers.h.style.color = colH; layers.h.style.height = tH + 'px'; layers.h.style.display='block'; } else { layers.h.style.display='none'; }
      } catch(e) {  }
    };
    
  }
})();
</script>

<!-- Minimal drawer from SMY.M_REAL; no workM, no wrappers -->
<script>

if(false){

(function(){
  if (typeof window.drawSegmentsFromRealCell !== 'function') {
    window.drawSegmentsFromRealCell = function(r,c){
  {
    var S = window.SMY || {};
    var rc = (S.M_REAL && S.M_REAL[r] && typeof S.M_REAL[r][c] === 'string') ? S.M_REAL[r][c] : '---';
    var v = (rc.length>=2 ? rc.charAt(1).toLowerCase() : '-'); // VERTICAL  ← OSZL_REAL
    var h = (rc.length>=3 ? rc.charAt(2).toLowerCase() : '-'); // HORIZONTAL ← SOROK_REAL

    var ensure = (typeof ensureSegLayer1 === 'function') ? ensureSegLayer1
               : (typeof ensureSegLayer  === 'function') ? ensureSegLayer
               : null;
    if(!ensure) return;
    var L = ensure(r,c); if(!L) return;

    function toColor(ch){
      if(ch==='p') return '#08f';
      if(ch==='z') return '#f08';
      if(ch==='x') return '#aaa';
      return null;
    }
    var colV = toColor(v);
    var colH = toColor(h);

    
    if(L.v){
      if(!L.v._stripe){
        var s=document.createElement('div');
        s.style.position='absolute'; s.style.top='2px'; s.style.bottom='2px'; s.style.left='50%'; s.style.width='0';
        s.style.borderLeft='3px solid transparent'; s.style.transform='translateX(-1px)';
        L.v.appendChild(s); L.v._stripe=s;
      }
      L.v._stripe.style.borderLeftColor = colV || 'transparent';
      L.v.style.display = colV ? 'block' : 'none';
    }

    
    if(L.h){
      if(!L.h._stripe){
        var s=document.createElement('div');
        s.style.position='absolute'; s.style.left='2px'; s.style.right='2px'; s.style.top='50%'; s.style.height='0';
        s.style.borderTop='3px solid transparent'; s.style.transform='translateY(-1px)';
        L.h.appendChild(s); L.h._stripe=s;
      }
      L.h._stripe.style.borderTopColor = colH || 'transparent';
      L.h.style.display = colH ? 'block' : 'none';
    }

    if(L.code) L.code.textContent = rc;
  }
};;
  }
  window.__repaintFromReal_viaSetCell = function(){
    {
      if (!window.SMY || !SMY.M_REAL) return;
      for (var r=0; r<SMY.M_REAL.length; r++){
        for (var c=0; c<SMY.M_REAL[r].length; c++){
          var rc = SMY.M_REAL[r][c] || '---';
          var T = rc.charAt ? rc.charAt(0) : '-';
          var cc = (rc.length>=3) ? rc.slice(1,3) : '--';
          if (T === '-') continue;
          if (T === '0') {
            if (typeof setCellWater === 'function') setCellWater(r,c);
          } else {
            if (typeof setCellShip === 'function') setCellShip(r,c,T,cc);
          }
        }
      }
    }
  };
})();

}

</script>


<script>
(function(){
  if (!window.SMY_forceSegmentsRedraw){
    window.SMY_forceSegmentsRedraw = function(){
      {
        if (!window.SMY || !SMY.N) return;
        if (typeof window.drawSegmentsFromRealCell !== 'function') return;
        const N = SMY.N || 9;
        for (let r=0;r<N;r++){
          for (let c=0;c<N;c++){
            window.drawSegmentsFromRealCell(r,c);
          }
        }
      }
    };
  }
})();
</script>


<script id="AUTO_REDRAW_PASS">

(function(){
    if (!window.SMY) return;
    const S0 = window.SMY;
    const N0 = S0.N || 9;

    function ensure3(s){
        s = (s || '').toString();
        return (s + '---').slice(0, 3);
    }

    
    
    
    function redrawFromRealAll(){
	
        {
            if (typeof window.__redrawSimpleStrict === 'function'){
                window.__redrawSimpleStrict();
                return;
            }
        }
        {
            const S = window.SMY;
            if (!S || !S.M_REAL) return;
            const N = S.N || 9;

            
            if (typeof buildEmptyBoard === 'function'){
                buildEmptyBoard();
            }

            
            // 1. CELLÁK KIRAJZOLÁSA REAL alapján
            
            for (let r = 0; r < N; r++){ 
                for (let c = 0; c < N; c++){
                    const rc = ensure3(S.M_REAL[r][c]);
                    const T  = rc.charAt(0);     
                    const CC = rc.slice(1, 3);   

                    
					if ( !( r===0 && (c===0 || c===N-1) || r===N-1 && (c===0 || c===N-1))) 
					{ 
                    if (T === '-'){
                        setCellReset(r, c, '-', CC);
                    }
                    else if ((T >= '0' && T <= '4') || T === 'V'){
                        setCellWater(r, c, T, CC);
                    }
                    else if (T === 'A' || T === 'B' || T === 'G' || T === 'D' || T === 'H'){
                        setCellShip(r, c, T, CC);
                    }
                    else{
                        setCellReset(r, c, '-', CC);
                    }
					}  

                    
                    
                    
                    try {
                        if (typeof window.drawSegmentsFromRealCell === 'function'){
                            window.drawSegmentsFromRealCell(r, c);
                        }
                    } catch(_){}      
                }
            }
	
            
            
            
            try {
                if (typeof drawPointsOverlay === 'function'){
                    drawPointsOverlay();
                }
            } catch(_){} 
            
        }
    }

    
    
    
    window.redrawFromRealAll = redrawFromRealAll;

    
    
    
    {
        const btn = document.getElementById('btnRedrawReal');
        if (btn){
            btn.addEventListener('click', function(ev){
                var __trusted = !!(ev && ev.isTrusted);
                var __savedCycle = (typeof redrawLabelCycle !== 'undefined') ? redrawLabelCycle : 0;

                // Csak kézi (trusted) kattintás lépteti a kirajzolási ciklust
                if (__trusted && (typeof redrawLabelCycle !== 'undefined')){
                    var mode = (typeof getViewModeForRedraw === 'function') ? getViewModeForRedraw() :
                               ((typeof EdJaMode !== 'undefined') ? EdJaMode : '');
                    if (mode === 'halado'){
                        // Játék: 2 fázis
                        redrawLabelCycle = (redrawLabelCycle + 1) % 2;
                    } else {
                        // Edzés: 3 fázis
                        redrawLabelCycle = (redrawLabelCycle + 1) % 3;
                    }
                }

                if (window.mergeRealAndWorkTypes) window.mergeRealAndWorkTypes();
                if (window.SMY_hardResetView) window.SMY_hardResetView();
                redrawFromRealAll();

                // Programból hívott redraw (LÖVÉS/HOMOK/AUT) esetén ne változzon a ciklus
                if (!__trusted){
                    try { if (typeof redrawLabelCycle !== 'undefined') redrawLabelCycle = __savedCycle; } catch(_){ }
                }
            });
        }
    }

})();  

</script>
<!-- PATCH_1102F START: Pre-Shot Ring (persistent) -->
<style>
  .preShotRing{
    position:absolute;
    pointer-events:none;
    border:2px solid rgba(80,160,255,0.9);
    border-radius:10px;
    box-shadow:0 0 0 2px rgba(80,160,255,0.25) inset;
    display:none;
    z-index: 9999;
  }
</style>
<script>
(function(){
  if(window.__PATCH_1102F__) return; window.__PATCH_1102F__=true;
  var ring=null, lockedRC=null;
  function ensureRing(){
    if(!ring){
      ring=document.createElement('div');
      ring.className='preShotRing';
      document.body.appendChild(ring);
    }
    return ring;
  }
  function cellRectByRC(r,c){
    var el=document.querySelector('.cell[data-r="'+r+'"][data-c="'+c+'"], [data-r="'+r+'"][data-c="'+c+'"]');
    if(!el) return null;
    var rc=el.getBoundingClientRect(), bc=document.body.getBoundingClientRect();
    return {left:rc.left-bc.left+1, top:rc.top-bc.top+1, w:rc.width-2, h:rc.height-2};
  }
  function showPreShotAt(r,c){
    var cr=cellRectByRC(r,c); if(!cr){ hidePreShot(true); return; }
    var d=ensureRing();
    d.style.left=cr.left+'px'; d.style.top=cr.top+'px';
    d.style.width=cr.w+'px';  d.style.height=cr.h+'px';
    d.style.display='block';
  }
  function hidePreShot(force){
    if(lockedRC && !force) return;
    if(ring) ring.style.display='none';
    lockedRC=null;
  }
  window.hidePreShot = hidePreShot;
  
  document.addEventListener('mouseover', function(ev){
    if(lockedRC) return;
    var cell=ev.target && ev.target.closest ? ev.target.closest('[data-r][data-c]') : null;
    if(!cell) return;
    var r=+cell.getAttribute('data-r'), c=+cell.getAttribute('data-c');
    if(Number.isFinite(r)&&Number.isFinite(c)) showPreShotAt(r,c);
  }, true);
  document.addEventListener('mouseout', function(ev){
    if(lockedRC) return;
    var cell=ev.target && ev.target.closest ? ev.target.closest('[data-r][data-c]') : null;
    if(cell) hidePreShot();
  }, true);
  
  document.addEventListener('click', function(ev){
    var cell=ev.target && ev.target.closest ? ev.target.closest('[data-r][data-c]') : null;
    if(!cell) return;
    var r=+cell.getAttribute('data-r'), c=+cell.getAttribute('data-c');
    if(Number.isFinite(r)&&Number.isFinite(c)){ lockedRC={r:r,c:c}; showPreShotAt(r,c); }
  }, true);
  // Index input: "cr" → lock
  function parseIdx(v){ v=String(v||'').trim(); if(!/^[1-9]{2}$/.test(v)) return null; return {c:+v[0]-1, r:+v[1]-1}; }
  var idx=document.getElementById('indexInput')||document.querySelector('input[id*="index" i], input[name*="index" i]');
  if(idx){
    var update=function(){ var rc=parseIdx(idx.value); if(rc){ lockedRC={r:rc.r,c:rc.c}; showPreShotAt(rc.r,rc.c); } else hidePreShot(); };
    idx.addEventListener('input', update);
    idx.addEventListener('change', update);
    idx.addEventListener('keydown', function(e){ if(e.key==='Enter') hidePreShot(true); }, true);
  }
  
  (function(){
    var orig=window.shoot;
    if(typeof orig==='function'){
      window.shoot=function(){ hidePreShot(true); return orig.apply(this, arguments); };
    }
    var btn=document.getElementById('shootBtn')||document.querySelector('[data-action="shoot"], button[id*="shoot" i]');
    if(btn){ btn.addEventListener('click', function(){ hidePreShot(true); }, true); }
  })();
})();
</script>

<script>
// === REDRAW (egységes, M_REAL / MATRIX_INPUT alapú) ===
// Nincs proxy, nincs extra állapot, csak M_REAL + MATRIX_INPUT + M_SHOT → nézet.

(function(){
  function ensure3(s){
    s = (s || '').toString();
    return (s + '---').slice(0, 3);
  }

  function splitToken(t){
    const tok = ensure3(t || '---');
    const T   = tok.charAt(0);
    const c2  = tok.charAt(1);
    const c3  = tok.charAt(2);
	
    let cc = '';
    if (c2 !== '-') cc += c2;
    if (c3 !== '-') cc += c3;
    return { T, cc, raw: tok };
  }

  function getViewModeForRedraw(){
    const elHal = document.getElementById('mode_halado');
    return (elHal && elHal.checked) ? 'halado' : 'kezdo';
	
  }

  

// - FELADATA: egy cellára (r,c) meghatározza a tábla fő betűjét (main)


//     MI    → MATRIX_INPUT   (eredeti rejtvény)
//     MSHOT → M_SHOT         (lövés utáni, játék közbeni állapot)
//     MR    → M_REAL         (eddig kiderített „valós” állapot)

// - KERESÉS: "REDRAW_MAIN_LABEL" vagy "computeLabel(r,c, mode, MI, MSHOT, MR)".

function normalizeColor(cc){
  const s = String(cc || '').toLowerCase();
  if (!s) return '';

  
  if (s === 'pp' || s === 'zz' || s === 'pz' || s === 'zp'){
    return s;
  }

  const hasP = s.indexOf('p') !== -1;
  const hasZ = s.indexOf('z') !== -1;
  const hasX = s.indexOf('x') !== -1;

  
  if (hasP && !hasZ){if (hasP) void 0;
    return 'p';
  }

  
  if (hasZ && !hasP){if (hasZ) void 0;
    return 'z';
  }

  // Ha van benne 'x' (és nincs erősebb p/z szabály) → x   (xx, ?x, x?, x)
  if (hasX){ 
    return 'x';   
  }

  
  if (/^[\-\?]+$/.test(s)){ 
    return '-';
  }

  
  return '-';
}


function computeLabel(r,c, mode, MI, MSHOT, MR)
{
  
   const phase = redrawLabelCycle;
     // HOMOK flag (globálisból)
   let homok = false;
   let ishott= false
  
   const S = window.SMY || window.S || null;
   if (S && S.HOMOK_REAL && S.HOMOK_REAL[r]){ homok  = S.HOMOK_REAL[r][c]; }
   if (S && S.ISHOT_REAL && S.ISHOT_REAL[r]){ ishott = S.ISHOT_REAL[r][c]; }
 
  
   
   const inpTok   = ensure3(ishott ? MATRIX[r][c] : '---');
   const shotTok  = (MSHOT && MSHOT[r]) ? ensure3(MSHOT[r][c]) : '---';
   const realTok  = (MR    && MR[r])    ? ensure3(MR[r][c])    : '---';
   
/*  const inpTok   = MI[r][c];
  const shotTok  = MSHOT[r][c];
  const realTok  = MR[r][c];  */

  const inp  = splitToken(inpTok);
  const shot = splitToken(shotTok);
  const real = splitToken(realTok);

  

  const hasShot = !!ishott;
  const hasReal = (realTok !== '---');
  const isAuto = (!homok && !ishott && hasReal);
  
     // Helper: REAL / INPUT / NONE választása
    const useReal = function(){
      if (hasReal){
        main = real.T;
        sub  = normalizeColor(real.cc);
      } else if (inpTok !== '---'){
        main = inp.T;
        const sIn = String(inp.cc || '').toLowerCase();
        if (sIn.indexOf('x') !== -1) sub = 'x'; else sub = normalizeColor(inp.cc);
      } else {
        main = '';
        sub  = '';
      }
    };
    const useInput = function(){
      if (inpTok !== '---'){
        main = inp.T;
        const sIn = String(inp.cc || '').toLowerCase();
        if (sIn.indexOf('x') !== -1) { 
          sub = 'x';
        } else {
          sub = normalizeColor(inp.cc);
        }
      } else if (hasReal){
        main = real.T;
        sub  = normalizeColor(real.cc);
      } else {
        main = '';
        sub  = '';
      }
    };
    const useNone = function(){
      main = '';
      sub  = '';
    };


  
// Négy mezőtípus: üres, MEGLŐTT, AUTOMATIZMUS, HOMOKOZÓ
{
  const S3 = window.SMY || window.S || null;
  
  
  
  const nonEmpty = (inpTok !== '---' || realTok !== '---');
  const isShot   = !!ishott;
  const isHomok  = !!homok;
  const isAuto   = nonEmpty && !isShot && !isHomok;

  
  if (!nonEmpty){
    main = '';
    sub  = '';
  } 
  else if (mode === 'kezdo')
  {
    // Edzés / Kezdő – 3 fázis
  //  const phase = ((raw % 3) + 3) % 3; // 0,1,2
 //   const phase = raw; // 0,1,2
void 0;
 
    if (isShot){
      // MEGLŐTT: M_REAL/INPUT >> M_REAL - M_REAL - INPUT
      if (phase === 0 || phase === 1){
        useReal();  
      } else {
        useInput();  
      }
    } else if (isHomok){
      // HOMOKOZÓ: mindig M_REAL >> M_REAL - M_REAL - M_REAL
      useReal();  
    } else if (isAuto){
      // AUTOMATIZMUS M_REAL/INPUT >> M_REAL - INPUT - M_REAL (3. érték kiegészítve)
      if (phase === 0){
        useNone();  
      } else if (phase === 1){
        useReal();  
      } else {
        useInput();  
      }
    } else {
      
      useNone();   
    }

  } 
  else if (mode === 'halado')
  {
    // Játék / Haladó – 2 fázis
 //   const phase = raw; // 0 vagy 1
 //	const phase = ((raw % 2) + 2) % 2; // 0 vagy 1
void 0;

    if (isShot){
      // MEGLŐTT: Játékban két állapot:
      //   D: REAL (eddig kiderített „valós” állapot)
      //   E: INPUT = a meglőtt mező azonnali „lövés” szerinti képe (MSHOT)
      if (phase === 0){
        
        useReal(); 
      } else 
	  {
        // E állapot: SHOT-ból rajzolunk, ha van; különben visszaesünk REAL-ra
      /*  if (shotTok !== '---')
		{
          main = shot.T;
          sub  = normalizeColor(shot.cc);
        } */
		/*if (shotTok !== '---')*/
		{
          useInput();   
        } 
		/*else 
		{
          useReal();
        }*/
      }
    } else if (isHomok){
      // HOMOKOZÓ: M_REAL >> M_REAL - M_REAL
      useReal();
    } else if (isAuto){
      // AUTOMATIZMUS M_REAL/INPUT >> M_REAL - ---
      if (phase === 0){
        useReal();
      } else {
        useNone();
      }
    } else {
      useNone();
    }
  }
}

  // JÁTÉK (haladó) módban csak a meglőtt vagy HOMOK-mezőkön legyen felirat
  if (mode === 'halado' && !ishott && !homok){
    main = '';
    sub  = '';
  }

  return { main, sub, isAuto, homok, ishott, hasReal, hasShot };
}

function isCorner(r,c,N){
  return (r === 0 && c === 0) ||
         (r === 0 && c === N-1) ||
         (r === N-1 && c === 0) ||
         (r === N-1 && c === N-1);
}

function redrawSimpleStrict(){
  const S   = window.SMY || window.S || {};
  const MR  = S.M_REAL;
  if (!MR) return;
  const N   = S.N || (MR.length|0) || 9;
  const MI  = S.MATRIX_INPUT;
  const MS  = S.M_SHOT;
  EdJaMode = getViewModeForRedraw();
  const mode = EdJaMode; 

  const prevPaint = window._PAINT_ONLY;
  window._PAINT_ONLY = true;
  try{
    for (let r=0; r<N; r++){
      for (let c=0; c<N; c++){
        const realTok = (MR[r] ? ensure3(MR[r][c]) : '---');
        const T       = realTok.charAt(0);

        
        if (isCorner(r,c,N)){
          if (typeof setCellWater === 'function'){
            setCellWater(r, c, '', '');
          } else if (typeof setCellReset === 'function'){
            setCellReset(r, c, '-', '');
          }
          if (typeof window.drawSegmentsFromRealCell === 'function'){
            window.drawSegmentsFromRealCell(r,c);
          }
          continue;
        }

        const lbl  = computeLabel(r,c, mode, MI, MS, MR);
        const isAuto = !!(lbl && lbl.isAuto);
        let main   = (lbl && lbl.main) ? lbl.main : '';
        let sub    = (lbl && lbl.sub)  ? lbl.sub  : '';
         

       
        if (T === '-'){
          if (typeof setCellReset === 'function'){
            setCellReset(r, c, main, sub);
          }
        }
        else if ((T >= '0' && T <= '4') || T === 'V'){
          if (typeof setCellWater === 'function'){
            setCellWater(r, c, main, sub);
          }
        }
        else if (T === 'A' || T === 'B' || T === 'G' || T === 'D' || T === 'H'){
          if (typeof setCellShip === 'function'){
            setCellShip(r, c, main, sub);
          }
        }
        else{
          if (typeof setCellReset === 'function'){
            setCellReset(r, c, main, sub);
          }
        }

        if (typeof window.drawSegmentsFromRealCell === 'function'){
          window.drawSegmentsFromRealCell(r,c);
        }
      }
    }
  } finally {
    window._PAINT_ONLY = prevPaint;
  }

  {
    if (typeof drawPointsOverlay === 'function'){
      drawPointsOverlay();
    }
  }}window.__redrawSimpleStrict = redrawSimpleStrict;
  const btn = document.getElementById('btnRedrawReal');
  if (btn){
    btn.onclick = null;
    btn.addEventListener('click', redrawSimpleStrict);
  }
})();
</script>

<script id="AUTO_FUNCS_1104">
(function(){
  {
    const N = (typeof window.N==='number') ? window.N : 9;

    function getWorkM(){ return (typeof window.workM!=='undefined') ? window.workM : null; }
    function getWorkP(){ return (typeof workP!=='undefined') ? workP : null; }
    function isWaterCell(obj){ return obj && obj.kind==='water' && typeof obj.main==='string' && /^[0-4V]$/.test(obj.main); }
    function isShipCell(obj){ return obj && obj.kind==='ship' && typeof obj.main==='string' && /^[ABGD]$/.test(obj.main); }

    function safeSetPoint(r,c,val){
      const P = getWorkP(); if(!P) return;
      const PR = P.length;
      const PC = PR ? P[0].length : 0;
      if(r<0||c<0||r>=PR||c>=PC) return;

      
      if ((r === 0 && c === 0) ||
          (r === 0 && c === PC-1) ||
          (r === PR-1 && c === 0) ||
          (r === PR-1 && c === PC-1)) return;

      const cur = P[r][c];
      if(cur===val) return;
      if(cur===undefined || cur===null || cur==='-'){
        P[r][c] = val;
        const S = window.SMY || window.S;
        if (S && S.P_REAL && S.P_REAL[r]) {
          S.P_REAL[r][c] = val;
        }
      }
    }
    function safeSetWaterCell(r,c){
      if(r<0||c<0||r>=N||c>=N) return;
      if(typeof window.setCellWater==='function'){
        const obj = getWorkM()?.[r]?.[c];
        let num = 'V';
        let color = '-';
        if (obj && obj.kind === 'water') {
          if (obj.main)  num = obj.main;
          if (obj.color) color = obj.color;
        }
        window.setCellWater(r,c,num,color);
      }
    }

    
    
    
    
    // [AUTO16_BLOCK] ========================================================
    // Automatizmus 16: 'V' típusú vízmezők számozása + 16/a következmények.
    
    
    
    
    //      H/V állapotát, és ebből következtet új H/V pontokra.
    
    //     workM → M_REAL tükre (hajó/víz/üres mezők logikai állapota)
    //     workP → P_REAL tükre (sarokpontok H/V/- állapota)
    
    //     • shoot() / afterAction() utáni AUTO-sor,
    //     • runAllAutosPass() (MINDEN AUT gomb) – ha CFG.auto.auto16 igaz.
    // - KERESÉS: "AUTO16_BLOCK" vagy 
    //             "auto_16_numbered_water_complete_points = function(".
    
    window.auto_16_numbered_water_complete_points = function(){
  // AUTO16 (16 + 16/c) – pontértékek kizárólag: '-', 'H', 'V'
  // Parti (szélső) mezőkben nem 4, hanem 2 releváns sarokpont van.
  // Kritikus: a pontot csak akkor tekintjük ismertnek, ha a LOGIKAI pont-rácson (N-1)x(N-1) belül van.

  var applied = 0;

  var S = window.SMY || window.S;
  if(!S || !S.M_REAL || !S.P_REAL) return 0;
  if(typeof workP === 'undefined' || !workP) return 0;

  var MR = S.M_REAL;
  var PR = S.P_REAL;
  var WP = workP;

  var Nloc = MR.length|0;
  var Pn = (Nloc>0 ? (Nloc-1) : 0); // logikai pont-rács méret (N-1)

  function isCornerCell(r,c){
    return (r===0 && c===0) || (r===0 && c===Nloc-1) || (r===Nloc-1 && c===0) || (r===Nloc-1 && c===Nloc-1);
  }

  function inBoundsPoint(p){
    return (p.r>=0 && p.c>=0 && p.r<Pn && p.c<Pn);
  }

  function cornersForCell(r,c){
    // Belső mező: 4 pont. Szélső mező: csak a táblán belüli 2 pont.
    // (A sarok-mezők itt eleve ki vannak zárva isCornerCell-lel.)
    if(r===0){
      return [ {r:0, c:c-1}, {r:0, c:c} ];
    }
    if(r===Nloc-1){
      return [ {r:r-1, c:c-1}, {r:r-1, c:c} ];
    }
    if(c===0){
      return [ {r:r-1, c:0}, {r:r, c:0} ];
    }
    if(c===Nloc-1){
      return [ {r:r-1, c:c-1}, {r:r, c:c-1} ];
    }
    return [
      {r:r-1, c:c-1},
      {r:r-1, c:c  },
      {r:r,   c:c-1},
      {r:r,   c:c  }
    ];
  }

  function readPointBoth(p){
    // Csak '-', 'H', 'V' értelmezett. Ha bármelyik (workP vagy P_REAL) már tudja, azt elfogadjuk.
    var a = (WP && WP[p.r] && typeof WP[p.r][p.c] === 'string') ? WP[p.r][p.c] : '-';
    var b = (PR && PR[p.r] && typeof PR[p.r][p.c] === 'string') ? PR[p.r][p.c] : '-';
    if(a==='H' || a==='V') return a;
    if(b==='H' || b==='V') return b;
    return '-';
  }

  function cornersAllKnown(pts){
    for(var i=0;i<pts.length;i++){
      var p = pts[i];
      if(!inBoundsPoint(p)) return false;
      var v = readPointBoth(p);
      if(v==='-') return false;
    }
    return true;
  }

  // --- 16/a: 'V' vízmezők számozása 0..4, ha az összes releváns sarokpont ismert ---
  for(var r=0;r<Nloc;r++){
    for(var c=0;c<Nloc;c++){
      if(isCornerCell(r,c)) continue;

      var tok0 = MR[r][c];
      if(typeof tok0 !== 'string' || !tok0) continue;
      var t = tok0.charAt(0);
      if(t!=='V') continue;

      var pts = cornersForCell(r,c);
      if(!pts || pts.length===0) continue;
      if(!cornersAllKnown(pts)) continue;

      var vCnt = 0;
      for(var k=0;k<pts.length;k++){
        if(readPointBoth(pts[k])==='V') vCnt++;
      }

      // színek megtartása
      var c1 = tok0.charAt(1);
      var c2 = tok0.charAt(2);
      var sub = String(c1) + String(c2);

      // V → 0..4 (partin: 0..2)
      setCellWater(r,c,String(vCnt), sub);
      applied++;
    }
  }

  // --- 16/c: számozott vízmezőkből (0..4) pont-következtetések ---
  for(var r2=0;r2<Nloc;r2++){
    for(var c2i=0;c2i<Nloc;c2i++){
      if(isCornerCell(r2,c2i)) continue;

      var tok = MR[r2][c2i];
      if(typeof tok !== 'string' || !tok) continue;
      var tt = tok.charAt(0);
      if(tt<'0' || tt>'4') continue;

      var need = tt.charCodeAt(0) - 48;

      var pts2 = cornersForCell(r2,c2i);
      if(!pts2 || pts2.length===0) continue;

      var nCorners = pts2.length;
      if(need > nCorners) continue; // parti mezőn 3/4 érték nem értelmezhető

      // In-bounds ellenőrzés (LOGIKAI pont-rács!)
      var ok = true;
      for(var q=0;q<nCorners;q++){
        var p2 = pts2[q];
        if(!inBoundsPoint(p2)){ ok=false; break; }
      }
      if(!ok) continue;

      var state = [];
      for(var u=0;u<nCorners;u++){
        state[u] = readPointBoth(pts2[u]); // 'H','V' vagy '-'
      }

      var vCnt2 = 0, hCnt2 = 0;
      var freeIdx = [];
      for(var u2=0;u2<nCorners;u2++){
        if(state[u2]==='V') vCnt2++;
        else if(state[u2]==='H') hCnt2++;
        else freeIdx.push(u2);
      }
      if(freeIdx.length===0) continue;

      // Ha már megvan a kellő V, a maradék biztosan H
      if(vCnt2===need){
        for(var z=0;z<freeIdx.length;z++){
          var pp = pts2[freeIdx[z]];
          safeSetPoint(pp.r, pp.c, 'H');
          applied++;
        }
        continue;
      }

      // Ha a H-k száma miatt a maradék mind V kell legyen
      // (partin: nCorners==2)
      if((nCorners - hCnt2)===need){
        for(var z2=0;z2<freeIdx.length;z2++){
          var pp2 = pts2[freeIdx[z2]];
          safeSetPoint(pp2.r, pp2.c, 'V');
          applied++;
        }
      }
    }
  }

  return applied;
};

;


    
    window.auto_2_pointV_implies_fourVCells = function(){
  

      try{
        const M = getWorkM(), P = getWorkP(); if(!M||!P) return;
        const PR = P.length, PC = P[0].length;
        for(let r=0;r<PR;r++){
          for(let c=0;c<PC;c++){
            if(P[r][c]==='V'){
         
			    const cells = [
                {r:r+1, c:c+1},
                {r:r+1, c:c},
                {r:r,   c:c+1},
                {r:r,   c:c}
              ];
              for(const q of cells){
                if(q.r>=0 && q.c>=0 && q.r<N && q.c<N){
                  const obj = M[q.r][q.c];
                  if(!obj || obj.kind!=='water'){
                    safeSetWaterCell(q.r,q.c);
                  }
                }
              }
            }
          }
        }
      }catch(e){  }
    };


    
    window.auto_14_fill_vectors_between_red_segments = function(){
      
      var applied = 0;
      try{
        var S = window.SMY || window.S || {};
        var MR = S && S.M_REAL;
        if(!S || !MR || !MR.length){
          
          
          return 0;
        }
        var N = MR.length;

        function getTok(r,c){
          if(r<0||c<0||r>=N||c>=N) return null;
          var row = MR[r];
          if(!row) return null;
          var tok = row[c];
          if(typeof tok !== 'string') return null;
          if(tok.length < 3){
            tok = (tok + '---').slice(0,3);
          }
          return tok;
        }
        function isWaterTok(tok){
          if(!tok || typeof tok!=='string' || !tok.length) return false;
          var t = tok.charAt(0).toUpperCase();
          return (t === 'V' || (t >= '0' && t <= '4'));
        }
        function isFillableTok(tok){
          if(!tok || typeof tok!=='string' || !tok.length) return false;
          var t = tok.charAt(0).toUpperCase();
          if(t === 'V' || (t >= '0' && t <= '4')) return true;
          if(t === '-') return true;
          if('ABGDH'.indexOf(t) >= 0) return true;
          return false;
        }
        function setTok(r,c,tok){
          if(r<0||c<0||r>=N||c>=N) return;
          var row = MR[r];
          if(!row) return;
          if(row[c] === tok) return;
          row[c] = tok;
          applied++;
        }

        
        for(var r=0; r<N; r++){
          var cols = [];
          for(var c=0; c<N; c++){
            var t = getTok(r,c);
            if(!t) continue;
            
            if(t.charAt(2) === 'p'){
              cols.push(c);
            }
          }
          if(cols.length >= 2){
            for(var i=0; i<cols.length-1; i++){
              var c1 = cols[i];
              var c2 = cols[i+1];
              if(Math.abs(c2 - c1) <= 1) continue; 
              for(var cc = c1+1; cc<c2; cc++){
                var tt = getTok(r,cc);
                if(!tt || !isFillableTok(tt)) continue; 
                if(tt.charAt(2) === 'p') continue;      
                tt = tt.substring(0,2) + 'p';
                setTok(r,cc,tt);
              }
            }
          }
        }

        
        for(var c=0; c<N; c++){
          var rows = [];
          for(var r=0; r<N; r++){
            var t2 = getTok(r,c);
            if(!t2) continue;
            
            if(t2.charAt(1) === 'p'){
              rows.push(r);
            }
          }
          if(rows.length >= 2){
            for(var j=0; j<rows.length-1; j++){
              var r1 = rows[j];
              var r2 = rows[j+1];
              if(Math.abs(r2 - r1) <= 1) continue;
              for(var rr = r1+1; rr<r2; rr++){
                var tt2 = getTok(rr,c);
                if(!tt2 || !isFillableTok(tt2)) continue;
                if(tt2.charAt(1) === 'p') continue;
                tt2 = tt2.charAt(0) + 'p' + tt2.charAt(2);
                setTok(rr,c,tt2);
              }
            }
          }
        }

      }catch(e){
        
      }
      
      return applied;
    };

    
    window.auto_14a_rowcol_vectors_from_ship_gaps = function(){

      var applied = 0;
      try{
        var S = window.SMY || window.S || {};
        var MR = S && S.M_REAL;
        if(!S || !MR || !MR.length){


          return 0;
        }
        var N = MR.length;

        function typeAt(r,c){
          if(r<0||c<0||r>=N) return '-';
          var row = MR[r];
          if(!row || c>=row.length) return '-';
          var code = row[c];
          if(typeof code !== 'string') return '-';
          return code.charAt(0).toUpperCase();
        }

        function isShipReal(r,c){
          var t = typeAt(r,c);
          return ('ABGDH'.indexOf(t) >= 0);
        }

        // ALFA-specifikus kivétel: ha két 'A' között pontosan 2 belső mező van (A _ _ A),
        // és a két belső mező még nem ellentmondásos (csak '-' vagy 'H'),
        // akkor ez ugyanazon ALFA hajó lehet → ne tekintsük "távoli hajóknak".
        function isSameAlfaCandidateRow(r,c1,c2){
          if ((c2 - c1) !== 3) return false;
          if (typeAt(r,c1) !== 'A' || typeAt(r,c2) !== 'A') return false;
          for (var cc=c1+1; cc<=c2-1; cc++){
            var t = typeAt(r,cc);
            if (t !== '-' && t !== 'H') return false;
          }
          return true;
        }
        function isSameAlfaCandidateCol(c,r1,r2){
          if ((r2 - r1) !== 3) return false;
          if (typeAt(r1,c) !== 'A' || typeAt(r2,c) !== 'A') return false;
          for (var rr=r1+1; rr<=r2-1; rr++){
            var t = typeAt(rr,c);
            if (t !== '-' && t !== 'H') return false;
          }
          return true;
        }


        if(!Array.isArray(S.SOROK_REAL)) S.SOROK_REAL = Array(N).fill('-');
        if(!Array.isArray(S.OSZL_REAL))  S.OSZL_REAL  = Array(N).fill('-');

        // sorok: csak akkor írunk 'P'-t, ha a vektor még '-' (nem írjuk felül a már 'Z'/'V'/stb. értéket)
        for(var r=0; r<N; r++){
          var cols = [];
          for(var c=0; c<N; c++){
            if(isShipReal(r,c)) cols.push(c);
          }
          if(cols.length >= 2){
            cols.sort(function(a,b){ return a-b; });
            for(var i=0; i<cols.length-1; i++){
              var c1 = cols[i], c2 = cols[i+1];
              var gap = c2 - c1;
              if(gap >= 3){
                if (isSameAlfaCandidateRow(r,c1,c2)) continue;
                var curRow = (S.SOROK_REAL && typeof S.SOROK_REAL[r] !== 'undefined') ? String(S.SOROK_REAL[r]).toUpperCase() : '-';
                if(curRow === '-'){
                  S.SOROK_REAL[r] = 'P';
                  applied++;
                }
                break;
              }
            }
          }
        }

        // oszlopok: csak akkor írunk 'P'-t, ha a vektor még '-' (nem írjuk felül a már 'Z'/'V'/stb. értéket)
        for(var c=0; c<N; c++){
          var rows = [];
          for(var r=0; r<N; r++){
            if(isShipReal(r,c)) rows.push(r);
          }
          if(rows.length >= 2){
            rows.sort(function(a,b){ return a-b; });
            for(var j=0; j<rows.length-1; j++){
              var r1 = rows[j], r2 = rows[j+1];
              var gap2 = r2 - r1;
              if(gap2 >= 3){
                if (isSameAlfaCandidateCol(c,r1,r2)) continue;
                var curCol = (S.OSZL_REAL && typeof S.OSZL_REAL[c] !== 'undefined') ? String(S.OSZL_REAL[c]).toUpperCase() : '-';
                if(curCol === '-'){
                  S.OSZL_REAL[c] = 'P';
                  applied++;
                }
                break;
              }
            }
          }
        }

      }catch(e){

      }


      return applied;
    };


    
    function refreshTopBoxes(){
      try{
        const vvBox = document.getElementById('vvBox');
        const szigBox = document.getElementById('szigBox');
        const szigOrigBox = document.getElementById('szigOrigBox');
        const khBox = document.getElementById('khBox');
        const leltar = window.LELTAR || {};

        
        const P = getWorkP();
        let vv=0;
        const PR = P?.length||0, PC = PR?P[0].length:0;
        const seen = Array.from({length:PR},()=>Array(PC).fill(false));
        const sizes=[];
        const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
        for(let r=0;r<PR;r++){
          for(let c=0;c<PC;c++){
            if(P[r][c]==='V' && !seen[r][c]){
              let q=[[r,c]]; seen[r][c]=true; let sz=0;
              while(q.length){
                const [rr,cc]=q.pop(); sz++; vv++;
                for(const [dr,dc] of dirs){
                  const nr=rr+dr,nc=cc+dc;
                  if(nr>=0&&nc>=0&&nr<PR&&nc<PC && P[nr][nc]==='V' && !seen[nr][nc]){ seen[nr][nc]=true; q.push([nr,nc]); }
                }
              }
              sizes.push(sz);
            } else if(P[r][c]==='V'){ vv++; }
          }
        }
        sizes.sort((a,b)=>a-b);

        
        const M = getWorkM();
        function isShip(o){ return o && o.kind==='ship'; }
        function countRuns(arr){ let cnt=0, inRun=false; for(const v of arr){ if(isShip(v)){ if(!inRun){cnt++; inRun=true;} } else inRun=false; } return cnt; }
        let khCur=0;
        if(M){
          khCur += countRuns(M[0]||[]);
          khCur += countRuns(M[N-1]||[]);
          const col0 = Array.from({length:N},(_,r)=> M[r]?.[0]);
          const colN = Array.from({length:N},(_,r)=> M[r]?.[N-1]);
          khCur += countRuns(col0);
          khCur += countRuns(colN);
        }

      
      
        let foundVV = 0;
        try{
          const S = window.SMY || {};
          const sr = Array.isArray(S.SOROK_REAL) ? S.SOROK_REAL : [];
          const or = Array.isArray(S.OSZL_REAL)  ? S.OSZL_REAL  : [];
          for(const v of sr){ if(v === 'V') foundVV++; }
          for(const v of or){ if(v === 'V') foundVV++; }
        }catch(_){}
        if(vvBox) vvBox.textContent = `${VIZVONALAKSZAMA} / ${foundVV}`;      
        if(khBox) khBox.textContent = `${KIKOTOTTHAJOKSZAMA} / ${khCur}`;   
        writeFoundIslandsPanel(sizes);
        

      }catch(e){  }
    }
    window.refreshTopBoxes = refreshTopBoxes;

  }
})();
</script>
<script id="AUTO_SWITCHES_1104">
document.addEventListener('DOMContentLoaded', function(){
  {
    const map = [
      ['sw_auto2',   'auto2'],
      ['sw_auto16', 'auto16'],
      ['sw_auto14', 'auto14'],
      ['sw_auto14a','auto14a'],
      ['sw_auto23a','auto23a']
    ];
    map.forEach(([id,key])=>{
      const el = document.getElementById(id);
      if(!el) return;
      
      el.checked = !!(window.CFG && window.CFG.auto && window.CFG.auto[key]);
      el.addEventListener('change', function(){
        if(window.CFG && window.CFG.auto) window.CFG.auto[key] = !!this.checked;
      });
    });
  }
});
</script>
<script>
// === Automatizmus kapcsolók bekötése + aggregátor + kényszerített iteráció ===
(function(){
  window.CFG = window.CFG || {}; CFG.auto = CFG.auto || {};
  // 3/a. Bind UI checkboxes (id='sw_*') to CFG.auto.*
  function bindAutoSwitches(){
    var rows = document.getElementById('autoRows'); if(!rows) return;
    var boxes = rows.querySelectorAll('input[type="checkbox"][id^="sw_"]');
    boxes.forEach(function(b){
      var key = b.id.replace(/^sw_/, '');
      if (!(key in CFG.auto)) CFG.auto[key] = !!b.checked;
      b.checked = !!CFG.auto[key];
      if(!b.__bound){
        b.addEventListener('change', function(){ CFG.auto[key] = !!b.checked; });
        b.__bound = true;
      }
    });
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bindAutoSwitches);
  } else { bindAutoSwitches(); }

  // 3/b. Aggregátor: futtasd a nevezett automatizmusokat a kapcsolók szerint
  window.runAllAutosPass = window.runAllAutosPass || function(){
    var applied = 0;
    // Map függvénynév -> kapcsoló kulcs (autoRows checkbox id-ből)
    var map = {
      'auto_6b_fromShipPoints': 'auto6b',
      'auto_9_rowWaterline_fill': 'auto9',
      'auto_10a_shoreDelta': 'auto10a',
      'auto_15_crossShipsCenterWater': 'auto15',
      'auto_21a_bridge': 'auto21a',
      'auto_21b_bridge': 'auto21b',
      'auto_16_numbered_water_complete_points': 'auto16',
      'auto_23a_push_ship_point': 'auto23a',
      'auto_2_pointV_implies_fourVCells': 'auto2',
      'auto_7_fillAllShipPoints': 'auto7',
      'auto_8_shoreFreeToWater': 'auto8',
      'auto_13b_fix_colors_from_vectors': 'auto13b',
      'auto_6_fromMaxIsland': 'auto6',
      'auto_3_4_5_fromWater': 'fromW',
      'auto_bridgeOneGapPairs': 'bridgeOneGapPairs',
      'auto_cornersWater': 'cornersWater',
      'auto_partExtension': 'partExtension',
      'findAndSealFullShips': 'sealFullShips'
    };
    var order = [
      'auto_23a_push_ship_point',
      'auto_16_numbered_water_complete_points',
      'auto_9_rowWaterline_fill','auto_10a_shoreDelta','auto_15_crossShipsCenterWater','auto_21a_bridge','auto_21b_bridge',
      'auto_6b_fromShipPoints','auto_7_fillAllShipPoints','auto_8_shoreFreeToWater',
      'auto_6_fromMaxIsland','auto_3_4_5_fromWater','auto_13b_fix_colors_from_vectors',
      'findAndSealFullShips'
    ];
    function call(name){
      {
        var key = map[name];
        if (key && CFG.auto.hasOwnProperty(key) && CFG.auto[key] === false) return 0;
        if (typeof window[name] === 'function'){
          var r = window[name]();
          if (typeof r === 'number' && isFinite(r)){
            var n = (r|0);
            if (n !== 0){ applied += n; window.VALTOZAS = true; }
          } else if (r === true){
            applied += 1;
            window.VALTOZAS = true;
          }
        }
      }
      return 0;
    }
    for (var i=0;i<order.length;i++) call(order[i]);
    
    return applied;
  };

  
  var _shoot = window.shoot;
  if (typeof _shoot === 'function' && !_shoot.__forced5){
    window.shoot = function(){
      var out = _shoot.apply(this, arguments);
      {
        for (var k=0; k<50 ; k++){
          VALTOZAS = false;
          if (typeof window.runAllAutosPass === 'function') window.runAllAutosPass();
          if (!VALTOZAS) break;
        }
      }
      return out;
    };
    window.shoot.__forced5 = true;
  }
})();
</script>
<script>
(function(){
  
  window.CFG = window.CFG || {}; CFG.auto = CFG.auto || {};

  
  const LSKEY = 'smyoz_auto_flags_v1';
  function loadFlags(){
    try{ const s = localStorage.getItem(LSKEY); return s ? JSON.parse(s) : {}; }catch(e){ return {}; }
  }
  function saveFlags(o){
    localStorage.setItem(LSKEY, JSON.stringify(o));
  }
  // Merge stored flags into CFG.auto
  Object.assign(CFG.auto, loadFlags());

  // Known automations: [key, label, functionName]
  
  const AUTOS_DEFAULT = [
        ['cornersWater', '1: hajó sarkaira víz',                 'auto_1_shipCornersFromReal'],
        ['auto2',   '2: vízpont körül 4 vízmező',                'auto_2_pointV_implies_fourVCells'],
        ['recomputeWaterPoints2a','2a: 4 vízmező között vízpont','recomputeWaterPoints2a'],
        ['fromW',   '3–4–5: vízből következők',                  'auto_3_4_5_fromWater'],
        ['auto16', '16: mező és pont kiegészítések',             'auto_16_numbered_water_complete_points'],
        ['auto7',   '7: összes vízpont megvan → a többi: hajópont',   'auto_7_fillAllShipPoints'],		
        ['auto8',   '8: minden kikötés megvan → parton a többi: víz', 'auto_8_shoreFreeToWater'],		
        ['auto6',   '6: hajópontok a max-sziget körül',            'auto_6_fromMaxIsland'],
        ['auto6b',  '6b: hajópont 3 vízmezővel → hajómező',      'auto_6b_fromShipPoints'],
        ['auto23a', '23/a: vízfrontból kilökött hajópont',       'auto_23a_push_ship_point'],
        ['auto10',  '10: partot közelítő piros → partra vízek',  'auto_10_shoreSideWater'],
        ['auto10a', '10/a: parttól 1-re piros → partra DELTA',   'auto_10a_shoreDelta'],
        ['auto11',  '11: kikötött hajó → teljes hajó',           'auto_11_shoreExtension'],
        ['sealFullShips','20: teljes hajót víz vesz körül',      'findAndSealFullShips'],		
        ['auto9',   '9: sor/oszlop vízvonal',                    'auto_9_rowWaterline_fill'],
    	['auto13',  '13: vízvonal kiterjesztés',                 'enforceAuto13WaterVectors'],
	['auto13b','13b: SOR/OSZL → színdöntés bizonytalan mezőkön','auto_13b_fix_colors_from_vectors'],
        ['auto12',  '12: színes vonal azonos szomszédokon folyamatos',    'auto_12_color_between_waters'],
        ['auto14',  '14: távoli piros szegmensek összeköthetők', 'auto_14_fill_vectors_between_red_segments'],
    	['auto12a', '12a: hajó piros vonal vízen folytatódik',   'auto_12a_color_between_differents'],
        ['auto14a', '14a: sor/oszlop hajók között piros vonal', 'auto_14a_rowcol_vectors_from_ship_gaps'],
        ['auto15',  '15: két hajótípus között víz',              'auto_15_crossShipsCenterWater'],
        ['auto18','18: félkész hajó toldása','auto_18_extend_partial_ship'],
        ['extendFromPairs',  '21: szomszédos hajómezők azonos típusúak', 'auto_21_extendFromPairs'],
        ['auto21a', '21a: ALFA kitöltés',                         'auto_21a_bridge'],
        ['auto21b', '21b: BÉTA kitöltés (nincs)',                        'auto_21b_bridge']
      ];


// Ha a böngészőben a window.SMY_AUTOS = [...] tömb már definiálva van
// (pl. egy külön SMY_AUTOS_CONFIG.js fájl tölti be), akkor azt használjuk.
const AUTOS = (typeof window !== 'undefined' && window.SMY_AUTOS && Array.isArray(window.SMY_AUTOS))
  ? window.SMY_AUTOS
  : AUTOS_DEFAULT;


  
function buildAutoRows(){
    const host = document.getElementById('autoRows');
    if(!host) return;

    
    const tb = document.createElement('div');
    tb.className = 'auto-toolbar';
    const allOn  = document.createElement('button'); allOn.textContent  = 'MINDEN BE';
    const allOff = document.createElement('button'); allOff.textContent = 'MINDEN KI';
    tb.appendChild(allOn); tb.appendChild(allOff);
    host.innerHTML = ''; host.appendChild(tb);

    
    const grid = document.createElement('div');
    grid.className = 'auto-grid';
    AUTOS.forEach(([key, label, fnName]) => {
      // default state: ON unless explicitly false in CFG.auto
      

      const item = document.createElement('label');
      item.style.display = 'flex';
      item.style.alignItems = 'center';
      item.style.gap = '8px';
      item.style.margin = '6px 0';

                const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.id   = 'sw_' + key;

          // Alapértelmezett állapot:
          // 1) ha CFG.auto már tartalmazza, azt használjuk (mentett beállítás)
          // 2) ha nincs, de létezik window.SMY_AUT_FLAGS[key], akkor az szerinti a default
          
          if (!Object.prototype.hasOwnProperty.call(CFG.auto, key)) {
            if (typeof window !== 'undefined' && window.SMY_AUT_FLAGS && Object.prototype.hasOwnProperty.call(window.SMY_AUT_FLAGS, key)) {
              CFG.auto[key] = !!window.SMY_AUT_FLAGS[key];
            } else {
              CFG.auto[key] = true;
            }
          }
          cb.checked = (CFG.auto[key] !== false);

const exists = (typeof window[fnName] === 'function' || key === 'auto6' || key === 'auto6b');
      if (!exists){ cb.disabled = true; item.classList.add('disabled'); }
      const span = document.createElement('span'); span.textContent = label;
      item.appendChild(cb); item.appendChild(span);
      item.title = fnName + (exists ? '' : ' (nincs implementáció)');
      grid.appendChild(item);

      cb.addEventListener('change', () => {
        CFG.auto[key] = !!cb.checked;
        saveFlags(CFG.auto);
      });
    });
    host.appendChild(grid);

    allOn.addEventListener('click', () => {
      host.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        if(!cb.disabled){
          cb.checked = true;
          CFG.auto[cb.id.replace(/^sw_/, '')] = true;
        }
      });
      saveFlags(CFG.auto);
    });allOff.addEventListener('click', () => {
      host.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        if(!cb.disabled){
          cb.checked = false;
          CFG.auto[cb.id.replace(/^sw_/, '')] = false;
        }
      });
      saveFlags(CFG.auto);
    });}

  // Aggregátor: futtasd a kiválasztott automatizmusokat a listából, sorrendben
  
  // === 5b: ensure SOROK_REAL / OSZL_REAL pick up colors already present in M_REAL ===
  // Only fills missing ('-') vector entries; never overwrites fixed values (including 'V').
  // 5b: propagate M_REAL line colors into SOROK_REAL / OSZL_REAL if still '-'
// - Does NOT overwrite existing non-'-' entries.
// - Uses only SMY.M_REAL (no HOMOK_REAL / ISHOT_REAL).
window.SMY_updateVectorsFromRealColors = function(){
  try{
    const S = window.SMY;
    if(!S || !S.M_REAL || !Array.isArray(S.SOROK_REAL) || !Array.isArray(S.OSZL_REAL)) return 0;
    const N = S.M_REAL.length|0;

    const ensure3 = (t)=>{
      const s = (t===undefined || t===null) ? '---' : String(t);
      return (s.length>=3) ? s : (s + '---').slice(0,3);
    };
    const isPZ = (x)=> x==='p' || x==='z';
    const isShipT = (t)=> (t==='A' || t==='B' || t==='G' || t==='D' || t==='H');

    // Precompute: does the row/col contain any ship cell? (then green is NOT a waterline)
    const rowHasShip = Array(N).fill(false);
    const colHasShip = Array(N).fill(false);
    for(let r=0; r<N; r++){
      for(let c=0; c<N; c++){
        const tok = ensure3(S.M_REAL[r][c] || '---');
        const t = tok.charAt(0);
        if(isShipT(t)){
          rowHasShip[r] = true;
          colHasShip[c] = true;
        }
      }
    }

    let changed = 0;

    for(let r=0; r<N; r++){
      for(let c=0; c<N; c++){
        const tok = ensure3(S.M_REAL[r][c] || '---');
        const v = tok.charAt(1); // vertical line color
        const h = tok.charAt(2); // horizontal line color

        // Column vector from vertical color
        if(S.OSZL_REAL[c] === '-' && isPZ(v)){
          // 'z' becomes 'V' only if the whole column has no ship; otherwise 'Z'
          S.OSZL_REAL[c] = (v==='z' ? (colHasShip[c] ? 'Z' : 'V') : 'P');
          changed++;
        }

        // Row vector from horizontal color
        if(S.SOROK_REAL[r] === '-' && isPZ(h)){
          // 'z' becomes 'V' only if the whole row has no ship; otherwise 'Z'
          S.SOROK_REAL[r] = (h==='z' ? (rowHasShip[r] ? 'Z' : 'V') : 'P');
          changed++;
        }
      }
    }
    return changed;
  }catch(_e){ return 0; }
};;
window.runAllAutosPass = function()
   {if (typeof bridgeWorkToSMY === 'function') bridgeWorkToSMY();
    let applied = 0;

    // 1. AUT: hajó sarkaira víz (teljes tábla, automatizmus-mód)
    if (typeof window.auto_1_shipCornersFromReal === 'function'){
      {
        const r0 = window.auto_1_shipCornersFromReal();
        if (typeof r0 === 'number' && isFinite(r0)) applied += (r0|0);
      }
    }

    // Többi automatizmus a listából (az AUT18 mindig a legvégén fusson)
    let deferredAuto18Fn = null;

    for (const [key, _label, fnName] of AUTOS){
      if (CFG.auto[key] === false) continue;

      // 18: félkész hajó toldása – mindig utolsóként fusson
      if (key === 'auto18') {
        const fn18 = window[fnName];
        if (typeof fn18 === 'function') deferredAuto18Fn = fn18;
        continue;
      }

      const fn = window[fnName];
      if (typeof fn === 'function'){
        {
          const r = fn();
          if (typeof r === 'number' && isFinite(r)) applied += (r|0);
        }
      }
    }

    if (deferredAuto18Fn){
      // 21 előfuttatás az AUT18 előtt akkor is, ha a 21 ki van kapcsolva.
      // Cél: stabilabb, determinisztikus típus-információ a toldás előtt.
      try{
        const fn21 = window.auto_21_extendFromPairs;
        if (typeof fn21 === 'function'){
          const cfg = window.CFG;
          const hadCFG = (typeof cfg === 'object' && cfg && typeof cfg.auto === 'object' && cfg.auto);
          let old21 = undefined;
          let hadOld21 = false;
          if (hadCFG){
            hadOld21 = Object.prototype.hasOwnProperty.call(cfg.auto, 'extendFromPairs');
            if (hadOld21) old21 = cfg.auto.extendFromPairs;
            cfg.auto.extendFromPairs = true;
          }
          const r21 = fn21();
          if (typeof r21 === 'number' && isFinite(r21)) applied += (r21|0);
          if (hadCFG){
            if (hadOld21) cfg.auto.extendFromPairs = old21;
            else delete cfg.auto.extendFromPairs;
          }
        }
      }catch(_e){}
      {
        const r = deferredAuto18Fn();
        if (typeof r === 'number' && isFinite(r)) applied += (r|0);
      }
    }
        try{
          if (window.SMY_updateVectorsFromRealColors){
            const _vchg = window.SMY_updateVectorsFromRealColors();
            if (typeof _vchg === 'number' && _vchg > 0){ window.VALTOZAS = true; }
          }
        }catch(_e){}

    if (window.debugCheckRealVsWork){ window.debugCheckRealVsWork('MINDEN AUT'); }
    return applied;
  };


  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', buildAutoRows);
  } else {
    buildAutoRows();
  }
})();
</script>

<script>
// === 23/a - „vízfrontból kilökött hajópont” - BÁZIS: SMY.M_REAL/M_REAL + SMY.P_REAL/P_REAL ===
/*
[OLD 23/a IMPLEMENTATION - commented out]
window.auto_23a_push_ship_point = function auto_23a_push_ship_point(){
  console.log('[AUTO-BEGIN] auto_23a_push_ship_point');

  console.log('SMY|AUTO-BEGIN auto_23a_push_ship_point');
  var MR = (typeof SMY!=='undefined' && SMY && SMY.M_REAL) ? SMY.M_REAL
           : (typeof M_REAL!=='undefined' ? M_REAL : null);
  var PR = (typeof SMY!=='undefined' && SMY && SMY.P_REAL) ? SMY.P_REAL
           : (typeof P_REAL!=='undefined' ? P_REAL : null);
  if (!MR || !PR || !PR.length || !PR[0].length) { console.log('SMY|AUTO 23/a: nincs M_REAL/P_REAL');; return 0; }

  var PRows = PR.length|0, PCols = PR[0].length|0, applied=0;

  function isWaterCell(r,c){
    if (r<0||c<0||r>=MR.length||c>=MR[0].length) return false;
    var v = MR[r][c];
    if (v==null) return false;
    if (typeof v==='object'){ if ((v.kind||'')==='water') return true; v=v.main||v.value||v.t||''; }
    var s=String(v).toUpperCase();
    return ('01234'.indexOf(s[0])>=0) || s[0]==='V';
  }
  function getP(r,c){ if(r<0||c<0||r>=PRows||c>=PCols) return null; return PR[r][c]; }
  function setH(r,c){
    if(r<0||c<0||r>=PRows||c>=PCols) return;
    if (PR[r][c]==='H') return;
    if (PR[r][c]==='-' || PR[r][c]==='' || PR[r][c]==null || PR[r][c]===undefined){
      PR[r][c]='H'; applied++; window.VALTOZAS=true;
    }
  }

  for (var pr=0; pr<PRows; pr++){
    for (var pc=0; pc<PCols; pc++){
      if (getP(pr,pc)!=='H') continue;
      if( isWaterCell(pr-1,pc-1) && isWaterCell(pr,pc-1) && getP(pr,pc-1)!=='H' ) setH(pr, pc-1);
      if( isWaterCell(pr-1,pc)   && isWaterCell(pr,pc)   && getP(pr,pc+1)!=='H' ) setH(pr, pc+1);
      if( isWaterCell(pr-1,pc-1) && isWaterCell(pr-1,pc) && getP(pr-1,pc)!=='H') setH(pr-1, pc);
      if( isWaterCell(pr,pc-1)   && isWaterCell(pr,pc)   && getP(pr+1,pc)!=='H') setH(pr+1, pc);
    }
  }
  console.log('SMY|AUTO auto_23a_push_ship_point applied=', applied);
  return applied;
}
*/

window.auto_23a_push_ship_point = function auto_23a_push_ship_point(){
  
  let applied = 0;
  let logged = 0;

  // Resolve REAL matrices
  const MR = (typeof SMY !== 'undefined' && SMY && SMY.M_REAL) ? SMY.M_REAL
             : (typeof M_REAL !== 'undefined' ? M_REAL : null);
  // const PR = (typeof SMY !== 'undefined' && SMY && SMY.P_REAL) ? SMY.P_REAL
  //           : (typeof P_REAL !== 'undefined' ? P_REAL : null);

  const PR = workP;

  if (!MR || !PR || !PR.length || !PR[0].length){
    
    
    return 0;
  }

  
  
  
  const N = 9;
  const PRows = 8;
  const PCols = 8;
 
  
  // Pontok: P_REAL[pr][pc], 0 <= pr,pc <= N-2
  for (let pr = 0; pr < PRows; pr++){
    for (let pc = 0; pc < PCols; pc++){
      if (PR[pr][pc] !== 'H') continue;  

      
      const tl_r = pr,     tl_c = pc;
      const bl_r = pr + 1, bl_c = pc;
      const tr_r = pr,     tr_c = pc + 1;
      const br_r = pr + 1, br_c = pc + 1;

      const TL = MR[tl_r][tl_c];
      const BL = MR[bl_r][bl_c];
      const TR = MR[tr_r][tr_c];
      const BR = MR[br_r][br_c];

      const TL_t = TL[0], BL_t = BL[0], TR_t = TR[0], BR_t = BR[0];

      const TL_empty = (TL_t === '-');
      const BL_empty = (BL_t === '-');
      const TR_empty = (TR_t === '-');
      const BR_empty = (BR_t === '-');

      const TL_water = (TL_t === 'V' || TL_t === '0' || TL_t === '1' || TL_t === '2');
      const BL_water = (BL_t === 'V' || BL_t === '0' || BL_t === '1' || BL_t === '2');
      const TR_water = (TR_t === 'V' || TR_t === '0' || TR_t === '1' || TR_t === '2');
      const BR_water = (BR_t === 'V' || BR_t === '0' || BR_t === '1' || BR_t === '2');


   
   

      
      if (pc > 0
          && TL_empty && BL_empty
          && TR_water && BR_water
          && PR[pr][pc-1] === '-'){
        PR[pr][pc-1] = 'H';
        applied++;
        if (logged < 3){
          
          logged++;
        }
        continue;
      }

      
      if (pc < PCols-1
          && TL_water && BL_water
          && TR_empty && BR_empty
          && PR[pr][pc+1] === '-'){
        PR[pr][pc+1] = 'H';
        applied++;
        if (logged < 3){
          
          logged++;
        }
        continue;
      }

      
      if (pr > 0
          && TL_empty && TR_empty
          && BL_water && BR_water
          && PR[pr-1][pc] === '-'){
        PR[pr-1][pc] = 'H';
        applied++;
        if (logged < 3){
          
          logged++;
        }
        continue;
      }

      
      if (pr < PRows-1
          && TL_water && TR_water
          && BL_empty && BR_empty
          && PR[pr+1][pc] === '-'){
		  
        PR[pr+1][pc] = 'H';
        applied++;
        if (logged < 3){
          
          logged++;
        }
        continue;
      }
    }
  }

  
  
  return applied;
};;
</script>
<script>

function auto_10_shoreSideWater(){
  let MR=(typeof SMY!=='undefined'&&SMY&&SMY.M_REAL)||(typeof M_REAL!=='undefined'?M_REAL:null);
  if(!MR||!MR.length) return 0;
  let N=MR.length,applied=0,c,r,cell,t,c1,c2;

  
  for(c=1;c<=N-2;c++){
    
    cell=MR[2][c];
    if(cell && cell[1]==='p'){
      r=0;

      
      let cellL=MR[r][c-1]||'---'; t=cellL[0]; c1=cellL[1]||'-'; c2=cellL[2]||'-';
      if(t==='-'){MR[r][c-1]='V'+c1+c2; applied++; VALTOZAS=true;}
      let cellR=MR[r][c+1]||'---'; t=cellR[0]; c1=cellR[1]||'-'; c2=cellR[2]||'-';
      if(t==='-'){MR[r][c+1]='V'+c1+c2; applied++; VALTOZAS=true;}
	  
      
      
      let shore = MR[0][c] || '---';
      let mid   = MR[1][c] || '---';
      let tS = shore[0];
      let tM = mid[0], m1 = mid[1]||'-', m2 = mid[2]||'-';
      if('V01234'.indexOf(String(tS||'').toUpperCase()[0])>=0 && tM==='-'){
        
        MR[1][c] = 'H-' + m2;   
        if (typeof setCellShip === 'function') { { setCellShip(1, c, 'H', '--'); } }
        applied++; VALTOZAS=true; 
	  }
    }

    
    cell=MR[N-3][c];
    if(cell && cell[1]==='p'){
      r=N-1;

      
      let cellL=MR[r][c-1]||'---'; t=cellL[0]; c1=cellL[1]||'-'; c2=cellL[2]||'-';
      if(t==='-'){MR[r][c-1]='V'+c1+c2; applied++; VALTOZAS=true;}
      let cellR=MR[r][c+1]||'---'; t=cellR[0]; c1=cellR[1]||'-'; c2=cellR[2]||'-';
      if(t==='-'){MR[r][c+1]='V'+c1+c2; applied++; VALTOZAS=true;}
	  
      
      
      let shore = MR[N-1][c] || '---';
      let mid   = MR[N-2][c] || '---';
      let tS = shore[0];
      let tM = mid[0], m1 = mid[1]||'-', m2 = mid[2]||'-';
      if('V01234'.indexOf(String(tS||'').toUpperCase()[0])>=0 && tM==='-'){
        MR[N-2][c] = 'H-' + m2;   
        if (typeof setCellShip === 'function') { { setCellShip(N-2, c, 'H', '--'); } }
        applied++; VALTOZAS=true;
      }
    }
  }

  
  for(r=1;r<=N-2;r++){
    
    cell=MR[r][2];
    if(cell && cell[2]==='p'){
      c=0;

      
      let cellT=MR[r-1][c]||'---'; t=cellT[0]; c1=cellT[1]||'-'; c2=cellT[2]||'-';
      if(t==='-'){MR[r-1][c]='V'+c1+c2; applied++; VALTOZAS=true;}
      let cellB=MR[r+1][c]||'---'; t=cellB[0]; c1=cellB[1]||'-'; c2=cellB[2]||'-';
      if(t==='-'){MR[r+1][c]='V'+c1+c2; applied++; VALTOZAS=true;}
	  
      
      
      let shore = MR[r][0] || '---';
      let mid   = MR[r][1] || '---';
      let tS = shore[0];
      let tM = mid[0], m1 = mid[1]||'-', m2 = mid[2]||'-';
      if('V01234'.indexOf(String(tS||'').toUpperCase()[0])>=0 && tM==='-'){
        
        MR[r][1] = 'H' + m1 + '-';   
        if (typeof setCellShip === 'function') { { setCellShip(r, 1, 'H', '--'); } }
        applied++; VALTOZAS=true;
      }
    }

    
    cell=MR[r][N-3];
    if(cell && cell[2]==='p'){
      c=N-1;

      
      let cellT=MR[r-1][c]||'---'; t=cellT[0]; c1=cellT[1]||'-'; c2=cellT[2]||'-';
      if(t==='-'){MR[r-1][c]='V'+c1+c2; applied++; VALTOZAS=true;}
      let cellB=MR[r+1][c]||'---'; t=cellB[0]; c1=cellB[1]||'-'; c2=cellB[2]||'-';
      if(t==='-'){MR[r+1][c]='V'+c1+c2; applied++; VALTOZAS=true;}

      
      
      let shore = MR[r][N-1] || '---';
      let mid   = MR[r][N-2] || '---';
      let tS = shore[0];
      let tM = mid[0], m1 = mid[1]||'-', m2 = mid[2]||'-';
      if('V01234'.indexOf(String(tS||'').toUpperCase()[0])>=0 && tM==='-'){
        MR[r][N-2] = 'H' + m1 + '-';   
        if (typeof setCellShip === 'function') { { setCellShip(r, N-2, 'H', '--'); } }
		
        applied++; VALTOZAS=true;
      }
    }
  }

  return applied;
};function auto_10a_shoreDelta(){
  
  let applied = 0;

  // M_REAL elérése (SMY preferált, fallback M_REAL-ra)
  const MR = (typeof SMY !== 'undefined' && SMY && SMY.M_REAL)
    ? SMY.M_REAL
    : (typeof M_REAL !== 'undefined' ? M_REAL : null);

  if (!MR || !MR.length){
    
    
    return 0;
  }

  const N = MR.length;

  
  function isWater10a(t){
    return t === 'V' || t === '0' || t === '1' || t === '2';
  }

  
  const ringRows = [1,7];
  for (let idx = 0; idx < ringRows.length; idx++){
    const r = ringRows[idx];
    if (r < 0 || r >= N) continue;

    for (let c = 1; c <= 7 && c < N-1; c++){
      const cell = MR[r][c]; if (!cell) continue;
      const t = cell[0], v = cell[1], h = cell[2];

      
      if (v !== 'p') continue;        

      let pr = -1, pc = -1;          
      if (r === 1){
        pr = 0; pc = c;              
      } else if (r === 7 && N > 8){
        pr = 8; pc = c;              
      } else {
        continue;
      }

      const target = MR[pr][pc] || ['-','-','-'];
      if (target[0] === 'D') continue;   

      
      
      // ezért M_REAL-ban közvetlenül elmentjük, a setCellShip csak a típust és
      
      const horiz = target[2];    

      MR[pr][pc] = 'D' + '-' + (horiz || '-');

      {
        // A wrapper csak p/z/x-et tud, ezért ha a horiz nem ilyen, csak 'D--' kerül M_SHOT-ba,
        // a tényleges, részletes kód M_REAL-ban marad meg.
        if (horiz === 'p' || horiz === 'z' || horiz === 'x'){
          setCellShip(pr, pc, 'D', '-'+horiz);
        } else {
          setCellShip(pr, pc, 'D', '--');
        }
      }

      applied++;
    }
  }

  
  const ringCols = [1,7];
  for (let idx = 0; idx < ringCols.length; idx++){
    const c = ringCols[idx];
    if (c < 0 || c >= N) continue;

    for (let r = 1; r <= 7 && r < N-1; r++){
      const cell = MR[r][c]; if (!cell) continue;
      const t = cell[0], v = cell[1], h = cell[2];

      
      if (h !== 'p') continue;        

      let pr = -1, pc = -1;
      if (c === 1){
        pr = r; pc = 0;               
      } else if (c === 7 && N > 8){
        pr = r; pc = 8;               
      } else {
        continue;
      }

      const target = MR[pr][pc] || ['-','-','-'];
      if (target[0] === 'D') continue;

      
      // A függőleges komponens megőrzése törekvés, M_REAL-ban közvetlenül.
      const vert = target[1];  

      
	  MR[pr][pc] = 'D' + (vert || '-'+ '-' );

      {
        if (vert === 'p' || vert === 'z' || vert === 'x'){
          setCellShip(pr, pc, 'D', vert+'-');
        } else {
          setCellShip(pr, pc, 'D', '--');
        }
      }

      applied++;
    }
  }

  
  
  return applied;
};;;
</script>
<script>

function auto_15_crossShipsCenterWater(){
  
  let applied = 0;

  // M_REAL: SMY preferált, fallback M_REAL-ra
  const MR = (typeof SMY !== 'undefined' && SMY && SMY.M_REAL)
    ? SMY.M_REAL
    : (typeof M_REAL !== 'undefined' ? M_REAL : null);

  if (!MR || !MR.length){
    
    
    return 0;
  }

  const WM = (typeof workM !== 'undefined' && workM && Array.isArray(workM))
    ? workM
    : null;

  const N = MR.length;

  function typeFromMR(r,c){
    const row = MR[r];
    if (!row) return '-';
    const v = row[c];
    if (!v) return '-';
    if (typeof v === 'string') return v.charAt(0) || '-';
      if (Array.isArray(v)) return String(v[0] || '-').charAt(0) || '-';
      if (typeof v.realCell === 'string') return v.realCell.charAt(0) || '-';
    return '-';
  }

  function typeFromWM(r,c){
    if (!WM || !WM[r]) return '-';
    const v = WM[r][c];
    if (!v) return '-';
    if (typeof v === 'string') return v.charAt(0) || '-';
      if (v.kind === 'ship' && typeof v.main === 'string') return v.main.charAt(0).toUpperCase();
      if (typeof v.realCell === 'string') return v.realCell.charAt(0) || '-';
      if (v.kind === 'water' && typeof v.main === 'string') return v.main.charAt(0) || 'V';
    return '-';
  }

  const isShipType = function(t){ return t === 'A' || t === 'B' || t === 'G' || t === 'D'; };

  for (let r = 1; r <= N-2; r++){
    for (let c = 1; c <= N-2; c++){
      
      let raw = MR[r][c];
      if (typeof raw === 'undefined' || raw === null) raw = '---';
      let s = '';
      try { s = String(raw); } catch(_){ s = '---'; }
      const t0 = s.charAt(0) || '-';
      const v0 = s.charAt(1) || '-';
      const h0 = s.charAt(2) || '-';

      const isPureEmpty  = (t0 === '-' && v0 === '-' && h0 === '-');
      const isPlainWater = (t0 === '0');

      if (!isPureEmpty && !isPlainWater) continue;

      const upT    = typeFromMR(r-1,c);
      const downT  = typeFromMR(r+1,c);
      const leftT  = typeFromMR(r,c-1);
      const rightT = typeFromMR(r,c+1);

      const vertMR = isShipType(upT) && isShipType(downT) && upT !== downT;
      const horMR  = isShipType(leftT) && isShipType(rightT) && leftT !== rightT;
      const condMR = vertMR || horMR;

      let condWM = condMR;
      if (WM){
        const upW    = typeFromWM(r-1,c);
        const downW  = typeFromWM(r+1,c);
        const leftW  = typeFromWM(r,c-1);
        const rightW = typeFromWM(r,c+1);

        const vertWM = isShipType(upW) && isShipType(downW) && upW !== downW;
        const horWM  = isShipType(leftW) && isShipType(rightW) && leftW !== rightW;
        condWM = vertWM || horWM;

        if (condMR !== condWM){
          {
            
          }
        }
      }

      if (!condMR) continue; 

      let newT = '0';
      let newV = v0;
      let newH = h0;

      if (vertMR) newV = 'p';   
      if (horMR)  newH = 'p';   

      // UI: piros víz - subTxt='p'; az irányinformáció M_REAL-ban marad pontos
        setCellWater(r,c,'0','p');

      if (!MR[r]) MR[r] = [];
        MR[r][c] = '' + newT + (newV || '-') + (newH || '-');

      applied++;
      VALTOZAS = true;
    }
  }

  
  
  return applied;
}



function auto_18_extend_partial_ship(){

  let applied = 0;

  if (!window.CFG || !CFG.auto || CFG.auto.auto18 === false) {
    return applied;
  }

  // M_REAL preferált, fallback M_REAL-ra
  var MR = (typeof SMY !== 'undefined' && SMY && SMY.M_REAL)
    ? SMY.M_REAL
    : (typeof M_REAL !== 'undefined' ? M_REAL : null);

  if (!MR || !MR.length){
    return applied;
  }

  var N = MR.length;
  var deltas = [[-1,0],[1,0],[0,-1],[0,1]];

  function inBounds(r,c){
    return r >= 0 && c >= 0 && r < N && c < N;
  }

  function cellMainAt(r,c){
    if (!inBounds(r,c)) return '-';
    var row = MR[r];
    if (!row) return '-';
    var cell = row[c] || '---';
    return String(cell[0] || '-').toUpperCase();
  }

  function isShipMain(ch){
    return ch === 'A' || ch === 'B' || ch === 'G' || ch === 'D';
  }

  // Hajóhossz-korlát: ne engedjük, hogy a toldás két külön hajót "összeragasszon",
  // vagy hogy egy futásban a típus max hosszán túl nőjön a folytonos szakasz.
  function runLenAfterAdd(rr, cc, main, orient){
    var len = 1; // a hozzáadott cella
    if (orient === 'H'){
      var cL = cc - 1;
      while (cL >= 0 && cellMainAt(rr, cL) === main){ len++; cL--; }
      var cR = cc + 1;
      while (cR < N && cellMainAt(rr, cR) === main){ len++; cR++; }
      return len;
    }
    // 'V'
    var rU = rr - 1;
    while (rU >= 0 && cellMainAt(rU, cc) === main){ len++; rU--; }
    var rD = rr + 1;
    while (rD < N && cellMainAt(rD, cc) === main){ len++; rD++; }
    return len;
  }

  function setShipAt(r,c, main){
    if (!inBounds(r,c)) return false;
    if (cellMainAt(r,c) !== '-') return false;
    MR[r][c] = main + '--';

    // workM szinkron (minimálisan, közvetlen)
    if (window.workM && workM[r]){
      var wrow = workM[r];
      if (!wrow[c] || typeof wrow[c] !== 'object'){
        wrow[c] = {kind:'ship', main:main, color:'--'};
      } else {
        wrow[c].kind = 'ship';
        wrow[c].main = main;
        wrow[c].color = '--';
      }
    }

    // Sarokvizezés az új hajómező körül (AUT1 logika)
    if (typeof auto_1_shipCornersFromReal === 'function') {
      auto_1_shipCornersFromReal();
    }

    applied++;
    { VALTOZAS = true; }
    return true;
  }

  // Komponens-alapú AUT18:
  // - 1 cellás komponensnél: marad a "pontosan 1 üres szomszéd" elv
  // - >=2 cellás komponensnél: csak akkor told, ha az irány már ismert és pontosan 1 végén van üres hely
  var visited = [];
  for (var rr = 0; rr < N; rr++){
    visited[rr] = [];
    for (var cc = 0; cc < N; cc++){
      visited[rr][cc] = false;
    }
  }

  for (var r = 0; r < N; r++){
    for (var c = 0; c < N; c++){
      if (visited[r][c]) continue;

      var main = cellMainAt(r,c);
      if (!isShipMain(main)) continue;

      // BFS komponens (azonos main, 4-szomszéd)
      var stack = [[r,c]];
      visited[r][c] = true;
      var cells = [];
      var minR = r, maxR = r, minC = c, maxC = c;

      while (stack.length){
        var cur = stack.pop();
        var cr = cur[0], cc = cur[1];
        cells.push([cr,cc]);
        if (cr < minR) minR = cr;
        if (cr > maxR) maxR = cr;
        if (cc < minC) minC = cc;
        if (cc > maxC) maxC = cc;

        for (var k = 0; k < deltas.length; k++){
          var nr = cr + deltas[k][0];
          var nc = cc + deltas[k][1];
          if (!inBounds(nr,nc)) continue;
          if (visited[nr][nc]) continue;
          if (cellMainAt(nr,nc) !== main) continue;
          visited[nr][nc] = true;
          stack.push([nr,nc]);
        }
      }

      // teljes hossz
      var fullLen = 0;
      try {
        if (typeof lengthOfShipCode === 'function'){
          fullLen = lengthOfShipCode(main);
        }
      } catch(e){
        fullLen = 0;
      }
      if (!fullLen || fullLen <= 0) continue;
      if (cells.length >= fullLen) continue;

      // 1 cellás: eredeti elv
      if (cells.length === 1){
        var er = cells[0][0], ec = cells[0][1];
        var emptyCount = 0;
        var emptyR = -1, emptyC = -1;
        for (var kk = 0; kk < deltas.length; kk++){
          var rr1 = er + deltas[kk][0];
          var cc1 = ec + deltas[kk][1];
          if (!inBounds(rr1,cc1)) continue;
          if (cellMainAt(rr1,cc1) === '-'){
            emptyCount++;
            emptyR = rr1;
            emptyC = cc1;
          }
        }
        if (emptyCount === 1){
          var ori1 = (emptyR === er) ? 'H' : 'V';
          if (runLenAfterAdd(emptyR, emptyC, main, ori1) <= fullLen){
            setShipAt(emptyR, emptyC, main);
          }
        }
        continue;
      }

      // >=2 cellás: irány megállapítása (csak egy tengelyen lehet)
      var isHorizontal = (minR === maxR && minC !== maxC);
      var isVertical   = (minC === maxC && minR !== maxR);
      if (!isHorizontal && !isVertical){
        // ha valamiért nem egy egyenes komponens, nem toldunk (bizonytalan)
        continue;
      }

      // Végpontok és jelöltek
      var cand = [];
      if (isHorizontal){
        var row = minR;
        var leftR = row, leftC = minC;
        var rightR = row, rightC = maxC;

        var c1r = leftR, c1c = leftC - 1;
        var c2r = rightR, c2c = rightC + 1;
        if (inBounds(c1r,c1c) && cellMainAt(c1r,c1c) === '-') cand.push([c1r,c1c]);
        if (inBounds(c2r,c2c) && cellMainAt(c2r,c2c) === '-') cand.push([c2r,c2c]);
      } else {
        var col = minC;
        var topR = minR, topC = col;
        var botR = maxR, botC = col;

        var c1r2 = topR - 1, c1c2 = topC;
        var c2r2 = botR + 1, c2c2 = botC;
        if (inBounds(c1r2,c1c2) && cellMainAt(c1r2,c1c2) === '-') cand.push([c1r2,c1c2]);
        if (inBounds(c2r2,c2c2) && cellMainAt(c2r2,c2c2) === '-') cand.push([c2r2,c2c2]);
      }

      // Ha mindkét vég nyitott, az kétértelmű (pont a te eseted: 2 ALFA/BETA mezőnél),
      // ezért NEM toldunk.
      if (cand.length !== 1) continue;

      // Toldás, ha még belefér
      if (cells.length + 1 <= fullLen){
        var ori2 = isHorizontal ? 'H' : 'V';
        if (runLenAfterAdd(cand[0][0], cand[0][1], main, ori2) <= fullLen){
          setShipAt(cand[0][0], cand[0][1], main);
        }
      }
    }
  }

  return applied;
}

</script>
<script>



window.auto_12_color_between_waters  = function auto_12_color_between_waters(){
  

  
  var MR = (typeof SMY!=='undefined' && SMY && SMY.M_REAL) ? SMY.M_REAL
           : (typeof M_REAL!=='undefined' ? M_REAL : null);
  var SR = (typeof SMY!=='undefined' && SMY && SMY.SOROK_REAL) ? SMY.SOROK_REAL
           : (typeof SOROK_REAL!=='undefined' ? SOROK_REAL : null);
  var OR = (typeof SMY!=='undefined' && SMY && SMY.OSZL_REAL) ? SMY.OSZL_REAL
           : (typeof OSZL_REAL!=='undefined' ? OSZL_REAL : null);

  if (!MR) { ; return 0; }

  var applied = 0;
  var N = MR.length;

  function isWaterCell(r,c){
    if (r<0||c<0||r>=N||!MR[r]||c>=MR[r].length) return false;
    var v = MR[r][c];
    if (!v) return false;
    var s = String(v);
    if (!s.length) return false;
    var t = s.charAt(0).toUpperCase();
    return ('01234V'.indexOf(t) >= 0);
  }


function isShipCell(r,c){
    if (r<0||c<0||r>=N||!MR[r]||c>=MR[r].length) return false;
    var v = MR[r][c];
    if (!v) return false;
    var s = String(v);
    if (!s.length) return false;
    var t = s.charAt(0).toUpperCase();
    return ('ABGDH'.indexOf(t) >= 0);
  }

  
  var col_ori='-', col_nei='-', col_com='-';
  var pr, pc;

  for (pr = 0; pr < N; pr++){
    if (!MR[pr]) continue;
    for (pc = 0; pc < MR[pr].length; pc++){
      if (!isWaterCell(pr,pc)) continue;

      
      if (isWaterCell(pr, pc+1)){
        var s0 = String(MR[pr][pc]); if (s0.length<3) s0 = (s0+'---').slice(0,3);
        var s1 = String(MR[pr][pc+1]); if (s1.length<3) s1 = (s1+'---').slice(0,3);
        col_ori = s0.charAt(2);
        col_nei = s1.charAt(2);

        if (col_ori === '-' && (col_nei === 'p' || col_nei === 'z' || col_nei === 'x')){
          applied++;
          MR[pr][pc] = s0.charAt(0) + s0.charAt(1) + col_nei;
        } else if (col_nei === '-' && (col_ori === 'p' || col_ori === 'z' || col_ori === 'x')){
          applied++;
          MR[pr][pc+1] = s1.charAt(0) + s1.charAt(1) + col_ori;
        }
      }

      
      if (isWaterCell(pr+1, pc)){
        var sv0 = String(MR[pr][pc]); if (sv0.length<3) sv0 = (sv0+'---').slice(0,3);
        var sv1 = String(MR[pr+1][pc]); if (sv1.length<3) sv1 = (sv1+'---').slice(0,3);
        col_ori = sv0.charAt(1);
        col_nei = sv1.charAt(1);

        if (col_ori === '-' && (col_nei === 'p' || col_nei === 'z' || col_nei === 'x')){
          applied++;
          MR[pr][pc] = sv0.charAt(0) + col_nei + sv0.charAt(2);
        } else if (col_nei === '-' && (col_ori === 'p' || col_ori === 'z' || col_ori === 'x')){
          applied++;
          MR[pr+1][pc] = sv1.charAt(0) + col_ori + sv1.charAt(2);
        }
      }
    }
  }

  

  // --- 12/b2: szomszédos HAJÓMEZŐK esetén is folyamatos szín ---
  for (pr = 0; pr < N; pr++){
    if (!MR[pr]) continue;
    for (pc = 0; pc < MR[pr].length; pc++){
      if (!isShipCell(pr,pc)) continue;

      // jobbra: vízszintes szín (index 2)
      if (isShipCell(pr, pc+1)){
        var s0s = String(MR[pr][pc]); if (s0s.length<3) s0s = (s0s+'---').slice(0,3);
        var s1s = String(MR[pr][pc+1]); if (s1s.length<3) s1s = (s1s+'---').slice(0,3);
        col_ori = s0s.charAt(2);
        col_nei = s1s.charAt(2);

        if (col_ori === '-' && (col_nei === 'p' || col_nei === 'z' || col_nei === 'x')){
          MR[pr][pc] = s0s.charAt(0) + s0s.charAt(1) + col_nei;
          applied++;
        } else if (col_nei === '-' && (col_ori === 'p' || col_ori === 'z' || col_ori === 'x')){
          MR[pr][pc+1] = s1s.charAt(0) + s1s.charAt(1) + col_ori;
          applied++;
        }
      }

      // le: függőleges szín (index 1)
      if (isShipCell(pr+1, pc)){
        var sv0s = String(MR[pr][pc]); if (sv0s.length<3) sv0s = (sv0s+'---').slice(0,3);
        var sv1s = String(MR[pr+1][pc]); if (sv1s.length<3) sv1s = (sv1s+'---').slice(0,3);
        col_ori = sv0s.charAt(1);
        col_nei = sv1s.charAt(1);

        if (col_ori === '-' && (col_nei === 'p' || col_nei === 'z' || col_nei === 'x')){
          MR[pr][pc] = sv0s.charAt(0) + col_nei + sv0s.charAt(2);
          applied++;
        } else if (col_nei === '-' && (col_ori === 'p' || col_ori === 'z' || col_ori === 'x')){
          MR[pr+1][pc] = sv1s.charAt(0) + col_ori + sv1s.charAt(2);
          applied++;
        }
      }
    }
  }

// --- 12/c: vízmező + fel/le, bal/jobb hajók → piros vonal + SOROK/OSZL_REAL ---

  function hasShipInDir(r,c,dr,dc){
    var rr = r + dr;
    var cc = c + dc;
    while (rr >= 0 && rr < N && cc >= 0 && MR[rr] && cc < MR[rr].length){
      if (isShipCell(rr,cc)) return true;
      rr += dr;
      cc += dc;
    }
    return false;
  }

  for (pr = 0; pr < N; pr++){
    if (!MR[pr]) continue;
    for (pc = 0; pc < MR[pr].length; pc++){
      if (!isWaterCell(pr,pc)) continue;

      var cell = String(MR[pr][pc]);
      if (cell.length<3) cell = (cell+'---').slice(0,3);
      var t0 = cell.charAt(0);
      var v0 = cell.charAt(1);
      var h0 = cell.charAt(2);
      var changedHere = false;

      
      if (hasShipInDir(pr,pc,-1,0) && hasShipInDir(pr,pc,+1,0)){
        if (v0 !== 'p'){
          v0 = 'p';
          changedHere = true;
        }
        if (OR && OR.length>pc && OR[pc] === '-'){
          OR[pc] = 'P';
        }
      }

      
      if (hasShipInDir(pr,pc,0,-1) && hasShipInDir(pr,pc,0,+1)){
        if (h0 !== 'p'){
          h0 = 'p';
          changedHere = true;
        }
        if (SR && SR.length>pr && SR[pr] === '-'){
          SR[pr] = 'P';
        }
      }

      if (changedHere){
        MR[pr][pc] = t0 + v0 + h0;
        applied++;
      }
    }
  }


  // [AUT12d] szomszédos víz és hajómező határán: ha a hajóban zöld vonal a határra merőleges,
  // akkor a víz a partig folytatódik (színtelen vízmezők; csak üres REAL+SHOT mezőkbe).
  // Feltétel: a hajó mellett KÖZVETLEN vízmező áll (V vagy 0..4).
  {
    var S12d = (typeof window !== 'undefined') ? window.SMY : undefined;
    var MS12d = (S12d && S12d.M_SHOT) ? S12d.M_SHOT : undefined;

    function isShipMain12d(t){ return (t==='A'||t==='B'||t==='G'||t==='D'||t==='H'); }
    function isWaterMain12d(t){ return (t==='V'||t==='0'||t==='1'||t==='2'||t==='3'||t==='4'); }

    function realCell12d(r,c){
      return (MR && MR[r] && typeof MR[r][c] === 'string') ? MR[r][c] : '---';
    }
    function mainAt12d(r,c){ var s = realCell12d(r,c); return (s.charAt(0) || '-'); }
    function shotMainAt12d(r,c){
      if(!MS12d || !MS12d[r]) return '-';
      var s = (typeof MS12d[r][c] === 'string') ? MS12d[r][c] : '---';
      return (s.charAt(0) || '-');
    }
    function placeWater12d(r,c){
      var cur = realCell12d(r,c);
      var vch = (cur.charAt(1) || '-');
      var hch = (cur.charAt(2) || '-');
      MR[r][c] = 'V' + vch + hch;
      if (typeof workM !== 'undefined' && workM && workM[r]) {
        workM[r][c] = {kind:'water', main:'V', color:'-'};
      }
      if (typeof updateWaterPointsAroundCell === 'function') updateWaterPointsAroundCell(r,c);
      applied++;
    }

    for (var r12=0; r12<N; r12++){
      for (var c12=0; c12<N; c12++){
        var cell = realCell12d(r12,c12);
        var t = (cell.charAt(0) || '-');
        if (!isShipMain12d(t)) continue;

        var vseg = (cell.charAt(1) || '-');
        var hseg = (cell.charAt(2) || '-');

        // Bal / jobb szomszéd: határ függőleges -> merőleges: vízszintes szegmens (3. karakter)
        if (hseg === 'z'){
          // bal oldal
          if (c12-1 >= 0 && isWaterMain12d(mainAt12d(r12, c12-1))){
            for (var cc = c12-1; cc >= 0; cc--){
              var tcur = mainAt12d(r12, cc);
              if (isShipMain12d(tcur)) break;
              if (tcur === '-' && shotMainAt12d(r12, cc) === '-') placeWater12d(r12, cc);
            }
          }
          // jobb oldal
          if (c12+1 < N && isWaterMain12d(mainAt12d(r12, c12+1))){
            for (var cc2 = c12+1; cc2 < N; cc2++){
              var tcur2 = mainAt12d(r12, cc2);
              if (isShipMain12d(tcur2)) break;
              if (tcur2 === '-' && shotMainAt12d(r12, cc2) === '-') placeWater12d(r12, cc2);
            }
          }
        }

        // Felső / alsó szomszéd: határ vízszintes -> merőleges: függőleges szegmens (2. karakter)
        if (vseg === 'z'){
          // felfelé
          if (r12-1 >= 0 && isWaterMain12d(mainAt12d(r12-1, c12))){
            for (var rr = r12-1; rr >= 0; rr--){
              var tcur3 = mainAt12d(rr, c12);
              if (isShipMain12d(tcur3)) break;
              if (tcur3 === '-' && shotMainAt12d(rr, c12) === '-') placeWater12d(rr, c12);
            }
          }
          // lefelé
          if (r12+1 < N && isWaterMain12d(mainAt12d(r12+1, c12))){
            for (var rr2 = r12+1; rr2 < N; rr2++){
              var tcur4 = mainAt12d(rr2, c12);
              if (isShipMain12d(tcur4)) break;
              if (tcur4 === '-' && shotMainAt12d(rr2, c12) === '-') placeWater12d(rr2, c12);
            }
          }
        }
      }
    }
  }


  
  return applied;
}

window.auto_12a_color_between_differents  = function auto_12a_color_between_differents(){
  

  
  var MR = (typeof SMY!=='undefined' && SMY && SMY.M_REAL) ? SMY.M_REAL
           : (typeof M_REAL!=='undefined' ? M_REAL : null);
  if (!MR) { ; return 0; }

  var applied=0;

  function isWaterCell(r,c)
  {
    
    if (r<0||c<0||r>8||c>8) return false;
    var v = MR[r][c];
    if (v==null) return false;
    var s = String(v);
    if (!s.length) return false;
    var t = s.charAt(0).toUpperCase();
    
    if ('01234V'.indexOf(t) >= 0) return true;
    if (t === '-'){
      var s3 = (s+'---').slice(0,3);
      if (s3.charAt(1) === 'p' || s3.charAt(2) === 'p') return true;
    }
    return false;
  }
   function isShipCell(r,c)
  {
    
    if (r<0||c<0||r>8||c>8) return false;
	var v = MR[r][c][0];
    if (v==null) return false;
    var s=String(v).toUpperCase();
    return ('ABGDH'.indexOf(s[0])>=0);
  }
  var col_ori='-', col_nei='-', col_com='-';
  
  for (var pr=2; pr<7; pr++)
  {
    for (var pc=0; pc<9; pc++)
    {   
      if( !isShipCell(pr,pc) || !(MR[pr][pc][1] === 'p')) continue;
      if( isWaterCell(pr+1,pc) && MR[pr+1][pc][1] === '-' ) 
	  { 
	      MR[pr+1][pc] = MR[pr+1][pc][0]+'p'+MR[pr+1][pc][2]; applied++;
	  }
	  if( isWaterCell(pr-1,pc) && MR[pr-1][pc][1] === '-' ) 
	  { 
	      MR[pr-1][pc] = MR[pr-1][pc][0]+'p'+MR[pr-1][pc][2]; applied++;
	  }
	}
  }
  
  for (var pc=2; pc<7; pc++)
  {
    for (var pr=0; pr<9; pr++)
    {  
      if( !isShipCell(pr,pc) || !(MR[pr][pc][2] === 'p')) continue;
	  
      if( isWaterCell(pr,pc+1) && MR[pr][pc+1][2] === '-' ) 
	  {
	   MR[pr][pc+1] = MR[pr][pc+1][0]+MR[pr][pc+1][1]+'p'; applied++;
	  }
	  if( isWaterCell(pr,pc-1) && MR[pr][pc-1][2] === '-' ) 
	  {
	   MR[pr][pc-1] = MR[pr][pc-1][0]+MR[pr][pc-1][1]+'p'; applied++;
	  }
	}
  }
  
  return applied;
}

</script>


<div id="mozgatas_panel" style="margin:4px auto 0 auto;padding:4px 2px;border:1px solid #ccc;border-radius:8px;display:inline-block">
  <div style="position:relative;display:flex;flex-wrap:wrap;gap:9px;justify-content:center;align-items:center;padding-left:30mm;">
    <button id="btnSmyozHelp" onclick="toggleSmyozHelp(true)" style="position:absolute;left:0;background:#00c853;border:1px solid #00a844;border-radius:6px;padding:4px 10px;font-weight:700;color:#ffffff;min-width:70px;">SÚGÓ</button>
    <button onclick="TORLES_WORK();TORLES_REAL()">TÖRLÉS</button>
    <button onclick="MENTES()">MENTÉS</button>
    <button onclick="VISSZATOLTES()">VISSZATÖLTÉS</button>
  </div>
</div>
<script>

(function(){
  if (window.SMY_hardResetView) return; 
  window.SMY_clearSegmentLayers = function(){
    {
      var grid = document.getElementById('grid');
      if(!grid) return;
      var segs = grid.querySelectorAll('.rc-segV, .rc-segH');
      for (var i=0;i<segs.length;i++){
        var n = segs[i];
        if (n._stripe && n._stripe.parentNode) n._stripe.parentNode.removeChild(n._stripe);
          n._stripe = null;
        n.style.display = 'none';
      }
    }
  };
  window.SMY_clearOverlays = function(){
    var gS = document.getElementById('gSegments');
      var gP = document.getElementById('gPoints');
      if (gS) gS.innerHTML = '';
      if (gP) gP.innerHTML = '';
      // placeOverlay ürítés marad, az automatizmus panel (autoOverlay) tartalmát nem bántjuk
      var o = document.getElementById('placeOverlay'); if (o) o.innerHTML = '';
  };
  window.SMY_hardResetView = function(){
    window.SMY_clearOverlays();
      window.SMY_clearSegmentLayers();
  };
})();
</script>
<script>
// [SMY FOLYTAT] Minimal, lokális vezérlés a Homokozó ELVET/FOLYTAT gombhoz.
// Feltételek: nem nyúlunk az állapotgép logikájához; csak (1) FOLYTATAS beállítása,
// (2) a gomb felirat/szín, és (3) az első fázis indítása FOLYTAT esetén.
(function(){
  
  if (typeof FOLYTATAS === 'undefined') { FOLYTATAS = false; }

  function $(id){ return document.getElementById(id); }
  function labelGreen(btn, on){
    if(!btn) return;
    btn.style.background = on ? '#eaffea' : '#eee';
    btn.style.border = on ? '1px solid #9bd49b' : '1px solid #cfcfcf';
    btn.style.color = on ? '#0a6d0a' : '#444';
  }
  function setLabel(btn, txt){
    if(!btn) return;
    btn.textContent = txt;
    
    labelGreen(btn, txt==='FOLYTAT');
  }
  function homokozoRoot(){
    return $('homokozo_panel') || document.body;
  }
  function findButtonByText(root, text){
    var btns = (root||document).getElementsByTagName('button');
    text = String(text||'').toUpperCase();
    for (var i=0;i<btns.length;i++){
      var t = (btns[i].textContent||'').trim().toUpperCase();
      if (t === text) return btns[i];
    }
    return null;
  }

  function initFolytat(){
    var root = homokozoRoot();

    
    var elhelyez = findButtonByText(root, 'ELHELYEZ');
    if (elhelyez && !elhelyez.__folyt_bind){
      elhelyez.addEventListener('click', function(){ var _lab = (elvet && elvet.textContent ? elvet.textContent : '').trim().toUpperCase(); if (_lab === 'FOLYTAT') { FOLYTATAS = false;  } }, true);
      elhelyez.__folyt_bind = true;
    }

    // Meglévő/gyártott ELVET gomb – toggle módra használjuk (FOLYTAT/ELVET)
    var elvet = null;
    if (typeof ensureElvetBtn === 'function') elvet = ensureElvetBtn();
    if (!elvet) elvet = findButtonByText(root, 'ELVET');
    if (!elvet) return; 

    // Mindig látszódjon – alapállapotban is.
    elvet.style.display = '';
    
    setLabel(elvet, 'FOLYTAT');

    // Kapcsoló logika: ha FOLYTAT, beállítjuk FOLYTATAS=true és belépünk az 1-es fázisba.
    if (!elvet.__folyt_click){
      elvet.addEventListener('click', function(ev){
        var label = (elvet.textContent||'').trim().toUpperCase();
        if (label === 'FOLYTAT'){
          FOLYTATAS = true;
          
          setLabel(elvet, ' ELVET ');  
          {
            if (typeof setElhelyezesState === 'function'){
              setElhelyezesState(1, 'FOLYTAT'); 
            }
          }
          
          ev.stopImmediatePropagation();
          ev.preventDefault();
          return false;
        } else {
          
          // hogy az alapállapot gombkiosztása megmaradjon.
          setTimeout(function(){ elvet.style.display=''; setLabel(elvet, 'FOLYTAT'); }, 0);
        }
      }, true);
      elvet.__folyt_click = true;
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', initFolytat);
  } else {
    initFolytat();
  }
})();
</script>
<script>
// [SMY FOLYTAT] Állapotmentés gating: ha FOLYTATAS===true, a snapshot/mentés kimarad.
(function(){
  function gateSave(name){
    var f = (typeof window[name] === 'function') ? window[name] : null;
    if (!f || f.__folyt_gate) return;
    var orig = f;
    var g = function(){
      if (FOLYTATAS === true){
        
        return;
      }
      return orig.apply(this, arguments);
    };
    g.__folyt_gate = true;
    window[name] = g;
  }
  var suspects = ['takeSnapshot','MENTES','clearSnapshot','saveState','saveSnapshot'];
  for (var i=0;i<suspects.length;i++) gateSave(suspects[i]);
})();
</script>
<script>
(function(){
  function lockWidths(){
    var root = document.getElementById('homokozo_panel') || document;
    function findBtn(txt){
      var bts = root.getElementsByTagName('button');
      txt = String(txt||'').toUpperCase();
      for(var i=0;i<bts.length;i++){
        var t=(bts[i].textContent||'').trim().toUpperCase();
        if(t===txt) return bts[i];
      }
      return null;
    }
    var elvet = findBtn('FOLYTAT') || findBtn('ELVET');
    var elhely = findBtn('ELHELYEZ');

    function measure(label){
      var meas = document.createElement('button');
      meas.textContent = label;
      meas.style.cssText = 'position:absolute;visibility:hidden;white-space:nowrap;padding:5px 10px;font-weight:800;';
      document.body.appendChild(meas);
      var w = meas.offsetWidth;
      meas.remove();
      return w;
    }
    var w = Math.max(measure('FOLYTAT'), measure('ELVET'));
    if (elvet){ elvet.style.minWidth = (w+6)+'px'; elvet.style.display='inline-block'; elvet.style.whiteSpace='nowrap'; }
    if (elhely){ elhely.style.minWidth = (w+6)+'px'; elhely.style.display='inline-block'; elhely.style.whiteSpace='nowrap'; }
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', lockWidths);
  else lockWidths();
})();
</script>
<script>
(function(){
  function root(){ return document.getElementById('homokozo_panel') || document; }
  function findBtn(txt){
    var r = root(), b = r.getElementsByTagName('button'); txt = String(txt||'').toUpperCase();
    for (var i=0;i<b.length;i++){ var t=(b[i].textContent||'').trim().toUpperCase(); if (t===txt) return b[i]; }
    return null;
  }
  function cloneMeasure(btn, label){
    if (!btn) return 0;
    var s = getComputedStyle(btn);
    var ghost = btn.cloneNode(false);
    ghost.textContent = label;
    ghost.style.position='absolute';
    ghost.style.visibility='hidden';
    ghost.style.left='-9999px';
    ghost.style.top='-9999px';
    ghost.style.width='auto';
    ghost.style.whiteSpace='nowrap';
    ghost.style.font = s.font;
    ghost.style.fontWeight = s.fontWeight;
    ghost.style.fontSize = s.fontSize;
    ghost.style.paddingLeft = s.paddingLeft;
    ghost.style.paddingRight = s.paddingRight;
    ghost.style.paddingTop = s.paddingTop;
    ghost.style.paddingBottom = s.paddingBottom;
    ghost.style.border = s.border;
    document.body.appendChild(ghost);
    var w = ghost.offsetWidth;
    document.body.removeChild(ghost);
    return w;
  }
  function lockWidths(){
    var toggle = findBtn('FOLYTAT') || findBtn('ELVET') || null;
    var elhely = findBtn('ELHELYEZ') || null;
    if (!toggle || !elhely) return;

    // Compute max width for toggle between its two labels using real styles
    var wToggle = Math.max(cloneMeasure(toggle,'FOLYTAT'), cloneMeasure(toggle,'ELVET'));
    // Fix the ELHELYEZ width to its real width
    var wElhely = cloneMeasure(elhely, 'ELHELYEZ');

    toggle.style.width = (wToggle) + 'px';
    toggle.style.display = 'inline-block';
    toggle.style.whiteSpace = 'nowrap';

    elhely.style.width = (wElhely) + 'px';
    elhely.style.display = 'inline-block';
    elhely.style.whiteSpace = 'nowrap';
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', lockWidths);
  else lockWidths();
})();
</script>
<script>

</script>
<script>


function diagRefreshVectors(){
    var e1 = document.getElementById('dg2_sorok_real');
      var e2 = document.getElementById('dg2_oszl_real');
      if(e1) e1.textContent = (window.SMY && Array.isArray(SMY.SOROK_REAL)) ? SMY.SOROK_REAL.join(' ') : '–';
      if(e2) e2.textContent = (window.SMY && Array.isArray(SMY.OSZL_REAL)) ? SMY.OSZL_REAL.join(' ') : '–';
  }


function enforceAuto13WaterVectors()
{
  
  var S = window.SMY;
  var hasS = !!S;
  var hasM = !!(S && S.M_REAL);
  var N   = hasM ? (S.M_REAL.length|0) : -1;
  {
//     console.log('[AUT13][ENTER]', {hasS:hasS, hasM:hasM, N:N, SOROK:(S&&S.SOROK_REAL)||null, OSZL:(S&&S.OSZL_REAL)||null});
  }
  if(!hasS || !hasM){ ; return 0; }

  
  if (!Array.isArray(S.SOROK_REAL) || S.SOROK_REAL.length!==N) S.SOROK_REAL = new Array(N).fill('-');
  if (!Array.isArray(S.OSZL_REAL)  || S.OSZL_REAL.length!==N)  S.OSZL_REAL  = new Array(N).fill('-');
//   { console.log('[AUT13][AFTER_INIT]', {SOROK:S.SOROK_REAL.slice(), OSZL:S.OSZL_REAL.slice()}); }

  var prevRowV = 0, prevColV = 0;
  for (var r=0;r<N;r++) if (S.SOROK_REAL[r]==='V') prevRowV++;
  for (var c=0;c<N;c++) if (S.OSZL_REAL[c]==='V') prevColV++;
//   { console.log('[AUT13][PREV_COUNTS]', {prevRowV:prevRowV, prevColV:prevColV}); }

  // Rows: Vz jelölés generál sorV-t
  for (var r=0; r<N; r++){
    if (S.SOROK_REAL[r]==='Z'){
      var makeV = false;
      for (var c=0; c<N; c++){
        var cell = (S.M_REAL[r] && S.M_REAL[r][c]) ? S.M_REAL[r][c] : '---';
        var main = cell.charAt ? cell.charAt(0) : '-';
var c1   = cell.charAt ? cell.charAt(1) : '-';
var c2   = cell.charAt ? cell.charAt(2) : '-';
var isWater = (main==='V' || main==='0' || main==='1' || main==='2' || main==='3' || main==='4');
if (isWater && ( c2==='z')){ makeV = true; break; }
      }
      if (makeV){ S.SOROK_REAL[r] = 'V';  }
    }
  }
  
  for (var c=0; c<N; c++){
    if (S.OSZL_REAL[c]==='Z'){
      var makeVc = false;
      for (var r=0; r<N; r++){
        var cell2 = (S.M_REAL[r] && S.M_REAL[r][c]) ? S.M_REAL[r][c] : '---';
        var main2 = cell2.charAt ? cell2.charAt(0) : '-';
var c12   = cell2.charAt ? cell2.charAt(1) : '-';
var c22   = cell2.charAt ? cell2.charAt(2) : '-';
var isWater2 = (main2==='V' || main2==='0' || main2==='1' || main2==='2' || main2==='3' || main2==='4');
if (isWater2 && (c12==='z' )){ makeVc = true; break; }
      }
      if (makeVc){ S.OSZL_REAL[c] = 'V';  }
    }
  }

  var nowRowV = 0, nowColV = 0;
  for (var rr=0;rr<N;rr++) if (S.SOROK_REAL[rr]==='V') nowRowV++;
  for (var cc=0;cc<N;cc++) if (S.OSZL_REAL[cc]==='V') nowColV++;
  var newly = (nowRowV - prevRowV) + (nowColV - prevColV);
//   { console.log('[AUT13][NOW_COUNTS]', {nowRowV:nowRowV, nowColV:nowColV, newly:newly}); }

  if (newly>0){
    var old_nVS = (typeof S.nVS==='number') ? S.nVS : null;
    if (typeof S.nVS !== 'number' && typeof S.nVV === 'number') S.nVS = S.nVV;
    if (typeof S.nVS === 'number') S.nVS = Math.max(0, S.nVS - newly);
    {  }
  }

  // [AUT13] Új vízmezők telepítése a biztos vízvonalak mentén (csak üres, még nem lőtt mezőkbe)
  {
    var MR = S.M_REAL;
    var MS = S.M_SHOT;
    if (MR && MS){
      
      for (var r2=0; r2<N; r2++){
        if (S.SOROK_REAL[r2] !== 'V') continue;
        for (var c2=0; c2<N; c2++){
          var shot = (MS[r2] && typeof MS[r2][c2] === 'string') ? MS[r2][c2] : '---';
          var real = (MR[r2] && typeof MR[r2][c2] === 'string') ? MR[r2][c2] : '---';
          var sMain = shot.charAt(0) || '-';
          var rMain = real.charAt(0) || '-';
          if (sMain !== '-' || rMain !== '-') continue; // csak teljesen üres SHOT+REAL
          var vch = real.charAt(1) || '-';
          var hch = real.charAt(2) || '-';
          MR[r2][c2] = 'V' + vch + 'z';
          if (typeof workM !== 'undefined' && workM && workM[r2]){
            
            workM[r2][c2] = {kind:'water', main:'V', color:'-'};
          }
        }
      }
      
      for (var c3=0; c3<N; c3++){
        if (S.OSZL_REAL[c3] !== 'V') continue;
        for (var r3=0; r3<N; r3++){
          var shot2 = (MS[r3] && typeof MS[r3][c3] === 'string') ? MS[r3][c3] : '---';
          var real2 = (MR[r3] && typeof MR[r3][c3] === 'string') ? MR[r3][c3] : '---';
          var sMain2 = shot2.charAt(0) || '-';
          var rMain2 = real2.charAt(0) || '-';
          if (sMain2 !== '-' || rMain2 !== '-') continue;
          var vch2 = real2.charAt(1) || '-';
          var hch2 = real2.charAt(2) || '-';
          MR[r3][c3] = 'V' + 'z' + hch2;
          if (typeof workM !== 'undefined' && workM && workM[r3]){
            
            workM[r3][c3] = {kind:'water', main:'V', color:'-'};
          }
        }
      }
    }
  }

  if (typeof diagRefreshVectors==='function') diagRefreshVectors();
  {  }
  return newly;
}


function auto_13b_fix_colors_from_vectors(){
  // 13/b: Teljestáblás átnézés.
  // A) SHOT → REAL promóció (csak akkor, ha ISHOT_REAL[r][c] === true).
  // B) Vektor-kitöltés biztos irányú M_REAL-ból (csak hajómezőknél, és csak '-' helyre).
  // C) Zöld vízmező + sor/oszlop vektorban 'Z' eset: a vízvonal merőleges, ezért a másik irányú vektorba 'V' beírható (ha még '-').
  //
  // Színhelyeken csak '-', 'p', 'z' értékek vannak (x-et most kihagyjuk).

  var applied = 0;

  var S = window.SMY;
  if(!S || !S.M_REAL || !S.SOROK_REAL || !S.OSZL_REAL) return 0;

  var MR = S.M_REAL;
  var SR = S.SOROK_REAL;
  var OR = S.OSZL_REAL;
  var N  = MR.length;

  function up(c){ return (c==='p') ? 'P' : (c==='z') ? 'Z' : (c==='P' || c==='Z' || c==='V' || c==='-') ? c : '-'; }
  function low(c){ return (c==='P') ? 'p' : (c==='Z') ? 'z' : '-'; }
  function hasP(tok){ return tok.indexOf('p') >= 0; }
  function hasZ(tok){ return tok.indexOf('z') >= 0; }
  function isShipT(t){ return t==='A' || t==='B' || t==='G' || t==='D' || t==='H'; }
  function isWaterT(t){ return t==='V' || t==='0' || t==='1' || t==='2' || t==='3' || t==='4'; }

  // A) SHOT → REAL (csak garantált lövésnél)
  if(S.M_SHOT && S.ISHOT_REAL){
    var MS = S.M_SHOT;
    var IR = S.ISHOT_REAL;

    for(var r=0; r<N; r++){
      var rowU = up(SR[r]); // 'P','Z','V','-'
      for(var c=0; c<N; c++){
        if(IR[r][c] !== true) continue; // csak garantált lövésnél
        var colU = up(OR[c]);

        var realTok = MR[r][c];
        var rt = realTok.charAt(0);
        var rc1 = realTok.charAt(1); // OSZL
        var rc2 = realTok.charAt(2); // SOROK

        var shotTok = MS[r][c];
        var hp = hasP(shotTok);
        var hz = hasZ(shotTok);

        // csak EGYszínű lövés érdekes itt
        if( (hp && hz) || (!hp && !hz) ) continue;
        var shotU = hp ? 'P' : 'Z';

        if(shotU==='Z' && (isWaterT(rt) || isWaterT(shotTok.charAt(0)))){
          var rowUcur = up(SR[r]);
          if(rc1!=='z' && rc2!=='z' && rowUcur!=='V' && colU!=='V'){
            var rowHas = (rowUcur==='P' || rowUcur==='Z');
            var colHas = (colU==='P' || colU==='Z');
            if(rowHas && !colHas){
              if(OR[c] === '-') { OR[c] = 'V'; applied++; }
              if(rc1==='-'){
                rc1 = 'z'; applied++;
                MR[r][c] = String(rt)+String(rc1)+String(rc2);
              }
              continue;
            }else if(colHas && !rowHas){
              if(SR[r] === '-') { SR[r] = 'V'; applied++; }
              if(rc2==='-'){
                rc2 = 'z'; applied++;
                MR[r][c] = String(rt)+String(rc1)+String(rc2);
              }
              continue;
            }
          }
        }

        // 1) Ha a sor vektor ismert és MÁSIK, akkor az oszlop vektor = shot szín determinált.
        if((rowU==='P' || rowU==='Z') && rowU !== shotU){
          if(OR[c] === '-') { OR[c] = shotU; applied++; }

          if(rc1==='-'){
            rc1 = low(shotU); applied++;
            MR[r][c] = String(rt)+String(rc1)+String(rc2);
          }
          continue;
        }

        // 2) Ha az oszlop vektor ismert és MÁSIK, akkor a sor vektor = shot szín determinált.
        if((colU==='P' || colU==='Z') && colU !== shotU){
          if(SR[r] === '-') { SR[r] = shotU; applied++; }

          if(rc2==='-'){
            rc2 = low(shotU); applied++;
            MR[r][c] = String(rt)+String(rc1)+String(rc2);
          }
          continue;
        }

        // Egyéb esetekben még nem determinált az irány (pl. vektorok üresek vagy egyeznek a shot színnel).
      }
    }
  }

  // B) Vektor-kitöltés biztos irányú M_REAL-ból (csak hajómezőnél, csak '-' helyre)
  for(var r2=0; r2<N; r2++){
    for(var c2=0; c2<N; c2++){
      var tok2 = MR[r2][c2];
      var t2 = tok2.charAt(0);
      if(!isShipT(t2)) continue;

      var cc1 = tok2.charAt(1); // OSZL
      var cc2 = tok2.charAt(2); // SOROK

      if((cc1==='p' || cc1==='z') && OR[c2] === '-'){
        OR[c2] = up(cc1); applied++;
      }
      if((cc2==='p' || cc2==='z') && SR[r2] === '-'){
        SR[r2] = up(cc2); applied++;
      }
    }
  }

  // C) Zöld vízmező + vektorban 'Z' ⇒ merőleges vízvonal: a másik irányú vektorba 'V' írható (ha '-')
  for(var r3=0; r3<N; r3++){
    for(var c3=0; c3<N; c3++){
      var tok3 = MR[r3][c3];
      var t3 = tok3.charAt(0);
      if(!isWaterT(t3)) continue;

      var w1 = tok3.charAt(1);
      var w2 = tok3.charAt(2);

      // egyszínű zöld: pontosan az egyik helyen 'z', a másikon '-'
      var greenSingle = (w1==='z' && w2==='-') || (w1==='-' && w2==='z');
      if(!greenSingle) continue;

      if(SR[r3] === 'Z' && OR[c3] === '-'){
        OR[c3] = 'V'; applied++;
      }else if(OR[c3] === 'Z' && SR[r3] === '-'){
        SR[r3] = 'V'; applied++;
      }
    }
  }

  // D) 13/d: Parti tetszőleges típusú mezőben lévő piros mindig párhuzamos a parttal:
  //           a piros irányt promótáljuk az M_REAL-ban (átírjuk a megfelelő C1/C2 helyre),
  //           és beírjuk a SOROK_REAL / OSZL_REAL vektorba, ha még nincs beírva.
  for(var r4=0; r4<N; r4++){
    for(var c4=0; c4<N; c4++){
      if(!(r4===0 || c4===0 || r4===N-1 || c4===N-1)) continue; // nem parti mező

      // Sarokban ilyen nem fordul elő (és itt nem is kezeljük)
      if((r4===0 || r4===N-1) && (c4===0 || c4===N-1)) continue;

      var tok4 = MR[r4][c4];
      if(!tok4 || typeof tok4 !== 'string' || tok4.length < 3) continue;

      var t4 = tok4.charAt(0);
      var c1 = tok4.charAt(1); // OSZL irány
      var c2 = tok4.charAt(2); // SOROK irány

      // A piros forrása lehet már REAL-ban, vagy csak SHOT-ban (nézet miatt látszik)
      var shot4 = (S.M_SHOT && S.M_SHOT[r4]) ? (S.M_SHOT[r4][c4] || '') : '';
      var hasRed4 = (c1==='p' || c2==='p' || (shot4 && shot4.indexOf('p') >= 0));
      if(!hasRed4) continue;

      if(r4===0 || r4===N-1){
        // felső/alsó part: a piros mindig vízszintes (SOROK, C2)
        if(c2!=='p'){
          MR[r4][c4] = String(t4)+String(c1)+String('p');
          applied++;
        }
        if(SR[r4] === '-'){ SR[r4] = 'P'; applied++; }
      }else if(c4===0 || c4===N-1){
        // bal/jobb part: a piros mindig függőleges (OSZL, C1)
        if(c1!=='p'){
          MR[r4][c4] = String(t4)+String('p')+String(c2);
          applied++;
        }
        if(OR[c4] === '-'){ OR[c4] = 'P'; applied++; }
      }
    }
  }



  return applied;
}



</script>
<script>

window.__LAST_MINTA = 0; 

// Aliases a SNAP-hoz (nem hozunk létre új mátrixot)
SMY.M_SNAP = SMY.M_SNAP;
SMY.P_SNAP = SMY.P_SNAP;




// --- 1) TÖRLÉS_REAL ---
// MINDENT törlünk: M_REAL, P_REAL, M_SHOT, P_SHOT, HOMOK/SHOT flagek.
// Végén P_REAL = '-' + SOROK/OSZL_REAL ürítése, majd REDRAW (btnRedrawReal).
function TORLES_REAL(){
  var N = (SMY && SMY.M_REAL && SMY.M_REAL.length) || 9;
  var r,c,i;
  for (r = 0; r < N; r++){
    for (c = 0; c < N; c++){
      
      if (SMY.M_REAL && SMY.M_REAL[r]) SMY.M_REAL[r][c] = '---';
      if (SMY.P_REAL && SMY.P_REAL[r]) SMY.P_REAL[r][c] = '-';
      // SHOT ürítés (LÖVÉS szint)
      if (SMY.M_SHOT && SMY.M_SHOT[r]) SMY.M_SHOT[r][c] = '---';
      if (SMY.P_SHOT && SMY.P_SHOT[r]) SMY.P_SHOT[r][c] = '-';
      // HOMOK / LÖVÉS flagek ürítése
      if (SMY.HOMOK_REAL && SMY.HOMOK_REAL[r]) SMY.HOMOK_REAL[r][c] = false;
      if (SMY.ISHOT_REAL && SMY.ISHOT_REAL[r]) SMY.ISHOT_REAL[r][c] = false;
    }
  }
  // SOROK/OSZL_REAL vektorok ürítése
  {
    if (SMY && Array.isArray(SMY.SOROK_REAL)){
      for (i = 0; i < SMY.SOROK_REAL.length; i++){ SMY.SOROK_REAL[i] = '-'; }
    }
    if (SMY && Array.isArray(SMY.OSZL_REAL)){
      for (i = 0; i < SMY.OSZL_REAL.length; i++){ SMY.OSZL_REAL[i] = '-'; }
    }
  }

  // Szegmens-layer törlése (REAL-szinthez kapcsolódó overlay)
  var gs = document.getElementById('gSegments'); if (gs) gs.innerHTML = '';

  // REAL → VIEW frissítés: REDRAW gomb meghívása
  var b = document.getElementById('btnRedrawReal'); if (b && b.click) b.click();
}


function TORLES_WORK(){
  var N = workM.length || 9;
  var r=0,c=0;
  for(r=0;r<N;r++){
    for(c=0;c<N;c++){
      workM[r][c] = { T:'-', C1:'-', C2:'-' };  
      workP[r][c] = '-';
    }
  }
  var gp = document.getElementById('gPoints'); if (gp) gp.innerHTML='';
  var pl = document.getElementById('POINTS_LAYER'); if (pl) pl.innerHTML='';
}


function MENTES() {

  var i=0,j=0,k;
  // --- MATRIX (TCC) ---
  for(i=0;i<SMY.M_REAL.length;i++){ for(j=0;j<SMY.M_REAL[0].length;j++){ SMY.M_SNAP[i][j] = SMY.M_REAL[i][j]; } }
  
  for(i=0;i<SMY.P_REAL.length;i++){ for(j=0;j<SMY.P_REAL[0].length;j++){ SMY.P_SNAP[i][j] = SMY.P_REAL[i][j]; } }
  for(i=0;i<SMY.HOMOK_REAL.length;i++){ for(j=0;j<SMY.HOMOK_REAL[0].length;j++){ SMY.HOMOK_SNAP[i][j] = SMY.HOMOK_REAL[i][j]; }}
  for(i=0;i<SMY.ISHOT_REAL.length;i++){ for(j=0;j<SMY.ISHOT_REAL[0].length;j++){ SMY.ISHOT_SNAP[i][j] = SMY.ISHOT_REAL[i][j]; }}
  
  for(i=0;i<SMY.SOROK_REAL.length;i++){ SMY.SOROK_SNAP[i] = SMY.SOROK_REAL[i]; }
  for(i=0;i<SMY.OSZL_REAL.length;i++){  SMY.OSZL_SNAP[i]  = SMY.OSZL_REAL[i]; }
  
  for(i=0;i<SMY.KERET_REAL.length;i++){ for(j=0;j<SMY.KERET_REAL[0].length;j++){ SMY.KERET_SNAP[i][j] = SMY.KERET_REAL[i][j]; } }
  
  for(i=0;i<SMY.nMS.length;i++){ SMY.nMS_SNAP[i] = SMY.nMS[i]; }
  for(i=0;i<SMY.nMO.length;i++){ SMY.nMO_SNAP[i] = SMY.nMO[i]; }
  
  SMY.nMM_SNAP  = SMY.nMM;
  SMY.nPP_SNAP  = SMY.nPP;
  SMY.nMVP_SNAP = SMY.nMVP;
  SMY.nVP_SNAP  = SMY.nVP;
  
  for(i=0;i<workM.length;i++){ for(j=0;j<workM[0].length;j++){ SMY.workM_SNAP[i][j] = workM[i][j]; } }
  for(i=0;i<workP.length;i++){ for(j=0;j<workP[0].length;j++){ SMY.workP_SNAP[i][j] = workP[i][j]; } }
  
  if (SMY.CFG) {
    if (!SMY.CFG_SNAP) SMY.CFG_SNAP = {};
    for (k in SMY.CFG) { SMY.CFG_SNAP[k] = SMY.CFG[k]; }
  }
  if (typeof window.RC_CONF !== 'undefined') {
    if (typeof window.RC_CONF_SNAP === 'undefined') window.RC_CONF_SNAP = {};
    for (k in window.RC_CONF) { window.RC_CONF_SNAP[k] = window.RC_CONF[k]; }
  }
}


function VISSZATOLTES() {
  TORLES_REAL();

  var i=0,j=0,k;
  // --- MATRIX (TCC) ---
  for(i=0;i<SMY.M_REAL.length;i++){ for(j=0;j<SMY.M_REAL[0].length;j++){ var __code4 = SMY.M_SNAP[i][j]; SMY.M_REAL[i][j] = __code4;  } }
  
  for(i=0;i<SMY.P_REAL.length;i++){ for(j=0;j<SMY.P_REAL[0].length;j++){ SMY.P_REAL[i][j] = SMY.P_SNAP[i][j]; } }
  for(i=0;i<SMY.HOMOK_REAL.length;i++){ for(j=0;j<SMY.HOMOK_REAL[0].length;j++){ SMY.HOMOK_REAL[i][j] = SMY.HOMOK_SNAP[i][j]; } }
  for(i=0;i<SMY.ISHOT_REAL.length;i++){ for(j=0;j<SMY.ISHOT_REAL[0].length;j++){ SMY.ISHOT_REAL[i][j] = SMY.ISHOT_SNAP[i][j]; } }
  
  for(i=0;i<SMY.SOROK_REAL.length;i++){ SMY.SOROK_REAL[i] = SMY.SOROK_SNAP[i]; }
  for(i=0;i<SMY.OSZL_REAL.length;i++){  SMY.OSZL_REAL[i]  = SMY.OSZL_SNAP[i]; }
  
  for(i=0;i<SMY.KERET_REAL.length;i++){ for(j=0;j<SMY.KERET_REAL[0].length;j++){ SMY.KERET_REAL[i][j] = SMY.KERET_SNAP[i][j]; } }
  
  for(i=0;i<SMY.nMS.length;i++){ SMY.nMS[i] = SMY.nMS_SNAP[i]; }
  for(i=0;i<SMY.nMO.length;i++){ SMY.nMO[i] = SMY.nMO_SNAP[i]; }
  
  SMY.nMM  = SMY.nMM_SNAP;
  SMY.nPP  = SMY.nPP_SNAP;
  SMY.nMVP = SMY.nMVP_SNAP;
  SMY.nVP  = SMY.nVP_SNAP;
  
  for(i=0;i<workM.length;i++){ for(j=0;j<workM[0].length;j++){ workM[i][j] = SMY.workM_SNAP[i][j]; } }
  for(i=0;i<workP.length;i++){ for(j=0;j<workP[0].length;j++){ workP[i][j] = SMY.workP_SNAP[i][j]; } }
  
    if (SMY.CFG_SNAP) {
    if (!SMY.CFG) SMY.CFG = {};
    for (k in SMY.CFG_SNAP) { SMY.CFG[k] = SMY.CFG_SNAP[k]; }
  }
  if (typeof window.RC_CONF_SNAP !== 'undefined') {
    if (typeof window.RC_CONF === 'undefined') window.RC_CONF = {};
    for (k in window.RC_CONF_SNAP) { window.RC_CONF[k] = window.RC_CONF_SNAP[k]; }
  }
  // --- Overlay rétegek kemény törlése + per-cell szegmens reset ---
 
  if (typeof gSegments !== 'undefined' && gSegments) gSegments.innerHTML = '';
  if (typeof gPoints   !== 'undefined' && gPoints)   gPoints.innerHTML   = '';
  /*
  var _o;   //  RA  ez lőtte ki az AUTOM legördülőt
  _o = document.getElementById('autoOverlay');  if(_o) _o.innerHTML = '';
  _o = document.getElementById('placeOverlay'); if(_o) _o.innerHTML = '';
  */
  if (typeof clearRings === 'function') { clearRings(); }
  
  var N = SMY.M_REAL.length;
  if (typeof ensureSegLayer === 'function') {
    for (i=0;i<N;i++){ for (j=0;j<N;j++){ var L = ensureSegLayer(i,j); if(L){ L.v.style.display='none'; L.h.style.display='none'; } } }
  }
  // --- REAL-ból teljes újrarajz (végén drawPointsOverlay is fut) ---
  redrawFromRealAll();
}


/* ====== STUB AUTOMATIZMUSOK – csak logolnak, amíg a végleges szabály elkészül ====== */
window.recomputeWaterPoints2a = function recomputeWaterPoints2a(){
  

  // Közvetlenül M_REAL / P_REAL, helper nélkül
  const S = window.SMY || {};
  const MR = S.M_REAL;
  const PR = S.P_REAL;

  if (!MR || !PR || !MR.length || !PR.length){
    
    
    return 0;
  }

  const N  = MR.length;
  const PRows = PR.length;
  const PCols = PR[0].length;
  let applied = 0;

  
  // P(i,j) vízpont, ha a megfelelő 2×2 M_REAL blokk minden eleme vízmező (V/0/1/2/3/4)
  for (let r = 0; r < N-1 && r < PRows; r++){
    for (let c = 0; c < N-1 && c < PCols; c++){
      const tl = MR[r]     && MR[r][c];
      const tr = MR[r]     && MR[r][c+1];
      const bl = MR[r + 1] && MR[r+1][c];
      const br = MR[r + 1] && MR[r+1][c+1];
      if (!tl || !tr || !bl || !br) continue;

      const t0 = tl[0], t1 = tr[0], t2 = bl[0], t3 = br[0];

      
      if (!(
        (t0 === 'V' || t0 === '0' || t0 === '1' || t0 === '2' || t0 === '3' || t0 === '4') &&
        (t1 === 'V' || t1 === '0' || t1 === '1' || t1 === '2' || t1 === '3' || t1 === '4') &&
        (t2 === 'V' || t2 === '0' || t2 === '1' || t2 === '2' || t2 === '3' || t2 === '4') &&
        (t3 === 'V' || t3 === '0' || t3 === '1' || t3 === '2' || t3 === '3' || t3 === '4')
      )){
        continue;
      }

      const cur = PR[r] && PR[r][c];

      
      if (cur === 'H' || cur === 'V') continue;

      if (!PR[r]) continue;
      PR[r][c] = 'V';
      applied++;
    }
  }

  if (applied > 0){
    VALTOZAS = true;
  }

  
  
  return applied;
};

window.auto_9_rowWaterline_fill = function auto_9_rowWaterline_fill(){
  
  var applied = 0;
  {
    var S = window.SMY || window.S || {};
    var MR = S && S.M_REAL;
    if(!S || !MR || !MR.length){
      
      
      return 0;
    }
    var N = MR.length;

    
    var totalVV = (typeof window.VIZVONALAKSZAMA === 'number') ? window.VIZVONALAKSZAMA : 0;
    var nKH     = (typeof window.KIKOTOTTHAJOKSZAMA === 'number') ? window.KIKOTOTTHAJOKSZAMA : 0;

    var foundVV = 0;
    var sr = Array.isArray(S.SOROK_REAL) ? S.SOROK_REAL : [];
      var or = Array.isArray(S.OSZL_REAL)  ? S.OSZL_REAL  : [];
      for(var i=0;i<sr.length;i++) if(sr[i] === 'V') foundVV++;
      for(var j=0;j<or.length;j++) if(or[j] === 'V') foundVV++;

    var freeVV = totalVV - foundVV;
    try{  }catch(_){}

    // szabály: ha a szabad vízvonalak száma + nKH = 4, akkor a part menti vízvonalak Z státuszt kapnak
    if(freeVV + nKH !== 4){
      
      
      return 0;
    }

    if(!Array.isArray(S.SOROK_REAL)) S.SOROK_REAL = Array(N).fill('-');
    if(!Array.isArray(S.OSZL_REAL))  S.OSZL_REAL  = Array(N).fill('-');

    // négy partvonal Z jelölése (sor 0,8; oszlop 0,8) – a további automatikák (pl. 13) ebből indulhatnak ki
    if(N > 0){
      if(S.SOROK_REAL[0] !== 'Z'){ S.SOROK_REAL[0] = 'Z'; applied++; }
      if(S.SOROK_REAL[N-1] !== 'Z'){ S.SOROK_REAL[N-1] = 'Z'; applied++; }
      if(S.OSZL_REAL[0] !== 'Z'){ S.OSZL_REAL[0] = 'Z'; applied++; }
      if(S.OSZL_REAL[N-1] !== 'Z'){ S.OSZL_REAL[N-1] = 'Z'; applied++; }
    }

  }
  
  
  return applied;
};


window.auto_21a_bridge = function auto_21a_bridge(){
  
  
  let applied = 0;
  
  
  return applied;
};

function auto_21b_bridge(){
  
  let applied = 0;
  
  
  return applied;
};

window.auto_11_shoreExtension = function auto_11_shoreExtension(){
  
  let applied = 0;

  {
    
    if (!window.CFG || !CFG.auto || CFG.auto.auto11 === false) {
      
    } else {
      var S = window.SMY || window.S || {};
      var MR = (S && S.M_REAL) || (typeof M_REAL !== 'undefined' ? M_REAL : null);
      if (MR && MR.length) {
        var N = MR.length;
        for (var r = 0; r < N; r++) {
          for (var c = 0; c < N; c++) {
            var cell = MR[r][c];
            if (!cell) continue;
            var main = String(cell[0] || '-').toUpperCase();
            if (main === 'A' || main === 'B' || main === 'G' || main === 'D') {
              
              if (r === 0 || c === 0 || r === N - 1 || c === N - 1) {
                var a = tryEdgeCompletion(r, c, main) || 0;
                if (a) applied += a;
              }
            }
          }
        }
      }
    }
  }

  
  
  return applied;
}
;

window.auto_21_extendFromPairs = function auto_21_extendFromPairs(){
  
  let applied = 0;
  try{
    const r = (typeof window.tryExtendFromPairs === 'function') ? window.tryExtendFromPairs() : undefined;
    if (typeof r === 'number' && isFinite(r)) applied = (r|0);
  }catch(e){
    {  }
  }
  {  }
  
  return applied;
};

window.auto_21a_bridge = function auto_21a_bridge(){

  var applied = 0;
  {
    var S = window.SMY || window.S || {};
    var MR = S && S.M_REAL;
    if(!S || !MR || !MR.length){
      return 0;
    }
    var N = MR.length;
    if(typeof window.setCellShip !== 'function'){
      return 0;
    }

    function tAt(r,c){
      if(r<0||c<0||r>=N) return '?';
      var row = MR[r];
      if(!row || c>=row.length) return '?';
      var code = row[c];
      if(typeof code !== 'string') return '?';
      return code.charAt(0);
    }
    function isALFA(r,c){ return tAt(r,c) === 'A'; }

    // Köztes cellák megengedett típusa: üres '-' vagy határozatlan hajó 'H' (vagy már eleve 'A')
    function okBridgeCellT(t){ return (t === '-' || t === 'H' || t === 'A'); }

    // Az 'A' hajó hossza 4 (lengthOfShipCode('A')=4)
    var maxLen = 4;

    var oriDetected = null;

    function pushSegmentsInRow(r){
      var segs = [];
      var c = 0;
      while(c < N){
        if(!isALFA(r,c)){ c++; continue; }
        var s = c;
        while(c+1 < N && isALFA(r,c+1)) c++;
        var e = c;
        segs.push({ start: s, end: e, len: (e-s+1) });
        c++;
      }
      return segs;
    }
    function pushSegmentsInCol(c){
      var segs = [];
      var r = 0;
      while(r < N){
        if(!isALFA(r,c)){ r++; continue; }
        var s = r;
        while(r+1 < N && isALFA(r+1,c)) r++;
        var e = r;
        segs.push({ start: s, end: e, len: (e-s+1) });
        r++;
      }
      return segs;
    }

    // Sorok: két ALFA-szegmens közti hidalás (össz-hossz <=4, és egyik szegmens sem teljes)
    for(var r=0; r<N; r++){
      var segs = pushSegmentsInRow(r);
      if(segs.length < 2) continue;
      for(var i=0; i<segs.length-1; i++){
        var s1 = segs[i], s2 = segs[i+1];
        var c1 = s1.end, c2 = s2.start;
        if(c2 - c1 <= 1) continue; // nincs köztes
        if(s1.len >= maxLen || s2.len >= maxLen) continue;

        var mergedSpan = (s2.end - s1.start + 1);
        if(mergedSpan > maxLen) continue;

        var ok = true;
        for(var cc=c1+1; cc<c2; cc++){
          var t = tAt(r,cc);
          if(!okBridgeCellT(t)){ ok = false; break; }
        }
        if(!ok) continue;

        for(var cc2=c1+1; cc2<c2; cc2++){
          var t2 = tAt(r,cc2);
          if(t2 === '-' || t2 === 'H'){
            setCellShip(r, cc2, 'A', '-');
            applied++;
          }
        }
        if(!oriDetected) oriDetected = 'H';
      }
    }

    // Oszlopok: két ALFA-szegmens közti hidalás (össz-hossz <=4, és egyik szegmens sem teljes)
    for(var c=0; c<N; c++){
      var segs2 = pushSegmentsInCol(c);
      if(segs2.length < 2) continue;
      for(var j=0; j<segs2.length-1; j++){
        var t1 = segs2[j], t2s = segs2[j+1];
        var r1 = t1.end, r2 = t2s.start;
        if(r2 - r1 <= 1) continue;
        if(t1.len >= maxLen || t2s.len >= maxLen) continue;

        var mergedSpan2 = (t2s.end - t1.start + 1);
        if(mergedSpan2 > maxLen) continue;

        var ok2 = true;
        for(var rr=r1+1; rr<r2; rr++){
          var tt = tAt(rr,c);
          if(!okBridgeCellT(tt)){ ok2 = false; break; }
        }
        if(!ok2) continue;

        for(var rr2=r1+1; rr2<r2; rr2++){
          var tt2 = tAt(rr2,c);
          if(tt2 === '-' || tt2 === 'H'){
            setCellShip(rr2, c, 'A', '-');
            applied++;
          }
        }
        if(!oriDetected) oriDetected = 'V';
      }
    }

    // Indikátor (ha még nincs) – csak ugyanazt az abszolút irányt állítja, amit a híd sugall.
    if(applied > 0 && oriDetected){
      try{
        var st = window.STATE || window.SMY_STATE || {};
        if(!st.alfaOri && typeof window.setAlfaOri === 'function'){
          setAlfaOri(oriDetected);
        }
      }catch(_){}
    }
  }

  return applied;
};


window.auto_21b_bridge = function auto_21b_bridge(){
  
  let applied = 0;
  
  
  return applied;
};

</script>


<script id="futmon1115A_js">

/*(function(){
  {
    window.FUTOTT = window.FUTOTT || [];
    window.FUTNEV = window.FUTNEV || [];
    window.FUTID  = window.FUTID  || {};
    var nextId = window.FUTNEV.length;

    function futmonRegister(name){
      if(!name) return -1;
      if(Object.prototype.hasOwnProperty.call(window.FUTID, name)){
        return window.FUTID[name];
      }
      var id = nextId++;
      window.FUTID[name] = id;
      window.FUTNEV[id]  = name;
      if(typeof window.FUTOTT[id] !== 'number') window.FUTOTT[id] = 0;
      return id;
    }

    // Automatikus wrap: minden nem natív, globális JS-függvényre
    Object.keys(window).forEach(function(key){
      try{
        var v = window[key];
        if(typeof v !== 'function') return;
        if(v.__futmonWrapped) return;

        var src = Function.prototype.toString.call(v);
        if(src.indexOf('[native code]') !== -1) return;

        // Pár belső/helper név kihagyása
        if(key === 'futmonDump' || key === 'downloadTextFile') return;

        var id = futmonRegister(key);
        var orig = v;
        function wrapped(){
          window.FUTOTT[id] = (window.FUTOTT[id]||0) + 1;
          return orig.apply(this, arguments);
        }
        wrapped.__futmonWrapped = true;
        window[key] = wrapped;
      }catch(e){}
    });

    // TXT letöltés helper (általános)
    window.downloadTextFile = window.downloadTextFile || function(filename, text){
      try{
        var blob = new Blob([text], {type:'text/plain'});
        var url  = URL.createObjectURL(blob);
        var a    = document.createElement('a');
        a.href = url;
        a.download = filename || 'FUTOTT.txt';
        document.body.appendChild(a);
        a.click();
        setTimeout(function(){ URL.revokeObjectURL(url); a.remove(); }, 1000);
      }catch(e){
        console.warn('downloadTextFile failed', e);
      }
    };

    // FUTOTT dump → FUTOTT_YYYYMMDD_hhmmss.txt
    window.futmonDump = function futmonDump(){
      try{
        var now = new Date();
        var pad = function(n){ return String(n).padStart(2,'0'); };
        var ts  = now.getFullYear() +
                  pad(now.getMonth()+1) +
                  pad(now.getDate()) + '_' +
                  pad(now.getHours()) +
                  pad(now.getMinutes()) +
                  pad(now.getSeconds());

        var lines = [];
        lines.push('# FUTMON – függvény-futásszámláló');
        lines.push('# timestamp=' + now.toISOString());

        // Gyűjtés és rendezés: növekvő futásszám szerint (azonosnál ID szerint)
        var items = [];
        for(var i=0;i<window.FUTNEV.length;i++){
          var name = window.FUTNEV[i] || ('<ID '+i+'>');
          var cnt  = window.FUTOTT[i] || 0;
          items.push({ i: i, name: name, cnt: cnt });
        }
        items.sort(function(a,b){
          if(a.cnt !== b.cnt) return a.cnt - b.cnt;
          return a.i - b.i;
        });

        items.forEach(function(it){
          lines.push(String(it.i).padStart(3,'0') + '  ' + it.name + '  ' + it.cnt);
        });

        var txt  = lines.join('\n');
        var file = 'FUTOTT_' + ts + '.txt';
        window.downloadTextFile(file, txt);
      }catch(e){
        console.warn('FUTMON dump error', e);
      }
    };

    // Gomb a toolbar végén: FUTMON LOG
    (function(){
      try{
        var tb = document.querySelector('.toolbar');
        if(tb && !tb.__futmon){
          tb.__futmon = true;
          var grp = document.createElement('div');
          grp.className = 'group';
          var btn = document.createElement('button');
          btn.textContent = 'FUTMON LOG';
          btn.addEventListener('click', function(){
            if(typeof window.futmonDump === 'function'){ window.futmonDump(); }
          });
          grp.appendChild(btn);
          tb.appendChild(grp);
        }
      }catch(e){}
    })();

  }
})();*/
</script>



<script>




function setFolytatZold(on){
  var btn = document.getElementById('elvet'); 
  if(!btn) return;
  if(on){
    btn.style.background = '#eaffea';      
    btn.style.border     = '1px solid #9bd49b';
    btn.style.color      = '#0a6d0a';
  } else {
    btn.style.background = '#eee';         
    btn.style.border     = '1px solid #cfcfcf';
    btn.style.color      = '#444';
  }
}

</script>

<script>
// === K/H/M automatizmus-profilok: Kiválasztás + kiírás/beolvasás (AUTOMfile_KHMt alapján) ===
(function(){
  
  // "1: hajó sarkaira víz"    -> "auto1"
  // "2a: V-pont körül..."     -> "auto2a"
  // "3–4–5: ..."              -> "auto3_4_5"
  // "23/a: ..."               -> "auto23_a"
  function SMY_profileKeyFromLabel(label){
    var s = (label || '').trim();
    if (!s) return null;
    var m = s.match(/^([0-9][0-9a-zA-Z\/\u2013\u2014\-]*)\s*:/);
    if (!m) return null;
    var code = m[1];
    
    code = code.replace(/[\/\u2013\u2014\-]+/g, '_');
    return 'auto' + code;
  }

  function getAutoRowsContext(){
    var host = document.getElementById('autoRows');
    if (!host) return null;
    var boxes = host.querySelectorAll('input[type="checkbox"][id^="sw_"]');
    if (!boxes || !boxes.length) return null;
    var rows = [];
    boxes.forEach(function(cb){
      var key = cb.id.replace(/^sw_/, '');
      var labelText = '';
      var lab = cb.closest ? cb.closest('label') : null;
        if (lab && lab.textContent) labelText = lab.textContent;
      if (!labelText){
        
        var p = cb.parentNode;
        while (p && p.nodeType === 1 && String(p.tagName).toLowerCase() !== 'label'){
          p = p.parentNode;
        }
        if (p && p.tagName && String(p.tagName).toLowerCase() === 'label' && p.textContent){
          labelText = p.textContent;
        }
      }
      labelText = (labelText || '').replace(/\s+/g, ' ').trim();
      var pKey = SMY_profileKeyFromLabel(labelText) || key;
      rows.push({ checkbox: cb, key: key, label: labelText, pKey: pKey });
    });
    var S = window.SMY = window.SMY || {};
    S.AUTO_ROWS = rows;
    return rows;
  }

  function ensureAutoProfiles(){
    var S = window.SMY = window.SMY || {};
    if (!S.AUTO_PROFILES){
      S.AUTO_PROFILES = { K:{}, H:{}, M:{} };
    } else {
      S.AUTO_PROFILES.K = S.AUTO_PROFILES.K || {};
      S.AUTO_PROFILES.H = S.AUTO_PROFILES.H || {};
      S.AUTO_PROFILES.M = S.AUTO_PROFILES.M || {};
    }
    if (!S.AUTO_PROFILE_CURRENT || !/^[KHM]$/.test(S.AUTO_PROFILE_CURRENT)){
      S.AUTO_PROFILE_CURRENT = 'K';
    }
    return S;
  }

  function freezeCurrentProfileFromCheckboxes(){
    var S = ensureAutoProfiles();
    var rows = S.AUTO_ROWS || getAutoRowsContext();
    if (!rows || !rows.length) return;
    var cur = S.AUTO_PROFILE_CURRENT || 'K';
    var prof = S.AUTO_PROFILES[cur] || (S.AUTO_PROFILES[cur] = {});
    rows.forEach(function(row){
      prof[row.pKey] = !!row.checkbox.checked;
    });
  }

  function applyProfileToCheckboxes(){
    var S = ensureAutoProfiles();
    var rows = S.AUTO_ROWS || getAutoRowsContext();
    if (!rows || !rows.length) return;
    var cur = S.AUTO_PROFILE_CURRENT || 'K';
    var prof = S.AUTO_PROFILES[cur] || (S.AUTO_PROFILES[cur] = {});
    rows.forEach(function(row){
      var has = Object.prototype.hasOwnProperty.call(prof, row.pKey);
      var val = has ? !!prof[row.pKey] : !!row.checkbox.checked;
      row.checkbox.checked = val;
      if (window.CFG && window.CFG.auto){
        window.CFG.auto[row.key] = val;
      }
    });
  }

  function hookCheckboxProfileSync(){
    var S = ensureAutoProfiles();
    var rows = S.AUTO_ROWS || getAutoRowsContext();
    if (!rows || !rows.length) return;
    rows.forEach(function(row){
      if (row.checkbox.__autoProfileBound) return;
      row.checkbox.addEventListener('change', function(){
        var S2 = ensureAutoProfiles();
        var cur = S2.AUTO_PROFILE_CURRENT || 'K';
        var prof = S2.AUTO_PROFILES[cur] || (S2.AUTO_PROFILES[cur] = {});
        prof[row.pKey] = !!row.checkbox.checked;
      });
      row.checkbox.__autoProfileBound = true;
    });
  }

  function setupProfileSelectorUi(){
    var S = ensureAutoProfiles();
    var rK = document.getElementById('autoProfile_K');
    var rH = document.getElementById('autoProfile_H');
    var rM = document.getElementById('autoProfile_M');

    function setRadioFromCurrent(){
      var cur = S.AUTO_PROFILE_CURRENT || 'K';
      if (rK) rK.checked = (cur === 'K');
      if (rH) rH.checked = (cur === 'H');
      if (rM) rM.checked = (cur === 'M');
    }

    function handler(){
      if (!this.checked) return;
      var v = this.value || 'K';
      if (v !== 'K' && v !== 'H' && v !== 'M') return;
      S.AUTO_PROFILE_CURRENT = v;
      applyProfileToCheckboxes();
    }

    [rK, rH, rM].forEach(function(r){
      if (!r || r.__autoProfBound) return;
      r.addEventListener('change', handler);
      r.__autoProfBound = true;
    });

    setRadioFromCurrent();
  }

  function exportProfilesToFile(){
    freezeCurrentProfileFromCheckboxes();
    var S = ensureAutoProfiles();
    var rows = S.AUTO_ROWS || getAutoRowsContext();
    if (!rows || !rows.length) return;

    var lines = [];
    var d = new Date();
    var yyyy = d.getFullYear();
    var mm = String(d.getMonth() + 1).padStart(2, '0');
    var dd = String(d.getDate()).padStart(2, '0');
    var dateStr = yyyy + '-' + mm + '-' + dd;

    lines.push('# SMYOZ EXPLORER – AUTOMATIZMUS PROFILOK (KEZDŐ / HALADÓ / MESTER)');
    lines.push('# Verzió: ' + dateStr);
    lines.push('#');
    lines.push('# Oszlopok:');
    lines.push('#   K = Kezdő profil');
    lines.push('#   H = Haladó profil');
    lines.push('#   M = Mester profil');
    lines.push('#');
    lines.push('# Jelölések:');
    lines.push("#   '+' = az adott profilban alapból bekapcsolva");
    lines.push("#   '-' = az adott profilban alapból kikapcsolva");
    lines.push('#');
    lines.push('# A tényleges adat a következő jelölés utáni sorokban van:');
    lines.push('# ---AUTOS_DATA_START---');
    lines.push('');
    lines.push('# K H M  Leírás');
    lines.push('');

    var curProf = S.AUTO_PROFILE_CURRENT || 'K';
    rows.forEach(function(row){
      var pKey = row.pKey;
      var kVal = !!(S.AUTO_PROFILES.K && S.AUTO_PROFILES.K[pKey]);
      var hVal = !!(S.AUTO_PROFILES.H && S.AUTO_PROFILES.H[pKey]);
      var mVal = !!(S.AUTO_PROFILES.M && S.AUTO_PROFILES.M[pKey]);
      
      if (curProf === 'K') {
        kVal = !!row.checkbox.checked;
      } else if (curProf === 'H') {
        hVal = !!row.checkbox.checked;
      } else if (curProf === 'M') {
        mVal = !!row.checkbox.checked;
      }
      var line = (kVal ? '+' : '-') + ' ' +
                 (hVal ? '+' : '-') + ' ' +
                 (mVal ? '+' : '-') + '  ' +
                 row.label;
      lines.push(line);
    });

    var txt = lines.join('\n');
    {
      var blob = new Blob([txt], { type: 'text/plain' });
      var url = URL.createObjectURL(blob);
      var a = document.createElement('a');
      var d2 = new Date();
      var date2 = d2.getFullYear().toString() +
                  String(d2.getMonth() + 1).padStart(2, '0') +
                  String(d2.getDate()).padStart(2, '0');
      a.href = url;
      a.download = 'SMYOZ AUTOMATIZMUSOK.txt';
      document.body.appendChild(a);
      a.click();
      setTimeout(function(){
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 0);
    }
  }
  function importProfilesFromText(txt){
    if (!txt) return;
    var S = ensureAutoProfiles();
    var rows = S.AUTO_ROWS || getAutoRowsContext();
    if (!rows || !rows.length) return;

    
    var map = {};
    rows.forEach(function(row){
      map[row.pKey] = row;
    });

    var lines = txt.split(/\r?\n/);
    var idxStart = -1;
    for (var i = 0; i < lines.length; i++){
      if (lines[i].indexOf('---AUTOS_DATA_START---') !== -1){
        idxStart = i;
        break;
      }
    }
    if (idxStart === -1) return;

    for (var j = idxStart + 1; j < lines.length; j++){
      var line = lines[j].trim();
      if (!line || line.charAt(0) === '#') continue;
      var m = line.match(/^([+-])\s+([+-])\s+([+-])\s+(.*)$/);
      if (!m) continue;
      var kCh = m[1], hCh = m[2], mCh = m[3];
      var desc = m[4] || '';
      var pKey = SMY_profileKeyFromLabel(desc);
      if (!pKey || !map[pKey]) continue;
      S.AUTO_PROFILES.K[pKey] = (kCh === '+');
      S.AUTO_PROFILES.H[pKey] = (hCh === '+');
      S.AUTO_PROFILES.M[pKey] = (mCh === '+');
    }

    
    applyProfileToCheckboxes();
  }

  function bindProfileButtons(){
    var exportBtn = document.getElementById('autoProfileExportBtn');
    var importBtn = document.getElementById('autoProfileImportBtn');
    var importInput = document.getElementById('autoProfileImportInput');

    if (exportBtn && !exportBtn.__autoProfExport){
      exportBtn.addEventListener('click', function(ev){
        ev.preventDefault();
        exportProfilesToFile();
      });
      exportBtn.__autoProfExport = true;
    }

    if (importBtn && importInput && !importBtn.__autoProfImportClick){
      importBtn.addEventListener('click', function(ev){
        ev.preventDefault();
        importInput.click();
      });
      importBtn.__autoProfImportClick = true;
    }

    if (importInput && !importInput.__autoProfImport){
      importInput.addEventListener('change', function(ev){
        var file = ev.target.files && ev.target.files[0];
        if (!file) return;
        var reader = new FileReader();
        reader.onload = function(e){
          importProfilesFromText(String(e.target.result || ''));
        };
        reader.readAsText(file);
        
        ev.target.value = '';
      });
      importInput.__autoProfImport = true;
    }
  }

  window.SMY_initAutoProfilesUi = function(){
    var rows = getAutoRowsContext();
      if (!rows || !rows.length) return;
      ensureAutoProfiles();
      hookCheckboxProfileSync();
      setupProfileSelectorUi();
      bindProfileButtons();
      // ha a profilok már tartalmaztak adatot, egyszer ráengedjük
      applyProfileToCheckboxes();
  };

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      if (typeof window.SMY_initAutoProfilesUi === 'function'){
        window.SMY_initAutoProfilesUi();
      }
    });
  } else {
    if (typeof window.SMY_initAutoProfilesUi === 'function'){
      window.SMY_initAutoProfilesUi();
    }
  }
})();
</script>


<script>
/* ====== Kompatibilitás: REAL vs SNAP (M/P + SOROK/OSZL) ====== */
(function(){
  'use strict';
  window.checkCompatibility = function checkCompatibility(r,c){
    try{
      var S = (typeof window!=='undefined' && (window.SMY || window.S)) ? (window.SMY || window.S) : {};
      var MR = S.M_REAL || [];
      var MS = S.M_SNAP || [];
      var PR = S.P_REAL || [];
      var PS = S.P_SNAP || [];
      var rowR = S.SOROK_REAL || [];
      var rowS = S.SOROK_SNAP || [];
      var colR = S.OSZL_REAL  || [];
      var colS = S.OSZL_SNAP  || [];

      function isWaterT(t){
        return t==='V' || t==='0' || t==='1' || t==='2' || t==='3' || t==='4';
      }
      function isShipT(t){
        return t==='A' || t==='B' || t==='G' || t==='D' || t==='H';
      }

      // 1) MATRIX: vízből hajó / hajóból víz NEM megengedett
      var i,j;
      var maxR = Math.min(MR.length, MS.length);
      for(i=0;i<maxR;i++){
        var rowNew = MR[i];
        var rowOld = MS[i];
        if(!rowNew || !rowOld) continue;
        var maxC = Math.min(rowNew.length, rowOld.length);
        for(j=0;j<maxC;j++){
          var oldCode = rowOld[j];
          var newCode = rowNew[j];
          var oldStr  = (oldCode==null) ? '' : String(oldCode);
          var newStr  = (newCode==null) ? '' : String(newCode);
          var oldT    = oldStr ? oldStr.charAt(0) : '-';
          var newT    = newStr ? newStr.charAt(0) : '-';
          if(isWaterT(oldT) && isShipT(newT)) return false;
          if(isShipT(oldT) && isWaterT(newT)) return false;
        }
      }

      
      var maxPR = Math.min(PR.length, PS.length);
      for(i=0;i<maxPR;i++){
        var rowNP = PR[i] || [];
        var rowOP = PS[i] || [];
        var maxPC = Math.min(rowNP.length, rowOP.length);
        for(j=0;j<maxPC;j++){
          var oldP = rowOP[j] || '-';
          var newP = rowNP[j] || '-';
          if((oldP==='H' && newP==='V') || (oldP==='V' && newP==='H')) return false;
        }
      }

      // 3) SOROK/OSZL: vektor kompatibilitás
      function vecOk(oldV, newV){
        oldV = (oldV==null) ? '-' : String(oldV).charAt(0);
        newV = (newV==null) ? '-' : String(newV).charAt(0);
        if(oldV === newV) return true;

        
        if(oldV === '-'){
          if(newV === '-') return true;
          if(newV === 'P' || newV === 'Z' || newV === 'V') return true;
          return true; 
        }

        
        
        if(newV === '-') return false;
        if(oldV === 'Z' && newV === 'P') return false;
        if(oldV === 'P' && newV === 'Z') return false;
        if(oldV === 'V' && (newV === 'P' || newV === 'Z')) return false;

        
        if(oldV === 'Z' && newV === 'V') return true;

        
        return true;
      }

      var L = Math.min(rowR.length, rowS.length);
      for(i=0;i<L;i++){
        if(!vecOk(rowS[i], rowR[i])) return false;
      }
      L = Math.min(colR.length, colS.length);
      for(i=0;i<L;i++){
        if(!vecOk(colS[i], colR[i])) return false;
      }

      // Shore red-perpendicular check (warning only; no auto-fix here)
      try{
        var N = 9;
        for(var rr=0; rr<N; rr++){
          for(var cc=0; cc<N; cc++){
            var onTop = (rr===0), onBottom=(rr===(N-1)), onLeft=(cc===0), onRight=(cc===(N-1));
            if(!(onTop||onBottom||onLeft||onRight)) continue;
            if((onTop||onBottom) && (onLeft||onRight)) continue; // corner
            var cell = String((MR[rr] && MR[rr][cc]) || '---').toLowerCase();
            var v = cell.charAt(1), h = cell.charAt(2);
            var pc = (v==='p') + (h==='p');
            if(pc!==1) continue;
            if((onTop||onBottom) && v==='p') return false;
            if((onLeft||onRight) && h==='p') return false;
          }
        }
      }catch(_){ }

      return true;
    }catch(e){
      
      
      return true;
    }
  };
})();
</script>






<style>
  .smyHelpBody{
    font-size:21px;
    line-height:1.5;
  }
</style>
<div id="smyozHelpOverlay" style="display:none;position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:1000;align-items:center;justify-content:center;">
  <div id="smyozHelpPanel" style="background:#ffffff;border-radius:10px;box-shadow:0 4px 16px rgba(0,0,0,0.35);max-width:90vw;max-height:80vh;width:640px;display:flex;flex-direction:column;">
    <div style="display:flex;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid #dde3f0;">
      <div style="font-weight:800;font-size:26px;">SMYOZ  --  tengeri csata</div>
      <button onclick="toggleSmyozHelp(false)" style="border:none;background:transparent;font-size:18px;font-weight:700;cursor:pointer;line-height:1;">×</button>
    </div>
    <div id="smyozHelpContent" class="smyHelpBody" style="padding:8px 12px;overflow:auto;">
      
	  <h3>0. A SMYOZ EXPLORER a SMYOZ GENERÁTOR által előállított elrendezés felderítője </h3>
      <h3>1. SMYOZ EXPLORER áttekintés </h3>
      <ul>
        <li>9×9-es táblán 10 hajó (20 hajómező) és 61 vízmező, szinezéssel</li>
        <li>Flotta: ALFA (1x4 mező), BETA (2x3 mező), GAMMA (3x2 mező), DELTA (4x1 mező)</li>
        <li>A hajók elrendezése rejtett, amit lövésekkel és következtetéssel kell kideríteni .</li>
        <li>Minden [oszlop,sor] lövésre mezőtípus (hajó vagy víz) és szín(pár) a válasz</li>		
		<li>A rejtett elrendezés kiderítését az EXPLORER számos opcionális AUTOMATIZMUSsal támogatja.</li>
      </ul>

      <h3>2. Az elrendezés öt szabálya </h3>
      <ul>
        <li><b>Sarok:</b> hajók sehol sem érintkezhetnek </li>
        <li><b>Csúcs:</b> szemben álló hajócsúcsok(végek) között legalább két vízmező legyen</li>
        <li><b>Kikötés:</b> hajót csak egy csúcsával szabad a partvonalhoz kötni</li>
        <li><b>Centrum:</b> azonos típusú hajók középpontjai nem állhatnak azonos sorban vagy oszlopban</li>
        <li><b>Oldal:</b> egymás mellett álló hajók között legalább két vízmező távolság legyen, ha az átfedésük egy mezőnél hosszabb</li>
      </ul>

      <h3>3. Színes vonalak és pontok</h3>
      <ul>
        <li>Minden sorban és oszlopban pontosan egy színes vonal (piros vagy zöld) fut:</li>
        <li><b>Vízvonal (zöld):</b> ha egy sor/oszlopban nincs hajómező, akkor zöld vízvonal fut rajta végig</li>
		<li><b>Zöld vonal:</b> ha egy sor/oszlopban csak egy hajó van, a hajó belsejében zöld vonal fut</li>
        <li><b>Piros vonal:</b> ha egy sor/oszlop több hajót tartalmaz, a két szélső hajó között "feszül" a piros vonal, és közöttük minden hajó- és vízmező piros</li>
        <li>A mezőket elválasztó vonalak metszései vízpontok vagy hajópontok, a szomszédos vízpontok szigeteket alkotnak</li>
		
      </ul>

      <h3>4. Lövések </h3>
      <ul>
        <li>Egy lövés: mező [oszlop,sor] index vagy kijelölás egérrel </li>
        <li>Hajómező: A, B, G, D és szinezés: p pp z zz pz x (színtelen) </li>
        <li>Vízmező: 0, 1, 2, 3, 4 (a mező sarkain lévő vízpontok száma) és szinezés, mint fenn</li>

      </ul>

      <h3>5. Az EXPLORER használata</h3>
      <ul>
        <li><b>INDULÁS:</b> Tallózás / Bemásolás (SEED.txt) tartalom megadása, BETÖLTÉS gomb</li>
        <li><b>Lövés leadása:</b> Célmező kijelölése, LÖVÉS gomb.</li>
        <li><b>Következtetés:</b> MŰHELY + bekapcsolt AUTOMATIZMUSok, („MINDEN AUTOMATIZMUS FUT” gomb)</li>
        <li><b>Műhely:</b> mezők építése és (3 lépéses) ELHELYEZése / ELVETése </li>
		<li><b>  </b>    az ELVET visszaállítja az ELHELYEZés illetve a FOLYTATás előtti állapotot</li>
        <li><b>Módok: </b>EDZÉSben minden érintett mező tartalma látszik, JÁTÉKban csak a "jogosak"  </li>
		<li><b>Eszközök: </b>TÖRLÉS   MENTÉS   VISSZATÖLTÉS   AUTOMATIMUSOK   ÚJ RAJZ   SÚGÓ</li>
		<li><b>AUTOMATIZMUSOK: </b>Menthető/Betölthető Menűválaszték 3 listával</li>
      </ul>
      <h3>       </h3>	  
      <li>     Köszönet <b> HENNYEY ZOLTÁN</b>nak, a SMYOZ atyjának</li>
 	  <li>                   a Hálás Utókor </li>

	  
      
    </div>
  </div>
</div>

<script>
function toggleSmyozHelp(show){
  var ov = document.getElementById('smyozHelpOverlay');
  if (!ov) return;
  if (typeof show === 'boolean'){
    ov.style.display = show ? 'flex' : 'none';
  } else {
    ov.style.display = (ov.style.display === 'flex') ? 'none' : 'flex';
  }
}

document.addEventListener('click', function(ev){
  var ov = document.getElementById('smyozHelpOverlay');
  if (!ov) return;
  if (ov.style.display === 'flex' && ev.target === ov){
    toggleSmyozHelp(false);
  }
});

document.addEventListener('keydown', function(ev){
  var ov = document.getElementById('smyozHelpOverlay');
  if (!ov) return;
  if (ov.style.display === 'flex' && (ev.key === 'Escape' || ev.key === 'Esc')){
    toggleSmyozHelp(false);
  }
});
</script>









<script>
(function(){
  function ready(fn){
    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', fn);
    } else {
      fn();
    }
  }
  ready(function(){
    {
      var labels = [
        'TÖRLÉS',
        'MENTÉS',
        'VISSZATÖLTÉS',
        'BETÖLTÉS',
        'MINDEN AUTOMATIZMUS FUT',
        'MINDEN AUT',
        'ÚJ RAJZ'
      ];
      function shouldFlash(btn){
        var t = (btn.textContent || '').trim().toUpperCase();
        for (var i = 0; i < labels.length; i++){
          if (t.indexOf(labels[i]) !== -1) return true;
        }
        return false;
      }
      function flashBtn(btn){
        try{
          var oldBox = btn.style.boxShadow;
          var oldBg  = btn.style.backgroundColor;
          btn.style.boxShadow = '0 0 0 3px rgba(255,255,0,0.9)';
          btn.style.backgroundColor = '#fff9c4';
          setTimeout(function(){
            btn.style.boxShadow = oldBox;
            btn.style.backgroundColor = oldBg;
          }, 60);
        }catch(e){}
      }
      var allButtons = document.querySelectorAll('button');
      for (var j = 0; j < allButtons.length; j++){
        var b = allButtons[j];
        if (!shouldFlash(b)) continue;
        if (b.__smyFlash) continue;
        b.addEventListener('click', function(ev){
          if (!ev || ev.isTrusted === false) return;
          flashBtn(this);
        });
        b.__smyFlash = true;
      }
    }
  });
})();
</script>

<script>
(function(){
  function stop(e){ if(!e) return; if(typeof e.stopPropagation==='function') e.stopPropagation(); }
  function attach(){
    var cb = document.getElementById('muhely_ovatos_toggle');
    if(!cb) return;
    cb.style.pointerEvents = 'auto';
    var lbl = (cb.closest && cb.closest('label')) ? cb.closest('label') : null;
    if(lbl){
      lbl.style.pointerEvents = 'auto';
      lbl.addEventListener('mousedown', stop, true);
      lbl.addEventListener('click', stop, true);
    }
    cb.addEventListener('mousedown', stop, true);
    cb.addEventListener('click', stop, true);
  }
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', attach);
  else attach();
})();
</script>

</body></html>